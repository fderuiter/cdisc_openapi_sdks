/**
 * CDISC Library API
 * REST API Documentation for CDISC Library in production server
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: cdisc_library_support@cdisc.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as $ from 'jquery';
import * as models from '../model/models';
import { COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


export class SearchesApi {
    protected basePath = 'https://library.cdisc.org/api';
    public defaultHeaders: Array<string> = [];
    public defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings = undefined;
    public configuration: Configuration = new Configuration();

    constructor(basePath?: string, configuration?: Configuration, defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
        if (defaultExtraJQueryAjaxSettings) {
            this.defaultExtraJQueryAjaxSettings = defaultExtraJQueryAjaxSettings;
        }
    }

    private extendObj<T1 extends object, T2 extends T1>(objA: T2, objB: T2): T1|T2 {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return objA;
    }

    /**
     * Get Search Results Across CDISC Library
     * @param q Search Term Expression
     * @param highlight Search Highlight Expression
     * @param start Initial Search Result Index
     * @param pageSize Number of Search Results to Return
     * @param _class Limit Search by Setting Scope to Class
     * @param codelist Limit Search by Setting Scope to Codelist
     * @param conceptId Limit Search by Setting Scope to Concept ID
     * @param core Limit Search by Setting Scope to Core
     * @param dataStructure Limit Search by Setting Scope to Data Structure
     * @param datasetStructure Limit Search by Setting Scope to Dataset Structure
     * @param definition Limit Search by Setting Scope to Definition
     * @param description Limit Search by Setting Scope to Description
     * @param domain Limit Search by Setting Scope to Domain
     * @param effectiveDate Limit Search by Setting Scope to Effective Date
     * @param extensible Limit Search by Setting Scope to Extensible
     * @param href Limit Search by Setting Scope to Href
     * @param label Limit Search by Setting Scope to Label
     * @param measureType SLimit Search by Setting Scope to Measure Type
     * @param name Limit Search by Setting Scope to Name
     * @param preferredTerm Limit Search by Setting Scope to Preferred Term
     * @param product Limit Search by Setting Scope to Product
     * @param productGroup Limit Search by Setting Scope to Product Group
     * @param registrationStatus Limit Search by Setting Scope to Registration Status
     * @param roleDescription Limit Search by Setting Scope to Role Description
     * @param sdtmTarget Limit Search by Setting Scope to SDTM Target
     * @param simpleDatatype Limit Search by Setting Scope to Simple Datatype
     * @param submissionValue Limit Search by Setting Scope to Submission Value
     * @param synonyms Limit Search by Setting Scope to Synonyms
     * @param type Limit Search by Setting Scope to Type
     * @param uiHref Limit Search by Setting Scope to UI Href
     * @param valueDomain Limit Search by Setting Scope to Value Domain
     * @param variableSet Limit Search by Setting Scope to Variable Set
     * @param version Limit Search by Setting Scope to Version
     */
    public mdrSearchGet(q: string, highlight?: string, start?: number, pageSize?: number, _class?: string, codelist?: string, conceptId?: string, core?: string, dataStructure?: string, datasetStructure?: string, definition?: string, description?: string, domain?: string, effectiveDate?: string, extensible?: string, href?: string, label?: string, measureType?: string, name?: string, preferredTerm?: string, product?: string, productGroup?: string, registrationStatus?: string, roleDescription?: string, sdtmTarget?: string, simpleDatatype?: string, submissionValue?: string, synonyms?: string, type?: string, uiHref?: string, valueDomain?: string, variableSet?: string, version?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.DefaultSearchResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/mdr/search';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling mdrSearchGet.');
        }

        if (q !== null && q !== undefined) {
            queryParameters['q'] = <string><any>q;
        }
        if (highlight !== null && highlight !== undefined) {
            queryParameters['highlight'] = <string><any>highlight;
        }
        if (start !== null && start !== undefined) {
            queryParameters['start'] = <string><any>start;
        }
        if (pageSize !== null && pageSize !== undefined) {
            queryParameters['pageSize'] = <string><any>pageSize;
        }
        if (_class !== null && _class !== undefined) {
            queryParameters['class'] = <string><any>_class;
        }
        if (codelist !== null && codelist !== undefined) {
            queryParameters['codelist'] = <string><any>codelist;
        }
        if (conceptId !== null && conceptId !== undefined) {
            queryParameters['conceptId'] = <string><any>conceptId;
        }
        if (core !== null && core !== undefined) {
            queryParameters['core'] = <string><any>core;
        }
        if (dataStructure !== null && dataStructure !== undefined) {
            queryParameters['dataStructure'] = <string><any>dataStructure;
        }
        if (datasetStructure !== null && datasetStructure !== undefined) {
            queryParameters['datasetStructure'] = <string><any>datasetStructure;
        }
        if (definition !== null && definition !== undefined) {
            queryParameters['definition'] = <string><any>definition;
        }
        if (description !== null && description !== undefined) {
            queryParameters['description'] = <string><any>description;
        }
        if (domain !== null && domain !== undefined) {
            queryParameters['domain'] = <string><any>domain;
        }
        if (effectiveDate !== null && effectiveDate !== undefined) {
            queryParameters['effectiveDate'] = <string><any>effectiveDate;
        }
        if (extensible !== null && extensible !== undefined) {
            queryParameters['extensible'] = <string><any>extensible;
        }
        if (href !== null && href !== undefined) {
            queryParameters['href'] = <string><any>href;
        }
        if (label !== null && label !== undefined) {
            queryParameters['label'] = <string><any>label;
        }
        if (measureType !== null && measureType !== undefined) {
            queryParameters['measureType'] = <string><any>measureType;
        }
        if (name !== null && name !== undefined) {
            queryParameters['name'] = <string><any>name;
        }
        if (preferredTerm !== null && preferredTerm !== undefined) {
            queryParameters['preferredTerm'] = <string><any>preferredTerm;
        }
        if (product !== null && product !== undefined) {
            queryParameters['product'] = <string><any>product;
        }
        if (productGroup !== null && productGroup !== undefined) {
            queryParameters['productGroup'] = <string><any>productGroup;
        }
        if (registrationStatus !== null && registrationStatus !== undefined) {
            queryParameters['registrationStatus'] = <string><any>registrationStatus;
        }
        if (roleDescription !== null && roleDescription !== undefined) {
            queryParameters['roleDescription'] = <string><any>roleDescription;
        }
        if (sdtmTarget !== null && sdtmTarget !== undefined) {
            queryParameters['sdtmTarget'] = <string><any>sdtmTarget;
        }
        if (simpleDatatype !== null && simpleDatatype !== undefined) {
            queryParameters['simpleDatatype'] = <string><any>simpleDatatype;
        }
        if (submissionValue !== null && submissionValue !== undefined) {
            queryParameters['submissionValue'] = <string><any>submissionValue;
        }
        if (synonyms !== null && synonyms !== undefined) {
            queryParameters['synonyms'] = <string><any>synonyms;
        }
        if (type !== null && type !== undefined) {
            queryParameters['type'] = <string><any>type;
        }
        if (uiHref !== null && uiHref !== undefined) {
            queryParameters['uiHref'] = <string><any>uiHref;
        }
        if (valueDomain !== null && valueDomain !== undefined) {
            queryParameters['valueDomain'] = <string><any>valueDomain;
        }
        if (variableSet !== null && variableSet !== undefined) {
            queryParameters['variableSet'] = <string><any>variableSet;
        }
        if (version !== null && version !== undefined) {
            queryParameters['version'] = <string><any>version;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (basicAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.DefaultSearchResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.DefaultSearchResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get Search Results Across CDISC Library
     */
    public mdrSearchScopesGet(extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.MdrSearchScopesGet200Response;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/mdr/search/scopes';

        let queryParameters: any = {};
        let headerParams: any = {};

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (basicAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.MdrSearchScopesGet200Response;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.MdrSearchScopesGet200Response, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get Search Results Limited to Scope
     * @param scope Search Scope
     */
    public mdrSearchScopesScopeGet(scope: models.DefaultSearchScopes, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.ScopeValues;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/mdr/search/scopes/{scope}'.replace('{' + 'scope' + '}', encodeURIComponent(String(scope)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling mdrSearchScopesScopeGet.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (basicAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.ScopeValues;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.ScopeValues, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

}
