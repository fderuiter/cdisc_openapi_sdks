/** CDISC Library API
  * REST API Documentation for CDISC Library in production server
  *
  * The version of the OpenAPI document: 1.1.0
  * Contact: cdisc_library_support@cdisc.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package org.openapitools.client.apis

import cats.effect.Concurrent
import io.circe.Encoder
import org.http4s.Uri
import org.http4s.client.Client as Http4sClient
import org.openapitools.client.models.DefaultErrorResponse
import org.openapitools.client.models.DefaultSearchResponse
import org.openapitools.client.models.DefaultSearchScopes
import org.openapitools.client.models.MdrSearchScopesGet200Response
import org.openapitools.client.models.ScopeValues
import org.openapitools.client.models.*

trait SearchesApiEndpoints[F[*]] {

  def mdrSearchGet(`q`: String, highlight: Option[String] = None, start: Option[BigDecimal] = None, pageSize: Option[BigDecimal] = None, `class`: Option[String] = None, codelist: Option[String] = None, conceptId: Option[String] = None, core: Option[String] = None, dataStructure: Option[String] = None, datasetStructure: Option[String] = None, definition: Option[String] = None, description: Option[String] = None, domain: Option[String] = None, effectiveDate: Option[String] = None, extensible: Option[String] = None, href: Option[String] = None, label: Option[String] = None, measureType: Option[String] = None, name: Option[String] = None, preferredTerm: Option[String] = None, product: Option[String] = None, productGroup: Option[String] = None, registrationStatus: Option[String] = None, roleDescription: Option[String] = None, sdtmTarget: Option[String] = None, simpleDatatype: Option[String] = None, submissionValue: Option[String] = None, synonyms: Option[String] = None, `type`: Option[String] = None, uiHref: Option[String] = None, valueDomain: Option[String] = None, variableSet: Option[String] = None, version: Option[String] = None)(using auth: _Authorization.Basic): F[DefaultSearchResponse]
  def mdrSearchScopesGet()(using auth: _Authorization.Basic): F[MdrSearchScopesGet200Response]
  def mdrSearchScopesScopeGet(scope: DefaultSearchScopes)(using auth: _Authorization.Basic): F[ScopeValues]

}

class SearchesApiEndpointsImpl[F[*]: Concurrent](
  override val baseUrl: Uri,
  defaultHeaders: Seq[(String, String)] = Nil,
  httpClient: Http4sClient[F]
) extends BaseClient[F](baseUrl, defaultHeaders, httpClient) with SearchesApiEndpoints[F] {
  
  import JsonSupports.*
  import io.circe.syntax.EncoderOps
  import cats.implicits.toFlatMapOps

  override def mdrSearchGet(`q`: String, highlight: Option[String] = None, start: Option[BigDecimal] = None, pageSize: Option[BigDecimal] = None, `class`: Option[String] = None, codelist: Option[String] = None, conceptId: Option[String] = None, core: Option[String] = None, dataStructure: Option[String] = None, datasetStructure: Option[String] = None, definition: Option[String] = None, description: Option[String] = None, domain: Option[String] = None, effectiveDate: Option[String] = None, extensible: Option[String] = None, href: Option[String] = None, label: Option[String] = None, measureType: Option[String] = None, name: Option[String] = None, preferredTerm: Option[String] = None, product: Option[String] = None, productGroup: Option[String] = None, registrationStatus: Option[String] = None, roleDescription: Option[String] = None, sdtmTarget: Option[String] = None, simpleDatatype: Option[String] = None, submissionValue: Option[String] = None, synonyms: Option[String] = None, `type`: Option[String] = None, uiHref: Option[String] = None, valueDomain: Option[String] = None, variableSet: Option[String] = None, version: Option[String] = None)(using auth: _Authorization.Basic): F[DefaultSearchResponse] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten
    val queryParameters = (
      Some(Seq("q" -> `q`)) ++ 
      highlight.map("highlight" -> _).map(Seq(_)) ++ 
      start.map("start" -> _).map(Seq(_)) ++ 
      pageSize.map("pageSize" -> _).map(Seq(_)) ++ 
      `class`.map("class" -> _).map(Seq(_)) ++ 
      codelist.map("codelist" -> _).map(Seq(_)) ++ 
      conceptId.map("conceptId" -> _).map(Seq(_)) ++ 
      core.map("core" -> _).map(Seq(_)) ++ 
      dataStructure.map("dataStructure" -> _).map(Seq(_)) ++ 
      datasetStructure.map("datasetStructure" -> _).map(Seq(_)) ++ 
      definition.map("definition" -> _).map(Seq(_)) ++ 
      description.map("description" -> _).map(Seq(_)) ++ 
      domain.map("domain" -> _).map(Seq(_)) ++ 
      effectiveDate.map("effectiveDate" -> _).map(Seq(_)) ++ 
      extensible.map("extensible" -> _).map(Seq(_)) ++ 
      href.map("href" -> _).map(Seq(_)) ++ 
      label.map("label" -> _).map(Seq(_)) ++ 
      measureType.map("measureType" -> _).map(Seq(_)) ++ 
      name.map("name" -> _).map(Seq(_)) ++ 
      preferredTerm.map("preferredTerm" -> _).map(Seq(_)) ++ 
      product.map("product" -> _).map(Seq(_)) ++ 
      productGroup.map("productGroup" -> _).map(Seq(_)) ++ 
      registrationStatus.map("registrationStatus" -> _).map(Seq(_)) ++ 
      roleDescription.map("roleDescription" -> _).map(Seq(_)) ++ 
      sdtmTarget.map("sdtmTarget" -> _).map(Seq(_)) ++ 
      simpleDatatype.map("simpleDatatype" -> _).map(Seq(_)) ++ 
      submissionValue.map("submissionValue" -> _).map(Seq(_)) ++ 
      synonyms.map("synonyms" -> _).map(Seq(_)) ++ 
      `type`.map("type" -> _).map(Seq(_)) ++ 
      uiHref.map("uiHref" -> _).map(Seq(_)) ++ 
      valueDomain.map("valueDomain" -> _).map(Seq(_)) ++ 
      variableSet.map("variableSet" -> _).map(Seq(_)) ++ 
      version.map("version" -> _).map(Seq(_))
    ).toSeq.flatten

    _executeRequest[Unit, DefaultSearchResponse](
      method = "GET",
      path = s"/mdr/search",
      body = None,
      formParameters = None,
      queryParameters = queryParameters,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, DefaultSearchResponse]("DefaultSearchResponse", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrSearchScopesGet()(using auth: _Authorization.Basic): F[MdrSearchScopesGet200Response] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, MdrSearchScopesGet200Response](
      method = "GET",
      path = s"/mdr/search/scopes",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, MdrSearchScopesGet200Response]("MdrSearchScopesGet200Response", r)
    }
  }

  override def mdrSearchScopesScopeGet(scope: DefaultSearchScopes)(using auth: _Authorization.Basic): F[ScopeValues] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, ScopeValues](
      method = "GET",
      path = s"/mdr/search/scopes/${scope}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, ScopeValues]("ScopeValues", r)
    }
  }

}


