//
// ControlledTerminologyCTAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class ControlledTerminologyCTAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://library.cdisc.org/api")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum MdrCtPackagesGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCtPackagesGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCtPackagesGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCtPackagesGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCtPackagesGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCtPackagesGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCtPackagesGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCtPackagesGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCtPackagesGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCtPackagesGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/ct/packages
    /// - Get CDISC Library CT Package List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - returns: AnyPublisher<CtPackages, Error> 
    open func mdrCtPackagesGet() -> AnyPublisher<CtPackages, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/mdr/ct/packages"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CtPackages, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CtPackages.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCtPackagesPackageCodelistsCodelistGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/ct/packages/{package}/codelists/{codelist}
    /// - Get CDISC Library CT Package Codelist
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter package: (path) CT Package Identifier 
    /// - parameter codelist: (path) CT Codelist Identifier 
    /// - returns: AnyPublisher<CtCodelist, Error> 
    open func mdrCtPackagesPackageCodelistsCodelistGet(package: String, codelist: String) -> AnyPublisher<CtCodelist, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/ct/packages/{package}/codelists/{codelist}"
                localVarPath = localVarPath.replacingOccurrences(of: "{package}", with: package)
                localVarPath = localVarPath.replacingOccurrences(of: "{codelist}", with: codelist)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CtCodelist, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CtCodelist.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCtPackagesPackageCodelistsCodelistTermsGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/ct/packages/{package}/codelists/{codelist}/terms
    /// - Get CDISC Library CT Package Codelist Term List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter package: (path) CT Package Identifier 
    /// - parameter codelist: (path) CT Codelist Identifier 
    /// - returns: AnyPublisher<CtCodelistTerms, Error> 
    open func mdrCtPackagesPackageCodelistsCodelistTermsGet(package: String, codelist: String) -> AnyPublisher<CtCodelistTerms, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/ct/packages/{package}/codelists/{codelist}/terms"
                localVarPath = localVarPath.replacingOccurrences(of: "{package}", with: package)
                localVarPath = localVarPath.replacingOccurrences(of: "{codelist}", with: codelist)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CtCodelistTerms, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CtCodelistTerms.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCtPackagesPackageCodelistsCodelistTermsTermGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsTermGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsTermGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsTermGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsTermGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsTermGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsTermGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsTermGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsTermGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCtPackagesPackageCodelistsCodelistTermsTermGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/ct/packages/{package}/codelists/{codelist}/terms/{term}
    /// - Get CDISC Library CT Package Codelist Term
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter package: (path) CT Package Product Identifier 
    /// - parameter codelist: (path) CT Codelist Identifier 
    /// - parameter term: (path) CT Codelist Term Identifier 
    /// - returns: AnyPublisher<CtTerm, Error> 
    open func mdrCtPackagesPackageCodelistsCodelistTermsTermGet(package: String, codelist: String, term: String) -> AnyPublisher<CtTerm, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/ct/packages/{package}/codelists/{codelist}/terms/{term}"
                localVarPath = localVarPath.replacingOccurrences(of: "{package}", with: package)
                localVarPath = localVarPath.replacingOccurrences(of: "{codelist}", with: codelist)
                localVarPath = localVarPath.replacingOccurrences(of: "{term}", with: term)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CtTerm, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsTermGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsTermGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsTermGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsTermGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsTermGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsTermGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsTermGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsTermGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsCodelistTermsTermGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CtTerm.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCtPackagesPackageCodelistsGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCtPackagesPackageCodelistsGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCtPackagesPackageCodelistsGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCtPackagesPackageCodelistsGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCtPackagesPackageCodelistsGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCtPackagesPackageCodelistsGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCtPackagesPackageCodelistsGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCtPackagesPackageCodelistsGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCtPackagesPackageCodelistsGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCtPackagesPackageCodelistsGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/ct/packages/{package}/codelists
    /// - Get CDISC Library CT Package Codelist List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter package: (path) CT Package Identifier 
    /// - returns: AnyPublisher<CtPackageCodelists, Error> 
    open func mdrCtPackagesPackageCodelistsGet(package: String) -> AnyPublisher<CtPackageCodelists, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/ct/packages/{package}/codelists"
                localVarPath = localVarPath.replacingOccurrences(of: "{package}", with: package)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CtPackageCodelists, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesPackageCodelistsGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CtPackageCodelists.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCtPackagesProductGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCtPackagesProductGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCtPackagesProductGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCtPackagesProductGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCtPackagesProductGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCtPackagesProductGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCtPackagesProductGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCtPackagesProductGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCtPackagesProductGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCtPackagesProductGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/ct/packages/{product}
    /// - Get CDISC Library CT Package
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter product: (path) CT Package Product Identifier 
    /// - returns: AnyPublisher<CtPackage, Error> 
    open func mdrCtPackagesProductGet(product: String) -> AnyPublisher<CtPackage, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/ct/packages/{product}"
                localVarPath = localVarPath.replacingOccurrences(of: "{product}", with: product)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CtPackage, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesProductGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesProductGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesProductGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesProductGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesProductGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesProductGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesProductGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesProductGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCtPackagesProductGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CtPackage.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrRootCtProductGroupCodelistsCodelistGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/root/ct/{productGroup}/codelists/{codelist}
    /// - Get CDISC Library Root CT Codelist
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter productGroup: (path) CT Product Group Identifier 
    /// - parameter codelist: (path) CT Codelist Identifier 
    /// - returns: AnyPublisher<RootCtCodelist, Error> 
    open func mdrRootCtProductGroupCodelistsCodelistGet(productGroup: String, codelist: String) -> AnyPublisher<RootCtCodelist, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/root/ct/{productGroup}/codelists/{codelist}"
                localVarPath = localVarPath.replacingOccurrences(of: "{productGroup}", with: productGroup)
                localVarPath = localVarPath.replacingOccurrences(of: "{codelist}", with: codelist)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RootCtCodelist, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(RootCtCodelist.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrRootCtProductGroupCodelistsCodelistTermsTermGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistTermsTermGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistTermsTermGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistTermsTermGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistTermsTermGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistTermsTermGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistTermsTermGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistTermsTermGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistTermsTermGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrRootCtProductGroupCodelistsCodelistTermsTermGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/root/ct/{productGroup}/codelists/{codelist}/terms/{term}
    /// - Get CDISC Library Root CT Term
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter productGroup: (path) CT Product Group Identifier 
    /// - parameter codelist: (path) CT Codelist Identifier 
    /// - parameter term: (path) CT Codelist Term Identifier 
    /// - returns: AnyPublisher<RootCtTerm, Error> 
    open func mdrRootCtProductGroupCodelistsCodelistTermsTermGet(productGroup: String, codelist: String, term: String) -> AnyPublisher<RootCtTerm, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/root/ct/{productGroup}/codelists/{codelist}/terms/{term}"
                localVarPath = localVarPath.replacingOccurrences(of: "{productGroup}", with: productGroup)
                localVarPath = localVarPath.replacingOccurrences(of: "{codelist}", with: codelist)
                localVarPath = localVarPath.replacingOccurrences(of: "{term}", with: term)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RootCtTerm, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistTermsTermGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistTermsTermGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistTermsTermGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistTermsTermGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistTermsTermGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistTermsTermGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistTermsTermGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistTermsTermGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCtProductGroupCodelistsCodelistTermsTermGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(RootCtTerm.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
