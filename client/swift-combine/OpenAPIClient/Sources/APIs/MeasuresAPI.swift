//
// MeasuresAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class MeasuresAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://library.cdisc.org/api")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum MdrQrsMeasureVersionGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrQrsMeasureVersionGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrQrsMeasureVersionGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrQrsMeasureVersionGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrQrsMeasureVersionGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrQrsMeasureVersionGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrQrsMeasureVersionGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrQrsMeasureVersionGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrQrsMeasureVersionGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrQrsMeasureVersionGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/qrs/{measure}/{version}
    /// - Get QRS Product
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter measure: (path) QRS Measure Identifier 
    /// - parameter version: (path) CDISC Library Product Version 
    /// - returns: AnyPublisher<QrsProduct, Error> 
    open func mdrQrsMeasureVersionGet(measure: String, version: String) -> AnyPublisher<QrsProduct, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/qrs/{measure}/{version}"
                localVarPath = localVarPath.replacingOccurrences(of: "{measure}", with: measure)
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<QrsProduct, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(QrsProduct.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrQrsMeasureVersionItemsGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrQrsMeasureVersionItemsGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrQrsMeasureVersionItemsGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrQrsMeasureVersionItemsGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrQrsMeasureVersionItemsGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrQrsMeasureVersionItemsGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrQrsMeasureVersionItemsGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrQrsMeasureVersionItemsGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrQrsMeasureVersionItemsGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrQrsMeasureVersionItemsGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/qrs/{measure}/{version}/items
    /// - Get QRS Item List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter measure: (path) QRS Measure Identifier 
    /// - parameter version: (path) CDISC Library Product Version 
    /// - returns: AnyPublisher<QrsItems, Error> 
    open func mdrQrsMeasureVersionItemsGet(measure: String, version: String) -> AnyPublisher<QrsItems, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/qrs/{measure}/{version}/items"
                localVarPath = localVarPath.replacingOccurrences(of: "{measure}", with: measure)
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<QrsItems, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(QrsItems.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrQrsMeasureVersionItemsItemGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrQrsMeasureVersionItemsItemGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrQrsMeasureVersionItemsItemGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrQrsMeasureVersionItemsItemGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrQrsMeasureVersionItemsItemGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrQrsMeasureVersionItemsItemGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrQrsMeasureVersionItemsItemGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrQrsMeasureVersionItemsItemGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrQrsMeasureVersionItemsItemGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrQrsMeasureVersionItemsItemGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/qrs/{measure}/{version}/items/{item}
    /// - Get QRS Item
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter measure: (path) QRS Measure Identifier 
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter item: (path) QRS Measure Item Identifier 
    /// - returns: AnyPublisher<QrsItem, Error> 
    open func mdrQrsMeasureVersionItemsItemGet(measure: String, version: String, item: String) -> AnyPublisher<QrsItem, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/qrs/{measure}/{version}/items/{item}"
                localVarPath = localVarPath.replacingOccurrences(of: "{measure}", with: measure)
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{item}", with: item)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<QrsItem, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsItemGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsItemGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsItemGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsItemGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsItemGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsItemGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsItemGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsItemGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionItemsItemGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(QrsItem.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrQrsMeasureVersionResponsegroupsGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/qrs/{measure}/{version}/responsegroups
    /// - Get QRS Response Group List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter measure: (path) QRS Measure Identifier 
    /// - parameter version: (path) CDISC Library Product Version 
    /// - returns: AnyPublisher<QrsResponsegroups, Error> 
    open func mdrQrsMeasureVersionResponsegroupsGet(measure: String, version: String) -> AnyPublisher<QrsResponsegroups, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/qrs/{measure}/{version}/responsegroups"
                localVarPath = localVarPath.replacingOccurrences(of: "{measure}", with: measure)
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<QrsResponsegroups, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(QrsResponsegroups.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrQrsMeasureVersionResponsegroupsResponsegroupGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsResponsegroupGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsResponsegroupGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsResponsegroupGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsResponsegroupGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsResponsegroupGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsResponsegroupGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsResponsegroupGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsResponsegroupGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrQrsMeasureVersionResponsegroupsResponsegroupGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/qrs/{measure}/{version}/responsegroups/{responsegroup}
    /// - Get QRS Response Group
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter measure: (path) QRS Measure Identifier 
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter responsegroup: (path) QRS Measure&#39;s Response Group Identifier 
    /// - returns: AnyPublisher<QrsResponsegroup, Error> 
    open func mdrQrsMeasureVersionResponsegroupsResponsegroupGet(measure: String, version: String, responsegroup: String) -> AnyPublisher<QrsResponsegroup, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/qrs/{measure}/{version}/responsegroups/{responsegroup}"
                localVarPath = localVarPath.replacingOccurrences(of: "{measure}", with: measure)
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{responsegroup}", with: responsegroup)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<QrsResponsegroup, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsResponsegroupGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsResponsegroupGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsResponsegroupGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsResponsegroupGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsResponsegroupGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsResponsegroupGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsResponsegroupGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsResponsegroupGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrQrsMeasureVersionResponsegroupsResponsegroupGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(QrsResponsegroup.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
