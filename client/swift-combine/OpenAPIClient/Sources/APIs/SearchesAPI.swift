//
// SearchesAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class SearchesAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://library.cdisc.org/api")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum MdrSearchGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrSearchGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrSearchGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrSearchGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrSearchGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrSearchGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrSearchGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrSearchGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrSearchGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrSearchGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/search
    /// - Get Search Results Across CDISC Library
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - externalDocs:
    ///     url: https://wiki.cdisc.org/display/LIBSUPRT/Search 
    ///     description: Release Notes about Searches 
    /// - parameter q: (query) Search Term Expression 
    /// - parameter highlight: (query) Search Highlight Expression (optional)
    /// - parameter start: (query) Initial Search Result Index (optional, default to 0)
    /// - parameter pageSize: (query) Number of Search Results to Return (optional, default to 100)
    /// - parameter _class: (query) Limit Search by Setting Scope to Class (optional)
    /// - parameter codelist: (query) Limit Search by Setting Scope to Codelist (optional)
    /// - parameter conceptId: (query) Limit Search by Setting Scope to Concept ID (optional)
    /// - parameter core: (query) Limit Search by Setting Scope to Core (optional)
    /// - parameter dataStructure: (query) Limit Search by Setting Scope to Data Structure (optional)
    /// - parameter datasetStructure: (query) Limit Search by Setting Scope to Dataset Structure (optional)
    /// - parameter definition: (query) Limit Search by Setting Scope to Definition (optional)
    /// - parameter description: (query) Limit Search by Setting Scope to Description (optional)
    /// - parameter domain: (query) Limit Search by Setting Scope to Domain (optional)
    /// - parameter effectiveDate: (query) Limit Search by Setting Scope to Effective Date (optional)
    /// - parameter extensible: (query) Limit Search by Setting Scope to Extensible (optional)
    /// - parameter href: (query) Limit Search by Setting Scope to Href (optional)
    /// - parameter label: (query) Limit Search by Setting Scope to Label (optional)
    /// - parameter measureType: (query) SLimit Search by Setting Scope to Measure Type (optional)
    /// - parameter name: (query) Limit Search by Setting Scope to Name (optional)
    /// - parameter preferredTerm: (query) Limit Search by Setting Scope to Preferred Term (optional)
    /// - parameter product: (query) Limit Search by Setting Scope to Product (optional)
    /// - parameter productGroup: (query) Limit Search by Setting Scope to Product Group (optional)
    /// - parameter registrationStatus: (query) Limit Search by Setting Scope to Registration Status (optional)
    /// - parameter roleDescription: (query) Limit Search by Setting Scope to Role Description (optional)
    /// - parameter sdtmTarget: (query) Limit Search by Setting Scope to SDTM Target (optional)
    /// - parameter simpleDatatype: (query) Limit Search by Setting Scope to Simple Datatype (optional)
    /// - parameter submissionValue: (query) Limit Search by Setting Scope to Submission Value (optional)
    /// - parameter synonyms: (query) Limit Search by Setting Scope to Synonyms (optional)
    /// - parameter type: (query) Limit Search by Setting Scope to Type (optional)
    /// - parameter uiHref: (query) Limit Search by Setting Scope to UI Href (optional)
    /// - parameter valueDomain: (query) Limit Search by Setting Scope to Value Domain (optional)
    /// - parameter variableSet: (query) Limit Search by Setting Scope to Variable Set (optional)
    /// - parameter version: (query) Limit Search by Setting Scope to Version (optional)
    /// - returns: AnyPublisher<DefaultSearchResponse, Error> 
    open func mdrSearchGet(q: String, highlight: String? = nil, start: Double? = nil, pageSize: Double? = nil, _class: String? = nil, codelist: String? = nil, conceptId: String? = nil, core: String? = nil, dataStructure: String? = nil, datasetStructure: String? = nil, definition: String? = nil, description: String? = nil, domain: String? = nil, effectiveDate: String? = nil, extensible: String? = nil, href: String? = nil, label: String? = nil, measureType: String? = nil, name: String? = nil, preferredTerm: String? = nil, product: String? = nil, productGroup: String? = nil, registrationStatus: String? = nil, roleDescription: String? = nil, sdtmTarget: String? = nil, simpleDatatype: String? = nil, submissionValue: String? = nil, synonyms: String? = nil, type: String? = nil, uiHref: String? = nil, valueDomain: String? = nil, variableSet: String? = nil, version: String? = nil) -> AnyPublisher<DefaultSearchResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/mdr/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "q", value: q))
                if let highlight = highlight { queryItems.append(URLQueryItem(name: "highlight", value: highlight)) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let pageSize = pageSize { queryItems.append(URLQueryItem(name: "pageSize", value: "\(pageSize)")) } 
                if let _class = _class { queryItems.append(URLQueryItem(name: "class", value: _class)) } 
                if let codelist = codelist { queryItems.append(URLQueryItem(name: "codelist", value: codelist)) } 
                if let conceptId = conceptId { queryItems.append(URLQueryItem(name: "conceptId", value: conceptId)) } 
                if let core = core { queryItems.append(URLQueryItem(name: "core", value: core)) } 
                if let dataStructure = dataStructure { queryItems.append(URLQueryItem(name: "dataStructure", value: dataStructure)) } 
                if let datasetStructure = datasetStructure { queryItems.append(URLQueryItem(name: "datasetStructure", value: datasetStructure)) } 
                if let definition = definition { queryItems.append(URLQueryItem(name: "definition", value: definition)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let domain = domain { queryItems.append(URLQueryItem(name: "domain", value: domain)) } 
                if let effectiveDate = effectiveDate { queryItems.append(URLQueryItem(name: "effectiveDate", value: effectiveDate)) } 
                if let extensible = extensible { queryItems.append(URLQueryItem(name: "extensible", value: extensible)) } 
                if let href = href { queryItems.append(URLQueryItem(name: "href", value: href)) } 
                if let label = label { queryItems.append(URLQueryItem(name: "label", value: label)) } 
                if let measureType = measureType { queryItems.append(URLQueryItem(name: "measureType", value: measureType)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let preferredTerm = preferredTerm { queryItems.append(URLQueryItem(name: "preferredTerm", value: preferredTerm)) } 
                if let product = product { queryItems.append(URLQueryItem(name: "product", value: product)) } 
                if let productGroup = productGroup { queryItems.append(URLQueryItem(name: "productGroup", value: productGroup)) } 
                if let registrationStatus = registrationStatus { queryItems.append(URLQueryItem(name: "registrationStatus", value: registrationStatus)) } 
                if let roleDescription = roleDescription { queryItems.append(URLQueryItem(name: "roleDescription", value: roleDescription)) } 
                if let sdtmTarget = sdtmTarget { queryItems.append(URLQueryItem(name: "sdtmTarget", value: sdtmTarget)) } 
                if let simpleDatatype = simpleDatatype { queryItems.append(URLQueryItem(name: "simpleDatatype", value: simpleDatatype)) } 
                if let submissionValue = submissionValue { queryItems.append(URLQueryItem(name: "submissionValue", value: submissionValue)) } 
                if let synonyms = synonyms { queryItems.append(URLQueryItem(name: "synonyms", value: synonyms)) } 
                if let type = type { queryItems.append(URLQueryItem(name: "type", value: type)) } 
                if let uiHref = uiHref { queryItems.append(URLQueryItem(name: "uiHref", value: uiHref)) } 
                if let valueDomain = valueDomain { queryItems.append(URLQueryItem(name: "valueDomain", value: valueDomain)) } 
                if let variableSet = variableSet { queryItems.append(URLQueryItem(name: "variableSet", value: variableSet)) } 
                if let version = version { queryItems.append(URLQueryItem(name: "version", value: version)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DefaultSearchResponse, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSearchGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSearchGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSearchGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSearchGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSearchGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSearchGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSearchGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSearchGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSearchGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(DefaultSearchResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /mdr/search/scopes
    /// - Get Search Results Across CDISC Library
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - externalDocs:
    ///     url: https://wiki.cdisc.org/display/LIBSUPRT/Search 
    ///     description: Release Notes about Searches 
    /// - returns: AnyPublisher<MdrSearchScopesGet200Response, Error> 
    open func mdrSearchScopesGet() -> AnyPublisher<MdrSearchScopesGet200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/mdr/search/scopes"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MdrSearchScopesGet200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(MdrSearchScopesGet200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /mdr/search/scopes/{scope}
    /// - Get Search Results Limited to Scope
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - externalDocs:
    ///     url: https://wiki.cdisc.org/display/LIBSUPRT/Search 
    ///     description: Release Notes about Searches 
    /// - parameter scope: (path) Search Scope 
    /// - returns: AnyPublisher<ScopeValues, Error> 
    open func mdrSearchScopesScopeGet(scope: DefaultSearchScopes) -> AnyPublisher<ScopeValues, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/search/scopes/{scope}"
                localVarPath = localVarPath.replacingOccurrences(of: "{scope}", with: )
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ScopeValues, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ScopeValues.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
