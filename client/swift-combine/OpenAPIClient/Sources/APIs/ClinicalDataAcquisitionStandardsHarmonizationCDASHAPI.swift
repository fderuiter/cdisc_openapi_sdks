//
// ClinicalDataAcquisitionStandardsHarmonizationCDASHAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class ClinicalDataAcquisitionStandardsHarmonizationCDASHAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://library.cdisc.org/api")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum MdrCdashVersionClassesClassDomainsGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashVersionClassesClassDomainsGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashVersionClassesClassDomainsGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashVersionClassesClassDomainsGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashVersionClassesClassDomainsGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashVersionClassesClassDomainsGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashVersionClassesClassDomainsGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashVersionClassesClassDomainsGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashVersionClassesClassDomainsGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashVersionClassesClassDomainsGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdash/{version}/classes/{class}/domains
    /// - Get CDASH Class Domain List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter _class: (path) CDASH Class Identifier 
    /// - returns: AnyPublisher<CdashClassDomains, Error> 
    open func mdrCdashVersionClassesClassDomainsGet(version: String, _class: String) -> AnyPublisher<CdashClassDomains, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdash/{version}/classes/{class}/domains"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{class}", with: _class)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashClassDomains, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassDomainsGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassDomainsGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassDomainsGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassDomainsGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassDomainsGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassDomainsGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassDomainsGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassDomainsGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassDomainsGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashClassDomains.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashVersionClassesClassFieldsFieldGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashVersionClassesClassFieldsFieldGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashVersionClassesClassFieldsFieldGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashVersionClassesClassFieldsFieldGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashVersionClassesClassFieldsFieldGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashVersionClassesClassFieldsFieldGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashVersionClassesClassFieldsFieldGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashVersionClassesClassFieldsFieldGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashVersionClassesClassFieldsFieldGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashVersionClassesClassFieldsFieldGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdash/{version}/classes/{class}/fields/{field}
    /// - Get CDASH Class Field
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter _class: (path) CDASH Class Identifier 
    /// - parameter field: (path) CDASH Field Identifier 
    /// - returns: AnyPublisher<CdashClassField, Error> 
    open func mdrCdashVersionClassesClassFieldsFieldGet(version: String, _class: String, field: String) -> AnyPublisher<CdashClassField, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdash/{version}/classes/{class}/fields/{field}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{class}", with: _class)
                localVarPath = localVarPath.replacingOccurrences(of: "{field}", with: field)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashClassField, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassFieldsFieldGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassFieldsFieldGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassFieldsFieldGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassFieldsFieldGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassFieldsFieldGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassFieldsFieldGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassFieldsFieldGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassFieldsFieldGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassFieldsFieldGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashClassField.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashVersionClassesClassGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashVersionClassesClassGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashVersionClassesClassGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashVersionClassesClassGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashVersionClassesClassGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashVersionClassesClassGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashVersionClassesClassGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashVersionClassesClassGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashVersionClassesClassGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashVersionClassesClassGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdash/{version}/classes/{class}
    /// - Get CDASH Class
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter _class: (path) CDASH Class Identifier 
    /// - returns: AnyPublisher<CdashClass, Error> 
    open func mdrCdashVersionClassesClassGet(version: String, _class: String) -> AnyPublisher<CdashClass, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdash/{version}/classes/{class}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{class}", with: _class)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashClass, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesClassGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashClass.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashVersionClassesGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashVersionClassesGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashVersionClassesGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashVersionClassesGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashVersionClassesGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashVersionClassesGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashVersionClassesGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashVersionClassesGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashVersionClassesGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashVersionClassesGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdash/{version}/classes
    /// - Get CDASH Class List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - returns: AnyPublisher<CdashProductClasses, Error> 
    open func mdrCdashVersionClassesGet(version: String) -> AnyPublisher<CdashProductClasses, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdash/{version}/classes"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashProductClasses, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionClassesGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashProductClasses.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashVersionDomainsDomainFieldsFieldGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsFieldGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsFieldGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsFieldGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsFieldGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsFieldGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsFieldGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsFieldGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsFieldGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsFieldGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdash/{version}/domains/{domain}/fields/{field}
    /// - Get CDASH Domain Field
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter domain: (path) CDASH Domain Identifier 
    /// - parameter field: (path) CDASH Field Identifier 
    /// - returns: AnyPublisher<CdashDomainField, Error> 
    open func mdrCdashVersionDomainsDomainFieldsFieldGet(version: String, domain: String, field: String) -> AnyPublisher<CdashDomainField, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdash/{version}/domains/{domain}/fields/{field}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{domain}", with: domain)
                localVarPath = localVarPath.replacingOccurrences(of: "{field}", with: field)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashDomainField, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsFieldGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsFieldGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsFieldGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsFieldGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsFieldGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsFieldGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsFieldGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsFieldGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsFieldGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashDomainField.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashVersionDomainsDomainFieldsGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashVersionDomainsDomainFieldsGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdash/{version}/domains/{domain}/fields
    /// - Get CDASH Domain Field List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter domain: (path) CDASH Domain Identifier 
    /// - returns: AnyPublisher<CdashDomainFields, Error> 
    open func mdrCdashVersionDomainsDomainFieldsGet(version: String, domain: String) -> AnyPublisher<CdashDomainFields, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdash/{version}/domains/{domain}/fields"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{domain}", with: domain)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashDomainFields, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainFieldsGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashDomainFields.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashVersionDomainsDomainGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashVersionDomainsDomainGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashVersionDomainsDomainGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashVersionDomainsDomainGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashVersionDomainsDomainGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashVersionDomainsDomainGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashVersionDomainsDomainGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashVersionDomainsDomainGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashVersionDomainsDomainGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashVersionDomainsDomainGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdash/{version}/domains/{domain}
    /// - Get CDASH Domain
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter domain: (path) CDASH Domain Identifier 
    /// - returns: AnyPublisher<CdashDomain, Error> 
    open func mdrCdashVersionDomainsDomainGet(version: String, domain: String) -> AnyPublisher<CdashDomain, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdash/{version}/domains/{domain}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{domain}", with: domain)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashDomain, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsDomainGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashDomain.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashVersionDomainsGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashVersionDomainsGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashVersionDomainsGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashVersionDomainsGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashVersionDomainsGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashVersionDomainsGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashVersionDomainsGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashVersionDomainsGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashVersionDomainsGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashVersionDomainsGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdash/{version}/domains
    /// - Get CDASH Domain List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - returns: AnyPublisher<CdashProductDomains, Error> 
    open func mdrCdashVersionDomainsGet(version: String) -> AnyPublisher<CdashProductDomains, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdash/{version}/domains"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashProductDomains, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionDomainsGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashProductDomains.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashVersionGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashVersionGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashVersionGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashVersionGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashVersionGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashVersionGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashVersionGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashVersionGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashVersionGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashVersionGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdash/{version}
    /// - Get CDASH Product
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - returns: AnyPublisher<CdashProduct, Error> 
    open func mdrCdashVersionGet(version: String) -> AnyPublisher<CdashProduct, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdash/{version}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashProduct, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashVersionGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashProduct.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrRootCdashClassesClassFieldsFieldGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrRootCdashClassesClassFieldsFieldGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrRootCdashClassesClassFieldsFieldGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrRootCdashClassesClassFieldsFieldGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrRootCdashClassesClassFieldsFieldGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrRootCdashClassesClassFieldsFieldGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrRootCdashClassesClassFieldsFieldGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrRootCdashClassesClassFieldsFieldGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrRootCdashClassesClassFieldsFieldGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrRootCdashClassesClassFieldsFieldGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/root/cdash/classes/{class}/fields/{field}
    /// - Get Root CDASH Class Field
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter _class: (path) CDASH Class Identifier 
    /// - parameter field: (path) CDASH Field Identifier 
    /// - returns: AnyPublisher<RootCdashClassField, Error> 
    open func mdrRootCdashClassesClassFieldsFieldGet(_class: String, field: String) -> AnyPublisher<RootCdashClassField, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/root/cdash/classes/{class}/fields/{field}"
                localVarPath = localVarPath.replacingOccurrences(of: "{class}", with: _class)
                localVarPath = localVarPath.replacingOccurrences(of: "{field}", with: field)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RootCdashClassField, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashClassesClassFieldsFieldGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashClassesClassFieldsFieldGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashClassesClassFieldsFieldGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashClassesClassFieldsFieldGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashClassesClassFieldsFieldGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashClassesClassFieldsFieldGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashClassesClassFieldsFieldGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashClassesClassFieldsFieldGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashClassesClassFieldsFieldGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(RootCdashClassField.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrRootCdashDomainsDomainFieldsFieldGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrRootCdashDomainsDomainFieldsFieldGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrRootCdashDomainsDomainFieldsFieldGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrRootCdashDomainsDomainFieldsFieldGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrRootCdashDomainsDomainFieldsFieldGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrRootCdashDomainsDomainFieldsFieldGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrRootCdashDomainsDomainFieldsFieldGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrRootCdashDomainsDomainFieldsFieldGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrRootCdashDomainsDomainFieldsFieldGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrRootCdashDomainsDomainFieldsFieldGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/root/cdash/domains/{domain}/fields/{field}
    /// - Get Root CDASH Domain Field
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter domain: (path) CDASH Domain Identifier 
    /// - parameter field: (path) CDASH Field Identifier 
    /// - returns: AnyPublisher<RootCdashDomainField, Error> 
    open func mdrRootCdashDomainsDomainFieldsFieldGet(domain: String, field: String) -> AnyPublisher<RootCdashDomainField, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/root/cdash/domains/{domain}/fields/{field}"
                localVarPath = localVarPath.replacingOccurrences(of: "{domain}", with: domain)
                localVarPath = localVarPath.replacingOccurrences(of: "{field}", with: field)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RootCdashDomainField, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashDomainsDomainFieldsFieldGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashDomainsDomainFieldsFieldGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashDomainsDomainFieldsFieldGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashDomainsDomainFieldsFieldGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashDomainsDomainFieldsFieldGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashDomainsDomainFieldsFieldGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashDomainsDomainFieldsFieldGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashDomainsDomainFieldsFieldGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashDomainsDomainFieldsFieldGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(RootCdashDomainField.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
