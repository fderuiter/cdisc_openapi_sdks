/** CDISC Library API
  * REST API Documentation for CDISC Library in production server
  *
  * The version of the OpenAPI document: 1.1.0
  * Contact: cdisc_library_support@cdisc.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package org.openapitools.client.apis

import cats.effect.Concurrent
import io.circe.Encoder
import org.http4s.Uri
import org.http4s.client.Client as Http4sClient
import org.openapitools.client.models.DefaultErrorResponse
import org.openapitools.client.models.ExportSdtmDatasetsTable
import org.openapitools.client.models.ExportSdtmVariablesTable
import org.openapitools.client.models.ExportSdtmWorkbook
import org.openapitools.client.models.RootSdtmClassVariable
import org.openapitools.client.models.RootSdtmDatasetVariable
import org.openapitools.client.models.SdtmClass
import org.openapitools.client.models.SdtmClassDatasets
import org.openapitools.client.models.SdtmClassVariable
import org.openapitools.client.models.SdtmClassVariables
import org.openapitools.client.models.SdtmClasses
import org.openapitools.client.models.SdtmDataset
import org.openapitools.client.models.SdtmDatasetVariable
import org.openapitools.client.models.SdtmDatasetVariables
import org.openapitools.client.models.SdtmDatasets
import org.openapitools.client.models.SdtmProduct
import org.openapitools.client.models.XmlRootSdtmClassVariable
import org.openapitools.client.models.XmlRootSdtmDatasetVariable
import org.openapitools.client.models.XmlSdtmClass
import org.openapitools.client.models.XmlSdtmClassDatasets
import org.openapitools.client.models.XmlSdtmClassVariable
import org.openapitools.client.models.XmlSdtmClassVariables
import org.openapitools.client.models.XmlSdtmClasses
import org.openapitools.client.models.XmlSdtmDataset
import org.openapitools.client.models.XmlSdtmDatasetVariable
import org.openapitools.client.models.XmlSdtmDatasetVariables
import org.openapitools.client.models.XmlSdtmDatasets
import org.openapitools.client.models.XmlSdtmProduct
import org.openapitools.client.models.*

trait StudyDataTabulationModelSDTMApiEndpoints[F[*]] {

  def mdrRootSdtmClassesClassVariablesVarGet(`class`: String, `var`: String)(using auth: _Authorization.Basic): F[RootSdtmClassVariable]
  def mdrRootSdtmDatasetsDatasetVariablesVarGet(dataset: String, `var`: String)(using auth: _Authorization.Basic): F[RootSdtmDatasetVariable]
  def mdrSdtmVersionClassesClassDatasetsGet(version: String, `class`: String)(using auth: _Authorization.Basic): F[SdtmClassDatasets]
  def mdrSdtmVersionClassesClassGet(version: String, `class`: String)(using auth: _Authorization.Basic): F[SdtmClass]
  def mdrSdtmVersionClassesClassVariablesGet(version: String, `class`: String)(using auth: _Authorization.Basic): F[SdtmClassVariables]
  def mdrSdtmVersionClassesClassVariablesVarGet(version: String, `class`: String, `var`: String)(using auth: _Authorization.Basic): F[SdtmClassVariable]
  def mdrSdtmVersionClassesGet(version: String)(using auth: _Authorization.Basic): F[SdtmClasses]
  def mdrSdtmVersionDatasetsDatasetGet(version: String, dataset: String)(using auth: _Authorization.Basic): F[SdtmDataset]
  def mdrSdtmVersionDatasetsDatasetVariablesGet(version: String, dataset: String)(using auth: _Authorization.Basic): F[SdtmDatasetVariables]
  def mdrSdtmVersionDatasetsDatasetVariablesVarGet(version: String, dataset: String, `var`: String)(using auth: _Authorization.Basic): F[SdtmDatasetVariable]
  def mdrSdtmVersionDatasetsGet(version: String)(using auth: _Authorization.Basic): F[SdtmDatasets]
  def mdrSdtmVersionGet(version: String)(using auth: _Authorization.Basic): F[SdtmProduct]

}

class StudyDataTabulationModelSDTMApiEndpointsImpl[F[*]: Concurrent](
  override val baseUrl: Uri,
  defaultHeaders: Seq[(String, String)] = Nil,
  httpClient: Http4sClient[F]
) extends BaseClient[F](baseUrl, defaultHeaders, httpClient) with StudyDataTabulationModelSDTMApiEndpoints[F] {
  
  import JsonSupports.*
  import io.circe.syntax.EncoderOps
  import cats.implicits.toFlatMapOps

  override def mdrRootSdtmClassesClassVariablesVarGet(`class`: String, `var`: String)(using auth: _Authorization.Basic): F[RootSdtmClassVariable] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, RootSdtmClassVariable](
      method = "GET",
      path = s"/mdr/root/sdtm/classes/${`class`}/variables/${`var`}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, RootSdtmClassVariable]("RootSdtmClassVariable", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrRootSdtmDatasetsDatasetVariablesVarGet(dataset: String, `var`: String)(using auth: _Authorization.Basic): F[RootSdtmDatasetVariable] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, RootSdtmDatasetVariable](
      method = "GET",
      path = s"/mdr/root/sdtm/datasets/${dataset}/variables/${`var`}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, RootSdtmDatasetVariable]("RootSdtmDatasetVariable", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrSdtmVersionClassesClassDatasetsGet(version: String, `class`: String)(using auth: _Authorization.Basic): F[SdtmClassDatasets] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, SdtmClassDatasets](
      method = "GET",
      path = s"/mdr/sdtm/${version}/classes/${`class`}/datasets",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, SdtmClassDatasets]("SdtmClassDatasets", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrSdtmVersionClassesClassGet(version: String, `class`: String)(using auth: _Authorization.Basic): F[SdtmClass] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, SdtmClass](
      method = "GET",
      path = s"/mdr/sdtm/${version}/classes/${`class`}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, SdtmClass]("SdtmClass", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrSdtmVersionClassesClassVariablesGet(version: String, `class`: String)(using auth: _Authorization.Basic): F[SdtmClassVariables] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, SdtmClassVariables](
      method = "GET",
      path = s"/mdr/sdtm/${version}/classes/${`class`}/variables",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, SdtmClassVariables]("SdtmClassVariables", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrSdtmVersionClassesClassVariablesVarGet(version: String, `class`: String, `var`: String)(using auth: _Authorization.Basic): F[SdtmClassVariable] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, SdtmClassVariable](
      method = "GET",
      path = s"/mdr/sdtm/${version}/classes/${`class`}/variables/${`var`}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, SdtmClassVariable]("SdtmClassVariable", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrSdtmVersionClassesGet(version: String)(using auth: _Authorization.Basic): F[SdtmClasses] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, SdtmClasses](
      method = "GET",
      path = s"/mdr/sdtm/${version}/classes",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, SdtmClasses]("SdtmClasses", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrSdtmVersionDatasetsDatasetGet(version: String, dataset: String)(using auth: _Authorization.Basic): F[SdtmDataset] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, SdtmDataset](
      method = "GET",
      path = s"/mdr/sdtm/${version}/datasets/${dataset}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, SdtmDataset]("SdtmDataset", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrSdtmVersionDatasetsDatasetVariablesGet(version: String, dataset: String)(using auth: _Authorization.Basic): F[SdtmDatasetVariables] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, SdtmDatasetVariables](
      method = "GET",
      path = s"/mdr/sdtm/${version}/datasets/${dataset}/variables",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, SdtmDatasetVariables]("SdtmDatasetVariables", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrSdtmVersionDatasetsDatasetVariablesVarGet(version: String, dataset: String, `var`: String)(using auth: _Authorization.Basic): F[SdtmDatasetVariable] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, SdtmDatasetVariable](
      method = "GET",
      path = s"/mdr/sdtm/${version}/datasets/${dataset}/variables/${`var`}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, SdtmDatasetVariable]("SdtmDatasetVariable", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrSdtmVersionDatasetsGet(version: String)(using auth: _Authorization.Basic): F[SdtmDatasets] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, SdtmDatasets](
      method = "GET",
      path = s"/mdr/sdtm/${version}/datasets",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, SdtmDatasets]("SdtmDatasets", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrSdtmVersionGet(version: String)(using auth: _Authorization.Basic): F[SdtmProduct] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, SdtmProduct](
      method = "GET",
      path = s"/mdr/sdtm/${version}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, SdtmProduct]("SdtmProduct", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

}


