/** CDISC Library API
  * REST API Documentation for CDISC Library in production server
  *
  * The version of the OpenAPI document: 1.1.0
  * Contact: cdisc_library_support@cdisc.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package org.openapitools.client.apis

import cats.effect.Concurrent
import io.circe.Encoder
import org.http4s.Uri
import org.http4s.client.Client as Http4sClient
import org.openapitools.client.models.CdashClass
import org.openapitools.client.models.CdashClassDomains
import org.openapitools.client.models.CdashClassField
import org.openapitools.client.models.CdashDomain
import org.openapitools.client.models.CdashDomainField
import org.openapitools.client.models.CdashDomainFields
import org.openapitools.client.models.CdashProduct
import org.openapitools.client.models.CdashProductClasses
import org.openapitools.client.models.CdashProductDomains
import org.openapitools.client.models.DefaultErrorResponse
import org.openapitools.client.models.ExportCdashTable
import org.openapitools.client.models.RootCdashClassField
import org.openapitools.client.models.RootCdashDomainField
import org.openapitools.client.models.XmlCdashClass
import org.openapitools.client.models.XmlCdashClassDomains
import org.openapitools.client.models.XmlCdashClassField
import org.openapitools.client.models.XmlCdashDomain
import org.openapitools.client.models.XmlCdashDomainField
import org.openapitools.client.models.XmlCdashDomainFields
import org.openapitools.client.models.XmlCdashProduct
import org.openapitools.client.models.XmlCdashProductClasses
import org.openapitools.client.models.XmlCdashProductDomains
import org.openapitools.client.models.XmlRootCdashClassField
import org.openapitools.client.models.XmlRootCdashDomainField
import org.openapitools.client.models.*

trait ClinicalDataAcquisitionStandardsHarmonizationCDASHApiEndpoints[F[*]] {

  def mdrCdashVersionClassesClassDomainsGet(version: String, `class`: String)(using auth: _Authorization.Basic): F[CdashClassDomains]
  def mdrCdashVersionClassesClassFieldsFieldGet(version: String, `class`: String, field: String)(using auth: _Authorization.Basic): F[CdashClassField]
  def mdrCdashVersionClassesClassGet(version: String, `class`: String)(using auth: _Authorization.Basic): F[CdashClass]
  def mdrCdashVersionClassesGet(version: String)(using auth: _Authorization.Basic): F[CdashProductClasses]
  def mdrCdashVersionDomainsDomainFieldsFieldGet(version: String, domain: String, field: String)(using auth: _Authorization.Basic): F[CdashDomainField]
  def mdrCdashVersionDomainsDomainFieldsGet(version: String, domain: String)(using auth: _Authorization.Basic): F[CdashDomainFields]
  def mdrCdashVersionDomainsDomainGet(version: String, domain: String)(using auth: _Authorization.Basic): F[CdashDomain]
  def mdrCdashVersionDomainsGet(version: String)(using auth: _Authorization.Basic): F[CdashProductDomains]
  def mdrCdashVersionGet(version: String)(using auth: _Authorization.Basic): F[CdashProduct]
  def mdrRootCdashClassesClassFieldsFieldGet(`class`: String, field: String)(using auth: _Authorization.Basic): F[RootCdashClassField]
  def mdrRootCdashDomainsDomainFieldsFieldGet(domain: String, field: String)(using auth: _Authorization.Basic): F[RootCdashDomainField]

}

class ClinicalDataAcquisitionStandardsHarmonizationCDASHApiEndpointsImpl[F[*]: Concurrent](
  override val baseUrl: Uri,
  defaultHeaders: Seq[(String, String)] = Nil,
  httpClient: Http4sClient[F]
) extends BaseClient[F](baseUrl, defaultHeaders, httpClient) with ClinicalDataAcquisitionStandardsHarmonizationCDASHApiEndpoints[F] {
  
  import JsonSupports.*
  import io.circe.syntax.EncoderOps
  import cats.implicits.toFlatMapOps

  override def mdrCdashVersionClassesClassDomainsGet(version: String, `class`: String)(using auth: _Authorization.Basic): F[CdashClassDomains] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, CdashClassDomains](
      method = "GET",
      path = s"/mdr/cdash/${version}/classes/${`class`}/domains",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, CdashClassDomains]("CdashClassDomains", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrCdashVersionClassesClassFieldsFieldGet(version: String, `class`: String, field: String)(using auth: _Authorization.Basic): F[CdashClassField] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, CdashClassField](
      method = "GET",
      path = s"/mdr/cdash/${version}/classes/${`class`}/fields/${field}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, CdashClassField]("CdashClassField", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrCdashVersionClassesClassGet(version: String, `class`: String)(using auth: _Authorization.Basic): F[CdashClass] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, CdashClass](
      method = "GET",
      path = s"/mdr/cdash/${version}/classes/${`class`}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, CdashClass]("CdashClass", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrCdashVersionClassesGet(version: String)(using auth: _Authorization.Basic): F[CdashProductClasses] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, CdashProductClasses](
      method = "GET",
      path = s"/mdr/cdash/${version}/classes",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, CdashProductClasses]("CdashProductClasses", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrCdashVersionDomainsDomainFieldsFieldGet(version: String, domain: String, field: String)(using auth: _Authorization.Basic): F[CdashDomainField] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, CdashDomainField](
      method = "GET",
      path = s"/mdr/cdash/${version}/domains/${domain}/fields/${field}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, CdashDomainField]("CdashDomainField", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrCdashVersionDomainsDomainFieldsGet(version: String, domain: String)(using auth: _Authorization.Basic): F[CdashDomainFields] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, CdashDomainFields](
      method = "GET",
      path = s"/mdr/cdash/${version}/domains/${domain}/fields",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, CdashDomainFields]("CdashDomainFields", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrCdashVersionDomainsDomainGet(version: String, domain: String)(using auth: _Authorization.Basic): F[CdashDomain] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, CdashDomain](
      method = "GET",
      path = s"/mdr/cdash/${version}/domains/${domain}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, CdashDomain]("CdashDomain", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrCdashVersionDomainsGet(version: String)(using auth: _Authorization.Basic): F[CdashProductDomains] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, CdashProductDomains](
      method = "GET",
      path = s"/mdr/cdash/${version}/domains",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, CdashProductDomains]("CdashProductDomains", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrCdashVersionGet(version: String)(using auth: _Authorization.Basic): F[CdashProduct] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, CdashProduct](
      method = "GET",
      path = s"/mdr/cdash/${version}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, CdashProduct]("CdashProduct", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrRootCdashClassesClassFieldsFieldGet(`class`: String, field: String)(using auth: _Authorization.Basic): F[RootCdashClassField] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, RootCdashClassField](
      method = "GET",
      path = s"/mdr/root/cdash/classes/${`class`}/fields/${field}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, RootCdashClassField]("RootCdashClassField", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrRootCdashDomainsDomainFieldsFieldGet(domain: String, field: String)(using auth: _Authorization.Basic): F[RootCdashDomainField] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, RootCdashDomainField](
      method = "GET",
      path = s"/mdr/root/cdash/domains/${domain}/fields/${field}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, RootCdashDomainField]("RootCdashDomainField", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

}


