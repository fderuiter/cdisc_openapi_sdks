/** CDISC Library API
  * REST API Documentation for CDISC Library in production server
  *
  * The version of the OpenAPI document: 1.1.0
  * Contact: cdisc_library_support@cdisc.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package org.openapitools.client.apis

import cats.effect.Concurrent
import io.circe.Encoder
import org.http4s.Uri
import org.http4s.client.Client as Http4sClient
import org.openapitools.client.models.About
import org.openapitools.client.models.DefaultErrorResponse
import org.openapitools.client.models.Lastupdated
import org.openapitools.client.models.ProductgroupDataAnalysis
import org.openapitools.client.models.ProductgroupDataCollection
import org.openapitools.client.models.ProductgroupDataTabulation
import org.openapitools.client.models.ProductgroupQrs
import org.openapitools.client.models.ProductgroupTerminology
import org.openapitools.client.models.Products
import org.openapitools.client.models.XmlAbout
import org.openapitools.client.models.XmlLastupdated
import org.openapitools.client.models.XmlProductgroupDataAnalysis
import org.openapitools.client.models.XmlProductgroupDataCollection
import org.openapitools.client.models.XmlProductgroupDataTabulation
import org.openapitools.client.models.XmlProductgroupTerminology
import org.openapitools.client.models.XmlProducts
import org.openapitools.client.models.*

trait DefaultApiEndpoints[F[*]] {

  def mdrAboutGet()(using auth: _Authorization.Basic): F[About]
  def mdrLastupdatedGet()(using auth: _Authorization.Basic): F[Lastupdated]
  def mdrProductsDataAnalysisGet()(using auth: _Authorization.Basic): F[ProductgroupDataAnalysis]
  def mdrProductsDataCollectionGet()(using auth: _Authorization.Basic): F[ProductgroupDataCollection]
  def mdrProductsDataTabulationGet()(using auth: _Authorization.Basic): F[ProductgroupDataTabulation]
  def mdrProductsGet()(using auth: _Authorization.Basic): F[Products]
  def mdrProductsMeasuresGet()(using auth: _Authorization.Basic): F[ProductgroupQrs]
  def mdrProductsTerminologyGet()(using auth: _Authorization.Basic): F[ProductgroupTerminology]

}

class DefaultApiEndpointsImpl[F[*]: Concurrent](
  override val baseUrl: Uri,
  defaultHeaders: Seq[(String, String)] = Nil,
  httpClient: Http4sClient[F]
) extends BaseClient[F](baseUrl, defaultHeaders, httpClient) with DefaultApiEndpoints[F] {
  
  import JsonSupports.*
  import io.circe.syntax.EncoderOps
  import cats.implicits.toFlatMapOps

  override def mdrAboutGet()(using auth: _Authorization.Basic): F[About] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, About](
      method = "GET",
      path = s"/mdr/about",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, About]("About", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrLastupdatedGet()(using auth: _Authorization.Basic): F[Lastupdated] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, Lastupdated](
      method = "GET",
      path = s"/mdr/lastupdated",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, Lastupdated]("Lastupdated", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrProductsDataAnalysisGet()(using auth: _Authorization.Basic): F[ProductgroupDataAnalysis] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, ProductgroupDataAnalysis](
      method = "GET",
      path = s"/mdr/products/DataAnalysis",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, ProductgroupDataAnalysis]("ProductgroupDataAnalysis", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrProductsDataCollectionGet()(using auth: _Authorization.Basic): F[ProductgroupDataCollection] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, ProductgroupDataCollection](
      method = "GET",
      path = s"/mdr/products/DataCollection",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, ProductgroupDataCollection]("ProductgroupDataCollection", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrProductsDataTabulationGet()(using auth: _Authorization.Basic): F[ProductgroupDataTabulation] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, ProductgroupDataTabulation](
      method = "GET",
      path = s"/mdr/products/DataTabulation",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, ProductgroupDataTabulation]("ProductgroupDataTabulation", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrProductsGet()(using auth: _Authorization.Basic): F[Products] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, Products](
      method = "GET",
      path = s"/mdr/products",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, Products]("Products", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrProductsMeasuresGet()(using auth: _Authorization.Basic): F[ProductgroupQrs] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, ProductgroupQrs](
      method = "GET",
      path = s"/mdr/products/Measures",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, ProductgroupQrs]("ProductgroupQrs", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrProductsTerminologyGet()(using auth: _Authorization.Basic): F[ProductgroupTerminology] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, ProductgroupTerminology](
      method = "GET",
      path = s"/mdr/products/Terminology",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, ProductgroupTerminology]("ProductgroupTerminology", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

}


