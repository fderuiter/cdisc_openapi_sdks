/** CDISC Library API
  * REST API Documentation for CDISC Library in production server
  *
  * The version of the OpenAPI document: 1.1.0
  * Contact: cdisc_library_support@cdisc.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package org.openapitools.client.apis

import cats.effect.Concurrent
import io.circe.Encoder
import org.http4s.Uri
import org.http4s.client.Client as Http4sClient
import org.openapitools.client.models.CtCodelist
import org.openapitools.client.models.CtCodelistTerms
import org.openapitools.client.models.CtPackage
import org.openapitools.client.models.CtPackageCodelists
import org.openapitools.client.models.CtPackages
import org.openapitools.client.models.CtTerm
import org.openapitools.client.models.DefaultErrorResponse
import org.openapitools.client.models.ExportCtTable
import org.openapitools.client.models.RootCtCodelist
import org.openapitools.client.models.RootCtTerm
import org.openapitools.client.models.XmlCtCodelist
import org.openapitools.client.models.XmlCtCodelistTerms
import org.openapitools.client.models.XmlCtPackage
import org.openapitools.client.models.XmlCtPackageCodelists
import org.openapitools.client.models.XmlCtPackages
import org.openapitools.client.models.XmlCtTerm
import org.openapitools.client.models.XmlRootCtCodelist
import org.openapitools.client.models.XmlRootCtTerm
import org.openapitools.client.models.*

trait ControlledTerminologyCTApiEndpoints[F[*]] {

  def mdrCtPackagesGet()(using auth: _Authorization.Basic): F[CtPackages]
  def mdrCtPackagesPackageCodelistsCodelistGet(`package`: String, codelist: String)(using auth: _Authorization.Basic): F[CtCodelist]
  def mdrCtPackagesPackageCodelistsCodelistTermsGet(`package`: String, codelist: String)(using auth: _Authorization.Basic): F[CtCodelistTerms]
  def mdrCtPackagesPackageCodelistsCodelistTermsTermGet(`package`: String, codelist: String, term: String)(using auth: _Authorization.Basic): F[CtTerm]
  def mdrCtPackagesPackageCodelistsGet(`package`: String)(using auth: _Authorization.Basic): F[CtPackageCodelists]
  def mdrCtPackagesProductGet(product: String)(using auth: _Authorization.Basic): F[CtPackage]
  def mdrRootCtProductGroupCodelistsCodelistGet(productGroup: String, codelist: String)(using auth: _Authorization.Basic): F[RootCtCodelist]
  def mdrRootCtProductGroupCodelistsCodelistTermsTermGet(productGroup: String, codelist: String, term: String)(using auth: _Authorization.Basic): F[RootCtTerm]

}

class ControlledTerminologyCTApiEndpointsImpl[F[*]: Concurrent](
  override val baseUrl: Uri,
  defaultHeaders: Seq[(String, String)] = Nil,
  httpClient: Http4sClient[F]
) extends BaseClient[F](baseUrl, defaultHeaders, httpClient) with ControlledTerminologyCTApiEndpoints[F] {
  
  import JsonSupports.*
  import io.circe.syntax.EncoderOps
  import cats.implicits.toFlatMapOps

  override def mdrCtPackagesGet()(using auth: _Authorization.Basic): F[CtPackages] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, CtPackages](
      method = "GET",
      path = s"/mdr/ct/packages",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, CtPackages]("CtPackages", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrCtPackagesPackageCodelistsCodelistGet(`package`: String, codelist: String)(using auth: _Authorization.Basic): F[CtCodelist] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, CtCodelist](
      method = "GET",
      path = s"/mdr/ct/packages/${`package`}/codelists/${codelist}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, CtCodelist]("CtCodelist", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrCtPackagesPackageCodelistsCodelistTermsGet(`package`: String, codelist: String)(using auth: _Authorization.Basic): F[CtCodelistTerms] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, CtCodelistTerms](
      method = "GET",
      path = s"/mdr/ct/packages/${`package`}/codelists/${codelist}/terms",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, CtCodelistTerms]("CtCodelistTerms", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrCtPackagesPackageCodelistsCodelistTermsTermGet(`package`: String, codelist: String, term: String)(using auth: _Authorization.Basic): F[CtTerm] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, CtTerm](
      method = "GET",
      path = s"/mdr/ct/packages/${`package`}/codelists/${codelist}/terms/${term}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, CtTerm]("CtTerm", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrCtPackagesPackageCodelistsGet(`package`: String)(using auth: _Authorization.Basic): F[CtPackageCodelists] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, CtPackageCodelists](
      method = "GET",
      path = s"/mdr/ct/packages/${`package`}/codelists",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, CtPackageCodelists]("CtPackageCodelists", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrCtPackagesProductGet(product: String)(using auth: _Authorization.Basic): F[CtPackage] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, CtPackage](
      method = "GET",
      path = s"/mdr/ct/packages/${product}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, CtPackage]("CtPackage", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrRootCtProductGroupCodelistsCodelistGet(productGroup: String, codelist: String)(using auth: _Authorization.Basic): F[RootCtCodelist] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, RootCtCodelist](
      method = "GET",
      path = s"/mdr/root/ct/${productGroup}/codelists/${codelist}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, RootCtCodelist]("RootCtCodelist", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def mdrRootCtProductGroupCodelistsCodelistTermsTermGet(productGroup: String, codelist: String, term: String)(using auth: _Authorization.Basic): F[RootCtTerm] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Unit, RootCtTerm](
      method = "GET",
      path = s"/mdr/root/ct/${productGroup}/codelists/${codelist}/terms/${term}",
      body = None,
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, RootCtTerm]("RootCtTerm", r)
        case r if r.status.code == 400 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 405 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 406 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 503 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 504 => parseJson[F, DefaultErrorResponse]("DefaultErrorResponse", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

}


