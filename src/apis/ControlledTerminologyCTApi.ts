// tslint:disable
/**
 * CDISC Library API
 * REST API Documentation for CDISC Library in production server
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: cdisc_library_support@cdisc.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    CtCodelist,
    CtCodelistFromJSON,
    CtCodelistToJSON,
    CtCodelistTerms,
    CtCodelistTermsFromJSON,
    CtCodelistTermsToJSON,
    CtPackage,
    CtPackageFromJSON,
    CtPackageToJSON,
    CtPackageCodelists,
    CtPackageCodelistsFromJSON,
    CtPackageCodelistsToJSON,
    CtPackages,
    CtPackagesFromJSON,
    CtPackagesToJSON,
    CtTerm,
    CtTermFromJSON,
    CtTermToJSON,
    DefaultErrorResponse,
    DefaultErrorResponseFromJSON,
    DefaultErrorResponseToJSON,
    ExportCtTable,
    ExportCtTableFromJSON,
    ExportCtTableToJSON,
    RootCtCodelist,
    RootCtCodelistFromJSON,
    RootCtCodelistToJSON,
    RootCtTerm,
    RootCtTermFromJSON,
    RootCtTermToJSON,
    XmlCtCodelist,
    XmlCtCodelistFromJSON,
    XmlCtCodelistToJSON,
    XmlCtCodelistTerms,
    XmlCtCodelistTermsFromJSON,
    XmlCtCodelistTermsToJSON,
    XmlCtPackage,
    XmlCtPackageFromJSON,
    XmlCtPackageToJSON,
    XmlCtPackageCodelists,
    XmlCtPackageCodelistsFromJSON,
    XmlCtPackageCodelistsToJSON,
    XmlCtPackages,
    XmlCtPackagesFromJSON,
    XmlCtPackagesToJSON,
    XmlCtTerm,
    XmlCtTermFromJSON,
    XmlCtTermToJSON,
    XmlRootCtCodelist,
    XmlRootCtCodelistFromJSON,
    XmlRootCtCodelistToJSON,
    XmlRootCtTerm,
    XmlRootCtTermFromJSON,
    XmlRootCtTermToJSON,
} from '../models';

export interface MdrCtPackagesPackageCodelistsCodelistGetRequest {
    _package: string;
    codelist: string;
}

export interface MdrCtPackagesPackageCodelistsCodelistTermsGetRequest {
    _package: string;
    codelist: string;
}

export interface MdrCtPackagesPackageCodelistsCodelistTermsTermGetRequest {
    _package: string;
    codelist: string;
    term: string;
}

export interface MdrCtPackagesPackageCodelistsGetRequest {
    _package: string;
}

export interface MdrCtPackagesProductGetRequest {
    product: string;
}

export interface MdrRootCtProductGroupCodelistsCodelistGetRequest {
    productGroup: string;
    codelist: string;
}

export interface MdrRootCtProductGroupCodelistsCodelistTermsTermGetRequest {
    productGroup: string;
    codelist: string;
    term: string;
}


/**
 * Get CDISC Library CT Package List
 */
function mdrCtPackagesGetRaw<T>( requestConfig: runtime.TypedQueryConfig<T, CtPackages> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/mdr/ct/packages`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CtPackagesFromJSON(body), text);
    }

    return config;
}

/**
* Get CDISC Library CT Package List
*/
export function mdrCtPackagesGet<T>( requestConfig?: runtime.TypedQueryConfig<T, CtPackages>): QueryConfig<T> {
    return mdrCtPackagesGetRaw( requestConfig);
}

/**
 * Get CDISC Library CT Package Codelist
 */
function mdrCtPackagesPackageCodelistsCodelistGetRaw<T>(requestParameters: MdrCtPackagesPackageCodelistsCodelistGetRequest, requestConfig: runtime.TypedQueryConfig<T, CtCodelist> = {}): QueryConfig<T> {
    if (requestParameters._package === null || requestParameters._package === undefined) {
        throw new runtime.RequiredError('_package','Required parameter requestParameters._package was null or undefined when calling mdrCtPackagesPackageCodelistsCodelistGet.');
    }

    if (requestParameters.codelist === null || requestParameters.codelist === undefined) {
        throw new runtime.RequiredError('codelist','Required parameter requestParameters.codelist was null or undefined when calling mdrCtPackagesPackageCodelistsCodelistGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/mdr/ct/packages/{package}/codelists/{codelist}`.replace(`{${"package"}}`, encodeURIComponent(String(requestParameters._package))).replace(`{${"codelist"}}`, encodeURIComponent(String(requestParameters.codelist))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CtCodelistFromJSON(body), text);
    }

    return config;
}

/**
* Get CDISC Library CT Package Codelist
*/
export function mdrCtPackagesPackageCodelistsCodelistGet<T>(requestParameters: MdrCtPackagesPackageCodelistsCodelistGetRequest, requestConfig?: runtime.TypedQueryConfig<T, CtCodelist>): QueryConfig<T> {
    return mdrCtPackagesPackageCodelistsCodelistGetRaw(requestParameters, requestConfig);
}

/**
 * Get CDISC Library CT Package Codelist Term List
 */
function mdrCtPackagesPackageCodelistsCodelistTermsGetRaw<T>(requestParameters: MdrCtPackagesPackageCodelistsCodelistTermsGetRequest, requestConfig: runtime.TypedQueryConfig<T, CtCodelistTerms> = {}): QueryConfig<T> {
    if (requestParameters._package === null || requestParameters._package === undefined) {
        throw new runtime.RequiredError('_package','Required parameter requestParameters._package was null or undefined when calling mdrCtPackagesPackageCodelistsCodelistTermsGet.');
    }

    if (requestParameters.codelist === null || requestParameters.codelist === undefined) {
        throw new runtime.RequiredError('codelist','Required parameter requestParameters.codelist was null or undefined when calling mdrCtPackagesPackageCodelistsCodelistTermsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/mdr/ct/packages/{package}/codelists/{codelist}/terms`.replace(`{${"package"}}`, encodeURIComponent(String(requestParameters._package))).replace(`{${"codelist"}}`, encodeURIComponent(String(requestParameters.codelist))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CtCodelistTermsFromJSON(body), text);
    }

    return config;
}

/**
* Get CDISC Library CT Package Codelist Term List
*/
export function mdrCtPackagesPackageCodelistsCodelistTermsGet<T>(requestParameters: MdrCtPackagesPackageCodelistsCodelistTermsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, CtCodelistTerms>): QueryConfig<T> {
    return mdrCtPackagesPackageCodelistsCodelistTermsGetRaw(requestParameters, requestConfig);
}

/**
 * Get CDISC Library CT Package Codelist Term
 */
function mdrCtPackagesPackageCodelistsCodelistTermsTermGetRaw<T>(requestParameters: MdrCtPackagesPackageCodelistsCodelistTermsTermGetRequest, requestConfig: runtime.TypedQueryConfig<T, CtTerm> = {}): QueryConfig<T> {
    if (requestParameters._package === null || requestParameters._package === undefined) {
        throw new runtime.RequiredError('_package','Required parameter requestParameters._package was null or undefined when calling mdrCtPackagesPackageCodelistsCodelistTermsTermGet.');
    }

    if (requestParameters.codelist === null || requestParameters.codelist === undefined) {
        throw new runtime.RequiredError('codelist','Required parameter requestParameters.codelist was null or undefined when calling mdrCtPackagesPackageCodelistsCodelistTermsTermGet.');
    }

    if (requestParameters.term === null || requestParameters.term === undefined) {
        throw new runtime.RequiredError('term','Required parameter requestParameters.term was null or undefined when calling mdrCtPackagesPackageCodelistsCodelistTermsTermGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/mdr/ct/packages/{package}/codelists/{codelist}/terms/{term}`.replace(`{${"package"}}`, encodeURIComponent(String(requestParameters._package))).replace(`{${"codelist"}}`, encodeURIComponent(String(requestParameters.codelist))).replace(`{${"term"}}`, encodeURIComponent(String(requestParameters.term))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CtTermFromJSON(body), text);
    }

    return config;
}

/**
* Get CDISC Library CT Package Codelist Term
*/
export function mdrCtPackagesPackageCodelistsCodelistTermsTermGet<T>(requestParameters: MdrCtPackagesPackageCodelistsCodelistTermsTermGetRequest, requestConfig?: runtime.TypedQueryConfig<T, CtTerm>): QueryConfig<T> {
    return mdrCtPackagesPackageCodelistsCodelistTermsTermGetRaw(requestParameters, requestConfig);
}

/**
 * Get CDISC Library CT Package Codelist List
 */
function mdrCtPackagesPackageCodelistsGetRaw<T>(requestParameters: MdrCtPackagesPackageCodelistsGetRequest, requestConfig: runtime.TypedQueryConfig<T, CtPackageCodelists> = {}): QueryConfig<T> {
    if (requestParameters._package === null || requestParameters._package === undefined) {
        throw new runtime.RequiredError('_package','Required parameter requestParameters._package was null or undefined when calling mdrCtPackagesPackageCodelistsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/mdr/ct/packages/{package}/codelists`.replace(`{${"package"}}`, encodeURIComponent(String(requestParameters._package))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CtPackageCodelistsFromJSON(body), text);
    }

    return config;
}

/**
* Get CDISC Library CT Package Codelist List
*/
export function mdrCtPackagesPackageCodelistsGet<T>(requestParameters: MdrCtPackagesPackageCodelistsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, CtPackageCodelists>): QueryConfig<T> {
    return mdrCtPackagesPackageCodelistsGetRaw(requestParameters, requestConfig);
}

/**
 * Get CDISC Library CT Package
 */
function mdrCtPackagesProductGetRaw<T>(requestParameters: MdrCtPackagesProductGetRequest, requestConfig: runtime.TypedQueryConfig<T, CtPackage> = {}): QueryConfig<T> {
    if (requestParameters.product === null || requestParameters.product === undefined) {
        throw new runtime.RequiredError('product','Required parameter requestParameters.product was null or undefined when calling mdrCtPackagesProductGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/mdr/ct/packages/{product}`.replace(`{${"product"}}`, encodeURIComponent(String(requestParameters.product))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CtPackageFromJSON(body), text);
    }

    return config;
}

/**
* Get CDISC Library CT Package
*/
export function mdrCtPackagesProductGet<T>(requestParameters: MdrCtPackagesProductGetRequest, requestConfig?: runtime.TypedQueryConfig<T, CtPackage>): QueryConfig<T> {
    return mdrCtPackagesProductGetRaw(requestParameters, requestConfig);
}

/**
 * Get CDISC Library Root CT Codelist
 */
function mdrRootCtProductGroupCodelistsCodelistGetRaw<T>(requestParameters: MdrRootCtProductGroupCodelistsCodelistGetRequest, requestConfig: runtime.TypedQueryConfig<T, RootCtCodelist> = {}): QueryConfig<T> {
    if (requestParameters.productGroup === null || requestParameters.productGroup === undefined) {
        throw new runtime.RequiredError('productGroup','Required parameter requestParameters.productGroup was null or undefined when calling mdrRootCtProductGroupCodelistsCodelistGet.');
    }

    if (requestParameters.codelist === null || requestParameters.codelist === undefined) {
        throw new runtime.RequiredError('codelist','Required parameter requestParameters.codelist was null or undefined when calling mdrRootCtProductGroupCodelistsCodelistGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/mdr/root/ct/{productGroup}/codelists/{codelist}`.replace(`{${"productGroup"}}`, encodeURIComponent(String(requestParameters.productGroup))).replace(`{${"codelist"}}`, encodeURIComponent(String(requestParameters.codelist))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(RootCtCodelistFromJSON(body), text);
    }

    return config;
}

/**
* Get CDISC Library Root CT Codelist
*/
export function mdrRootCtProductGroupCodelistsCodelistGet<T>(requestParameters: MdrRootCtProductGroupCodelistsCodelistGetRequest, requestConfig?: runtime.TypedQueryConfig<T, RootCtCodelist>): QueryConfig<T> {
    return mdrRootCtProductGroupCodelistsCodelistGetRaw(requestParameters, requestConfig);
}

/**
 * Get CDISC Library Root CT Term
 */
function mdrRootCtProductGroupCodelistsCodelistTermsTermGetRaw<T>(requestParameters: MdrRootCtProductGroupCodelistsCodelistTermsTermGetRequest, requestConfig: runtime.TypedQueryConfig<T, RootCtTerm> = {}): QueryConfig<T> {
    if (requestParameters.productGroup === null || requestParameters.productGroup === undefined) {
        throw new runtime.RequiredError('productGroup','Required parameter requestParameters.productGroup was null or undefined when calling mdrRootCtProductGroupCodelistsCodelistTermsTermGet.');
    }

    if (requestParameters.codelist === null || requestParameters.codelist === undefined) {
        throw new runtime.RequiredError('codelist','Required parameter requestParameters.codelist was null or undefined when calling mdrRootCtProductGroupCodelistsCodelistTermsTermGet.');
    }

    if (requestParameters.term === null || requestParameters.term === undefined) {
        throw new runtime.RequiredError('term','Required parameter requestParameters.term was null or undefined when calling mdrRootCtProductGroupCodelistsCodelistTermsTermGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/mdr/root/ct/{productGroup}/codelists/{codelist}/terms/{term}`.replace(`{${"productGroup"}}`, encodeURIComponent(String(requestParameters.productGroup))).replace(`{${"codelist"}}`, encodeURIComponent(String(requestParameters.codelist))).replace(`{${"term"}}`, encodeURIComponent(String(requestParameters.term))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(RootCtTermFromJSON(body), text);
    }

    return config;
}

/**
* Get CDISC Library Root CT Term
*/
export function mdrRootCtProductGroupCodelistsCodelistTermsTermGet<T>(requestParameters: MdrRootCtProductGroupCodelistsCodelistTermsTermGetRequest, requestConfig?: runtime.TypedQueryConfig<T, RootCtTerm>): QueryConfig<T> {
    return mdrRootCtProductGroupCodelistsCodelistTermsTermGetRaw(requestParameters, requestConfig);
}

