/**
 * CDISC Library API
 * REST API Documentation for CDISC Library in production server
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: cdisc_library_support@cdisc.org
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.16.0-SNAPSHOT.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


#include "CppRestOpenAPIClient/api/SearchesApi.h"
#include "CppRestOpenAPIClient/IHttpBody.h"
#include "CppRestOpenAPIClient/JsonBody.h"
#include "CppRestOpenAPIClient/MultipartFormData.h"

#include <boost/algorithm/string/replace.hpp>

#include <unordered_set>

namespace org {
namespace openapitools {
namespace client {
namespace api {

using namespace org::openapitools::client::model;

SearchesApi::SearchesApi( std::shared_ptr<const ApiClient> apiClient )
    : m_ApiClient(apiClient)
{
}

SearchesApi::~SearchesApi()
{
}

pplx::task<std::shared_ptr<DefaultSearchResponse>> SearchesApi::mdrSearchGet(utility::string_t q, boost::optional<utility::string_t> highlight, boost::optional<double> start, boost::optional<double> pageSize, boost::optional<utility::string_t> r_class, boost::optional<utility::string_t> codelist, boost::optional<utility::string_t> conceptId, boost::optional<utility::string_t> core, boost::optional<utility::string_t> dataStructure, boost::optional<utility::string_t> datasetStructure, boost::optional<utility::string_t> definition, boost::optional<utility::string_t> description, boost::optional<utility::string_t> domain, boost::optional<utility::string_t> effectiveDate, boost::optional<utility::string_t> extensible, boost::optional<utility::string_t> href, boost::optional<utility::string_t> label, boost::optional<utility::string_t> measureType, boost::optional<utility::string_t> name, boost::optional<utility::string_t> preferredTerm, boost::optional<utility::string_t> product, boost::optional<utility::string_t> productGroup, boost::optional<utility::string_t> registrationStatus, boost::optional<utility::string_t> roleDescription, boost::optional<utility::string_t> sdtmTarget, boost::optional<utility::string_t> simpleDatatype, boost::optional<utility::string_t> submissionValue, boost::optional<utility::string_t> synonyms, boost::optional<utility::string_t> type, boost::optional<utility::string_t> uiHref, boost::optional<utility::string_t> valueDomain, boost::optional<utility::string_t> variableSet, boost::optional<utility::string_t> version) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/mdr/search");

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t localVarResponseHttpContentType;

    // use JSON if possible
    if ( localVarResponseHttpContentTypes.size() == 0 )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SearchesApi->mdrSearchGet does not produce any supported media type"));
    }

    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

    {
        localVarQueryParams[utility::conversions::to_string_t("q")] = ApiClient::parameterToString(q);
    }
    if (highlight)
    {
        localVarQueryParams[utility::conversions::to_string_t("highlight")] = ApiClient::parameterToString(*highlight);
    }
    if (start)
    {
        localVarQueryParams[utility::conversions::to_string_t("start")] = ApiClient::parameterToString(*start);
    }
    if (pageSize)
    {
        localVarQueryParams[utility::conversions::to_string_t("pageSize")] = ApiClient::parameterToString(*pageSize);
    }
    if (r_class)
    {
        localVarQueryParams[utility::conversions::to_string_t("class")] = ApiClient::parameterToString(*r_class);
    }
    if (codelist)
    {
        localVarQueryParams[utility::conversions::to_string_t("codelist")] = ApiClient::parameterToString(*codelist);
    }
    if (conceptId)
    {
        localVarQueryParams[utility::conversions::to_string_t("conceptId")] = ApiClient::parameterToString(*conceptId);
    }
    if (core)
    {
        localVarQueryParams[utility::conversions::to_string_t("core")] = ApiClient::parameterToString(*core);
    }
    if (dataStructure)
    {
        localVarQueryParams[utility::conversions::to_string_t("dataStructure")] = ApiClient::parameterToString(*dataStructure);
    }
    if (datasetStructure)
    {
        localVarQueryParams[utility::conversions::to_string_t("datasetStructure")] = ApiClient::parameterToString(*datasetStructure);
    }
    if (definition)
    {
        localVarQueryParams[utility::conversions::to_string_t("definition")] = ApiClient::parameterToString(*definition);
    }
    if (description)
    {
        localVarQueryParams[utility::conversions::to_string_t("description")] = ApiClient::parameterToString(*description);
    }
    if (domain)
    {
        localVarQueryParams[utility::conversions::to_string_t("domain")] = ApiClient::parameterToString(*domain);
    }
    if (effectiveDate)
    {
        localVarQueryParams[utility::conversions::to_string_t("effectiveDate")] = ApiClient::parameterToString(*effectiveDate);
    }
    if (extensible)
    {
        localVarQueryParams[utility::conversions::to_string_t("extensible")] = ApiClient::parameterToString(*extensible);
    }
    if (href)
    {
        localVarQueryParams[utility::conversions::to_string_t("href")] = ApiClient::parameterToString(*href);
    }
    if (label)
    {
        localVarQueryParams[utility::conversions::to_string_t("label")] = ApiClient::parameterToString(*label);
    }
    if (measureType)
    {
        localVarQueryParams[utility::conversions::to_string_t("measureType")] = ApiClient::parameterToString(*measureType);
    }
    if (name)
    {
        localVarQueryParams[utility::conversions::to_string_t("name")] = ApiClient::parameterToString(*name);
    }
    if (preferredTerm)
    {
        localVarQueryParams[utility::conversions::to_string_t("preferredTerm")] = ApiClient::parameterToString(*preferredTerm);
    }
    if (product)
    {
        localVarQueryParams[utility::conversions::to_string_t("product")] = ApiClient::parameterToString(*product);
    }
    if (productGroup)
    {
        localVarQueryParams[utility::conversions::to_string_t("productGroup")] = ApiClient::parameterToString(*productGroup);
    }
    if (registrationStatus)
    {
        localVarQueryParams[utility::conversions::to_string_t("registrationStatus")] = ApiClient::parameterToString(*registrationStatus);
    }
    if (roleDescription)
    {
        localVarQueryParams[utility::conversions::to_string_t("roleDescription")] = ApiClient::parameterToString(*roleDescription);
    }
    if (sdtmTarget)
    {
        localVarQueryParams[utility::conversions::to_string_t("sdtmTarget")] = ApiClient::parameterToString(*sdtmTarget);
    }
    if (simpleDatatype)
    {
        localVarQueryParams[utility::conversions::to_string_t("simpleDatatype")] = ApiClient::parameterToString(*simpleDatatype);
    }
    if (submissionValue)
    {
        localVarQueryParams[utility::conversions::to_string_t("submissionValue")] = ApiClient::parameterToString(*submissionValue);
    }
    if (synonyms)
    {
        localVarQueryParams[utility::conversions::to_string_t("synonyms")] = ApiClient::parameterToString(*synonyms);
    }
    if (type)
    {
        localVarQueryParams[utility::conversions::to_string_t("type")] = ApiClient::parameterToString(*type);
    }
    if (uiHref)
    {
        localVarQueryParams[utility::conversions::to_string_t("uiHref")] = ApiClient::parameterToString(*uiHref);
    }
    if (valueDomain)
    {
        localVarQueryParams[utility::conversions::to_string_t("valueDomain")] = ApiClient::parameterToString(*valueDomain);
    }
    if (variableSet)
    {
        localVarQueryParams[utility::conversions::to_string_t("variableSet")] = ApiClient::parameterToString(*variableSet);
    }
    if (version)
    {
        localVarQueryParams[utility::conversions::to_string_t("version")] = ApiClient::parameterToString(*version);
    }

    std::shared_ptr<IHttpBody> localVarHttpBody;
    utility::string_t localVarRequestHttpContentType;

    // use JSON if possible
    if ( localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else if (localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/x-www-form-urlencoded")) != localVarConsumeHttpContentTypes.end())
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/x-www-form-urlencoded");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SearchesApi->mdrSearchGet does not consume any supported media type"));
    }

    // authentication (basicAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("GET"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=, this](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling mdrSearchGet: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling mdrSearchGet: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string();
    })
    .then([=, this](utility::string_t localVarResponse)
    {
        std::shared_ptr<DefaultSearchResponse> localVarResult(new DefaultSearchResponse());

        if(localVarResponseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);

            ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling mdrSearchGet: unsupported response type"));
        }

        return localVarResult;
    });
}
pplx::task<std::shared_ptr<_mdr_search_scopes_get_200_response>> SearchesApi::mdrSearchScopesGet() const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/mdr/search/scopes");

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t localVarResponseHttpContentType;

    // use JSON if possible
    if ( localVarResponseHttpContentTypes.size() == 0 )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SearchesApi->mdrSearchScopesGet does not produce any supported media type"));
    }

    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;


    std::shared_ptr<IHttpBody> localVarHttpBody;
    utility::string_t localVarRequestHttpContentType;

    // use JSON if possible
    if ( localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else if (localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/x-www-form-urlencoded")) != localVarConsumeHttpContentTypes.end())
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/x-www-form-urlencoded");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SearchesApi->mdrSearchScopesGet does not consume any supported media type"));
    }

    // authentication (basicAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("GET"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=, this](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling mdrSearchScopesGet: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling mdrSearchScopesGet: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string();
    })
    .then([=, this](utility::string_t localVarResponse)
    {
        std::shared_ptr<_mdr_search_scopes_get_200_response> localVarResult(new _mdr_search_scopes_get_200_response());

        if(localVarResponseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);

            ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling mdrSearchScopesGet: unsupported response type"));
        }

        return localVarResult;
    });
}
pplx::task<std::shared_ptr<ScopeValues>> SearchesApi::mdrSearchScopesScopeGet(std::shared_ptr<DefaultSearchScopes> scope) const
{

    // verify the required parameter 'scope' is set
    if (scope == nullptr)
    {
        throw ApiException(400, utility::conversions::to_string_t("Missing required parameter 'scope' when calling SearchesApi->mdrSearchScopesScopeGet"));
    }


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/mdr/search/scopes/{scope}");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("scope") + utility::conversions::to_string_t("}"), web::uri::encode_uri(ApiClient::parameterToString(scope)));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t localVarResponseHttpContentType;

    // use JSON if possible
    if ( localVarResponseHttpContentTypes.size() == 0 )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SearchesApi->mdrSearchScopesScopeGet does not produce any supported media type"));
    }

    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;


    std::shared_ptr<IHttpBody> localVarHttpBody;
    utility::string_t localVarRequestHttpContentType;

    // use JSON if possible
    if ( localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else if (localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/x-www-form-urlencoded")) != localVarConsumeHttpContentTypes.end())
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/x-www-form-urlencoded");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SearchesApi->mdrSearchScopesScopeGet does not consume any supported media type"));
    }

    // authentication (basicAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("GET"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=, this](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling mdrSearchScopesScopeGet: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling mdrSearchScopesScopeGet: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string();
    })
    .then([=, this](utility::string_t localVarResponse)
    {
        std::shared_ptr<ScopeValues> localVarResult(new ScopeValues());

        if(localVarResponseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);

            ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling mdrSearchScopesScopeGet: unsupported response type"));
        }

        return localVarResult;
    });
}

}
}
}
}

