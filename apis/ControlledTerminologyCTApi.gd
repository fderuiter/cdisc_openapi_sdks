extends ApiBee
class_name ControlledTerminologyCTApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API ControlledTerminologyCTApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "ControlledTerminologyCTApi"


# Operation mdrCtPackagesGet → GET /mdr/ct/packages
#
# Get CDISC Library CT Package List
func mdr_ct_packages_get(
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/mdr/ct/packages"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json', 'application/xml']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = CtPackages.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func mdr_ct_packages_get_threaded(
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "mdr_ct_packages_get")
	bzz_callable.bind(
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation mdrCtPackagesPackageCodelistsCodelistGet → GET /mdr/ct/packages/{package}/codelists/{codelist}
#
# Get CDISC Library CT Package Codelist
func mdr_ct_packages_package_codelists_codelist_get(
	# package: String = ""   Eg: sdtmct-2019-12-20
	# CT Package Identifier
	package: String,
	# codelist: String = ""   Eg: C67154
	# CT Codelist Identifier
	codelist: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/mdr/ct/packages/{package}/codelists/{codelist}".replace("{" + "package" + "}", _bzz_urlize_path_param(package)).replace("{" + "codelist" + "}", _bzz_urlize_path_param(codelist))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json', 'application/xml']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = CtCodelist.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func mdr_ct_packages_package_codelists_codelist_get_threaded(
	# package: String = ""   Eg: sdtmct-2019-12-20
	# CT Package Identifier
	package: String,
	# codelist: String = ""   Eg: C67154
	# CT Codelist Identifier
	codelist: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "mdr_ct_packages_package_codelists_codelist_get")
	bzz_callable.bind(
		package,
		codelist,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation mdrCtPackagesPackageCodelistsCodelistTermsGet → GET /mdr/ct/packages/{package}/codelists/{codelist}/terms
#
# Get CDISC Library CT Package Codelist Term List
func mdr_ct_packages_package_codelists_codelist_terms_get(
	# package: String = ""   Eg: sdtmct-2019-12-20
	# CT Package Identifier
	package: String,
	# codelist: String = ""   Eg: C67154
	# CT Codelist Identifier
	codelist: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/mdr/ct/packages/{package}/codelists/{codelist}/terms".replace("{" + "package" + "}", _bzz_urlize_path_param(package)).replace("{" + "codelist" + "}", _bzz_urlize_path_param(codelist))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json', 'application/xml']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = CtCodelistTerms.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func mdr_ct_packages_package_codelists_codelist_terms_get_threaded(
	# package: String = ""   Eg: sdtmct-2019-12-20
	# CT Package Identifier
	package: String,
	# codelist: String = ""   Eg: C67154
	# CT Codelist Identifier
	codelist: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "mdr_ct_packages_package_codelists_codelist_terms_get")
	bzz_callable.bind(
		package,
		codelist,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation mdrCtPackagesPackageCodelistsCodelistTermsTermGet → GET /mdr/ct/packages/{package}/codelists/{codelist}/terms/{term}
#
# Get CDISC Library CT Package Codelist Term
func mdr_ct_packages_package_codelists_codelist_terms_term_get(
	# package: String = ""   Eg: sdtmct-2019-12-20
	# CT Package Product Identifier
	package: String,
	# codelist: String = ""   Eg: C67154
	# CT Codelist Identifier
	codelist: String,
	# term: String = ""   Eg: C64796
	# CT Codelist Term Identifier
	term: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/mdr/ct/packages/{package}/codelists/{codelist}/terms/{term}".replace("{" + "package" + "}", _bzz_urlize_path_param(package)).replace("{" + "codelist" + "}", _bzz_urlize_path_param(codelist)).replace("{" + "term" + "}", _bzz_urlize_path_param(term))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json', 'application/xml']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = CtTerm.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func mdr_ct_packages_package_codelists_codelist_terms_term_get_threaded(
	# package: String = ""   Eg: sdtmct-2019-12-20
	# CT Package Product Identifier
	package: String,
	# codelist: String = ""   Eg: C67154
	# CT Codelist Identifier
	codelist: String,
	# term: String = ""   Eg: C64796
	# CT Codelist Term Identifier
	term: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "mdr_ct_packages_package_codelists_codelist_terms_term_get")
	bzz_callable.bind(
		package,
		codelist,
		term,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation mdrCtPackagesPackageCodelistsGet → GET /mdr/ct/packages/{package}/codelists
#
# Get CDISC Library CT Package Codelist List
func mdr_ct_packages_package_codelists_get(
	# package: String = ""   Eg: sdtmct-2019-12-20
	# CT Package Identifier
	package: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/mdr/ct/packages/{package}/codelists".replace("{" + "package" + "}", _bzz_urlize_path_param(package))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json', 'application/xml']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = CtPackageCodelists.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func mdr_ct_packages_package_codelists_get_threaded(
	# package: String = ""   Eg: sdtmct-2019-12-20
	# CT Package Identifier
	package: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "mdr_ct_packages_package_codelists_get")
	bzz_callable.bind(
		package,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation mdrCtPackagesProductGet → GET /mdr/ct/packages/{product}
#
# Get CDISC Library CT Package
func mdr_ct_packages_product_get(
	# product: String = ""   Eg: sdtmct-2019-12-20
	# CT Package Product Identifier
	product: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/mdr/ct/packages/{product}".replace("{" + "product" + "}", _bzz_urlize_path_param(product))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json', 'application/xml', 'text/csv', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = CtPackage.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func mdr_ct_packages_product_get_threaded(
	# product: String = ""   Eg: sdtmct-2019-12-20
	# CT Package Product Identifier
	product: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "mdr_ct_packages_product_get")
	bzz_callable.bind(
		product,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation mdrRootCtProductGroupCodelistsCodelistGet → GET /mdr/root/ct/{productGroup}/codelists/{codelist}
#
# Get CDISC Library Root CT Codelist
func mdr_root_ct_product_group_codelists_codelist_get(
	# productGroup: String = ""   Eg: sdtmct
	# CT Product Group Identifier
	productGroup: String,
	# codelist: String = ""   Eg: C67154
	# CT Codelist Identifier
	codelist: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/mdr/root/ct/{productGroup}/codelists/{codelist}".replace("{" + "productGroup" + "}", _bzz_urlize_path_param(productGroup)).replace("{" + "codelist" + "}", _bzz_urlize_path_param(codelist))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json', 'application/xml']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = RootCtCodelist.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func mdr_root_ct_product_group_codelists_codelist_get_threaded(
	# productGroup: String = ""   Eg: sdtmct
	# CT Product Group Identifier
	productGroup: String,
	# codelist: String = ""   Eg: C67154
	# CT Codelist Identifier
	codelist: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "mdr_root_ct_product_group_codelists_codelist_get")
	bzz_callable.bind(
		productGroup,
		codelist,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation mdrRootCtProductGroupCodelistsCodelistTermsTermGet → GET /mdr/root/ct/{productGroup}/codelists/{codelist}/terms/{term}
#
# Get CDISC Library Root CT Term
func mdr_root_ct_product_group_codelists_codelist_terms_term_get(
	# productGroup: String = ""   Eg: sdtmct
	# CT Product Group Identifier
	productGroup: String,
	# codelist: String = ""   Eg: C67154
	# CT Codelist Identifier
	codelist: String,
	# term: String = ""   Eg: C64796
	# CT Codelist Term Identifier
	term: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/mdr/root/ct/{productGroup}/codelists/{codelist}/terms/{term}".replace("{" + "productGroup" + "}", _bzz_urlize_path_param(productGroup)).replace("{" + "codelist" + "}", _bzz_urlize_path_param(codelist)).replace("{" + "term" + "}", _bzz_urlize_path_param(term))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json', 'application/xml']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = RootCtTerm.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func mdr_root_ct_product_group_codelists_codelist_terms_term_get_threaded(
	# productGroup: String = ""   Eg: sdtmct
	# CT Product Group Identifier
	productGroup: String,
	# codelist: String = ""   Eg: C67154
	# CT Codelist Identifier
	codelist: String,
	# term: String = ""   Eg: C64796
	# CT Codelist Term Identifier
	term: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "mdr_root_ct_product_group_codelists_codelist_terms_term_get")
	bzz_callable.bind(
		productGroup,
		codelist,
		term,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


