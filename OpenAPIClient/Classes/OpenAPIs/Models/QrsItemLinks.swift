//
// QrsItemLinks.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct QrsItemLinks: Codable, JSONEncodable, Hashable {

    public var qrsItemTEST: RootCtTermRef?
    public var qrsItemTESTCD: RootCtTermRef?
    public var qrsItemEVAL: RootCtTermRef?
    public var qrsItemSCAT: RootCtTermRef?
    public var responsegroup: QrsResponsegroup?

    public init(qrsItemTEST: RootCtTermRef? = nil, qrsItemTESTCD: RootCtTermRef? = nil, qrsItemEVAL: RootCtTermRef? = nil, qrsItemSCAT: RootCtTermRef? = nil, responsegroup: QrsResponsegroup? = nil) {
        self.qrsItemTEST = qrsItemTEST
        self.qrsItemTESTCD = qrsItemTESTCD
        self.qrsItemEVAL = qrsItemEVAL
        self.qrsItemSCAT = qrsItemSCAT
        self.responsegroup = responsegroup
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case qrsItemTEST
        case qrsItemTESTCD
        case qrsItemEVAL
        case qrsItemSCAT
        case responsegroup
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(qrsItemTEST, forKey: .qrsItemTEST)
        try container.encodeIfPresent(qrsItemTESTCD, forKey: .qrsItemTESTCD)
        try container.encodeIfPresent(qrsItemEVAL, forKey: .qrsItemEVAL)
        try container.encodeIfPresent(qrsItemSCAT, forKey: .qrsItemSCAT)
        try container.encodeIfPresent(responsegroup, forKey: .responsegroup)
    }
}

