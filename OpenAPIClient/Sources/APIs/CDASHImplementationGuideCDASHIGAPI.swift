//
// CDASHImplementationGuideCDASHIGAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class CDASHImplementationGuideCDASHIGAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://library.cdisc.org/api")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum MdrCdashigVersionClassesClassDomainsGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashigVersionClassesClassDomainsGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashigVersionClassesClassDomainsGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashigVersionClassesClassDomainsGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashigVersionClassesClassDomainsGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashigVersionClassesClassDomainsGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashigVersionClassesClassDomainsGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashigVersionClassesClassDomainsGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashigVersionClassesClassDomainsGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashigVersionClassesClassDomainsGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdashig/{version}/classes/{class}/domains
    /// - Get CDASHIG Class Domain List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter _class: (path) CDASHIG Class Identifier 
    /// - returns: AnyPublisher<CdashigClassDomains, Error> 
    open func mdrCdashigVersionClassesClassDomainsGet(version: String, _class: String) -> AnyPublisher<CdashigClassDomains, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdashig/{version}/classes/{class}/domains"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{class}", with: _class)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashigClassDomains, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassDomainsGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassDomainsGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassDomainsGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassDomainsGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassDomainsGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassDomainsGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassDomainsGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassDomainsGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassDomainsGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashigClassDomains.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashigVersionClassesClassGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashigVersionClassesClassGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashigVersionClassesClassGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashigVersionClassesClassGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashigVersionClassesClassGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashigVersionClassesClassGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashigVersionClassesClassGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashigVersionClassesClassGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashigVersionClassesClassGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashigVersionClassesClassGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdashig/{version}/classes/{class}
    /// - Get CDASHIG Class
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter _class: (path) CDASHIG Class Identifier 
    /// - returns: AnyPublisher<CdashigClass, Error> 
    open func mdrCdashigVersionClassesClassGet(version: String, _class: String) -> AnyPublisher<CdashigClass, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdashig/{version}/classes/{class}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{class}", with: _class)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashigClass, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashigClass.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashigVersionClassesClassScenariosGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashigVersionClassesClassScenariosGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashigVersionClassesClassScenariosGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashigVersionClassesClassScenariosGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashigVersionClassesClassScenariosGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashigVersionClassesClassScenariosGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashigVersionClassesClassScenariosGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashigVersionClassesClassScenariosGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashigVersionClassesClassScenariosGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashigVersionClassesClassScenariosGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdashig/{version}/classes/{class}/scenarios
    /// - Get CDASHIG Class Scenario List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter _class: (path) CDASHIG Class Identifier 
    /// - returns: AnyPublisher<CdashigClassScenarios, Error> 
    open func mdrCdashigVersionClassesClassScenariosGet(version: String, _class: String) -> AnyPublisher<CdashigClassScenarios, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdashig/{version}/classes/{class}/scenarios"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{class}", with: _class)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashigClassScenarios, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassScenariosGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassScenariosGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassScenariosGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassScenariosGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassScenariosGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassScenariosGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassScenariosGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassScenariosGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesClassScenariosGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashigClassScenarios.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashigVersionClassesGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashigVersionClassesGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashigVersionClassesGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashigVersionClassesGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashigVersionClassesGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashigVersionClassesGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashigVersionClassesGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashigVersionClassesGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashigVersionClassesGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashigVersionClassesGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdashig/{version}/classes
    /// - Get CDASHIG Class List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - returns: AnyPublisher<CdashigProductClasses, Error> 
    open func mdrCdashigVersionClassesGet(version: String) -> AnyPublisher<CdashigProductClasses, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdashig/{version}/classes"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashigProductClasses, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionClassesGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashigProductClasses.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashigVersionDomainsDomainFieldsFieldGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsFieldGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsFieldGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsFieldGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsFieldGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsFieldGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsFieldGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsFieldGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsFieldGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsFieldGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdashig/{version}/domains/{domain}/fields/{field}
    /// - Get CDASHIG Domain Field
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter domain: (path) CDASHIG Domain Identifier 
    /// - parameter field: (path) CDASHIG Field Identifier 
    /// - returns: AnyPublisher<CdashigDomainField, Error> 
    open func mdrCdashigVersionDomainsDomainFieldsFieldGet(version: String, domain: String, field: String) -> AnyPublisher<CdashigDomainField, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdashig/{version}/domains/{domain}/fields/{field}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{domain}", with: domain)
                localVarPath = localVarPath.replacingOccurrences(of: "{field}", with: field)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashigDomainField, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsFieldGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsFieldGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsFieldGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsFieldGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsFieldGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsFieldGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsFieldGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsFieldGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsFieldGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashigDomainField.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashigVersionDomainsDomainFieldsGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashigVersionDomainsDomainFieldsGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdashig/{version}/domains/{domain}/fields
    /// - Get CDASHIG Domain Field List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter domain: (path) CDASHIG Domain Identifier 
    /// - returns: AnyPublisher<CdashigDomainFields, Error> 
    open func mdrCdashigVersionDomainsDomainFieldsGet(version: String, domain: String) -> AnyPublisher<CdashigDomainFields, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdashig/{version}/domains/{domain}/fields"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{domain}", with: domain)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashigDomainFields, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainFieldsGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashigDomainFields.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashigVersionDomainsDomainGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashigVersionDomainsDomainGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashigVersionDomainsDomainGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashigVersionDomainsDomainGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashigVersionDomainsDomainGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashigVersionDomainsDomainGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashigVersionDomainsDomainGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashigVersionDomainsDomainGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashigVersionDomainsDomainGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashigVersionDomainsDomainGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdashig/{version}/domains/{domain}
    /// - Get CDASHIG Domain
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter domain: (path) CDASHIG Domain Identifier 
    /// - returns: AnyPublisher<CdashigDomain, Error> 
    open func mdrCdashigVersionDomainsDomainGet(version: String, domain: String) -> AnyPublisher<CdashigDomain, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdashig/{version}/domains/{domain}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{domain}", with: domain)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashigDomain, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsDomainGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashigDomain.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashigVersionDomainsGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashigVersionDomainsGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashigVersionDomainsGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashigVersionDomainsGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashigVersionDomainsGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashigVersionDomainsGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashigVersionDomainsGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashigVersionDomainsGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashigVersionDomainsGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashigVersionDomainsGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdashig/{version}/domains
    /// - Get CDASHIG Domain List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - returns: AnyPublisher<CdashigProductDomains, Error> 
    open func mdrCdashigVersionDomainsGet(version: String) -> AnyPublisher<CdashigProductDomains, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdashig/{version}/domains"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashigProductDomains, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionDomainsGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashigProductDomains.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashigVersionGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashigVersionGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashigVersionGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashigVersionGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashigVersionGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashigVersionGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashigVersionGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashigVersionGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashigVersionGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashigVersionGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdashig/{version}
    /// - Get CDASHIG Product
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - returns: AnyPublisher<CdashigProduct, Error> 
    open func mdrCdashigVersionGet(version: String) -> AnyPublisher<CdashigProduct, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdashig/{version}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashigProduct, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashigProduct.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdashig/{version}/scenarios/{domain}.{scenario}/fields/{field}
    /// - Get CDASHIG Scenario Field
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter domain: (path) CDASHIG Domain Identifier 
    /// - parameter scenario: (path) CDASHIG Scenario Identifier 
    /// - parameter field: (path) CDASHIG Field Identifier 
    /// - returns: AnyPublisher<CdashigScenarioField, Error> 
    open func mdrCdashigVersionScenariosDomainScenarioFieldsFieldGet(version: String, domain: String, scenario: String, field: String) -> AnyPublisher<CdashigScenarioField, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdashig/{version}/scenarios/{domain}.{scenario}/fields/{field}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{domain}", with: domain)
                localVarPath = localVarPath.replacingOccurrences(of: "{scenario}", with: scenario)
                localVarPath = localVarPath.replacingOccurrences(of: "{field}", with: field)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashigScenarioField, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsFieldGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashigScenarioField.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashigVersionScenariosDomainScenarioFieldsGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioFieldsGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdashig/{version}/scenarios/{domain}.{scenario}/fields
    /// - Get CDASHIG Scenario Field List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter domain: (path) CDASHIG Domain Identifier 
    /// - parameter scenario: (path) CDASHIG Scenario Identifier 
    /// - returns: AnyPublisher<CdashigScenarioFields, Error> 
    open func mdrCdashigVersionScenariosDomainScenarioFieldsGet(version: String, domain: String, scenario: String) -> AnyPublisher<CdashigScenarioFields, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdashig/{version}/scenarios/{domain}.{scenario}/fields"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{domain}", with: domain)
                localVarPath = localVarPath.replacingOccurrences(of: "{scenario}", with: scenario)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashigScenarioFields, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioFieldsGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashigScenarioFields.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashigVersionScenariosDomainScenarioGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashigVersionScenariosDomainScenarioGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdashig/{version}/scenarios/{domain}.{scenario}
    /// - Get CDASHIG Scenario
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter domain: (path) CDASHIG Domain Identifier 
    /// - parameter scenario: (path) CDASHIG Scenario Identifier 
    /// - returns: AnyPublisher<CdashigScenario, Error> 
    open func mdrCdashigVersionScenariosDomainScenarioGet(version: String, domain: String, scenario: String) -> AnyPublisher<CdashigScenario, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdashig/{version}/scenarios/{domain}.{scenario}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{domain}", with: domain)
                localVarPath = localVarPath.replacingOccurrences(of: "{scenario}", with: scenario)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashigScenario, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosDomainScenarioGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashigScenario.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrCdashigVersionScenariosGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrCdashigVersionScenariosGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrCdashigVersionScenariosGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrCdashigVersionScenariosGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrCdashigVersionScenariosGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrCdashigVersionScenariosGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrCdashigVersionScenariosGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrCdashigVersionScenariosGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrCdashigVersionScenariosGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrCdashigVersionScenariosGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/cdashig/{version}/scenarios
    /// - Get CDASHIG Scenario List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - returns: AnyPublisher<CdashigProductScenarios, Error> 
    open func mdrCdashigVersionScenariosGet(version: String) -> AnyPublisher<CdashigProductScenarios, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/cdashig/{version}/scenarios"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CdashigProductScenarios, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrCdashigVersionScenariosGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(CdashigProductScenarios.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrRootCdashigDomainsDomainFieldsFieldGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrRootCdashigDomainsDomainFieldsFieldGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrRootCdashigDomainsDomainFieldsFieldGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrRootCdashigDomainsDomainFieldsFieldGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrRootCdashigDomainsDomainFieldsFieldGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrRootCdashigDomainsDomainFieldsFieldGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrRootCdashigDomainsDomainFieldsFieldGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrRootCdashigDomainsDomainFieldsFieldGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrRootCdashigDomainsDomainFieldsFieldGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrRootCdashigDomainsDomainFieldsFieldGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/root/cdashig/domains/{domain}/fields/{field}
    /// - Get Root CDASHIG Domain Field
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter domain: (path) CDASHIG Domain Identifier 
    /// - parameter field: (path) CDASHIG Field Identifier 
    /// - returns: AnyPublisher<RootCdashigDomainField, Error> 
    open func mdrRootCdashigDomainsDomainFieldsFieldGet(domain: String, field: String) -> AnyPublisher<RootCdashigDomainField, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/root/cdashig/domains/{domain}/fields/{field}"
                localVarPath = localVarPath.replacingOccurrences(of: "{domain}", with: domain)
                localVarPath = localVarPath.replacingOccurrences(of: "{field}", with: field)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RootCdashigDomainField, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigDomainsDomainFieldsFieldGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigDomainsDomainFieldsFieldGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigDomainsDomainFieldsFieldGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigDomainsDomainFieldsFieldGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigDomainsDomainFieldsFieldGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigDomainsDomainFieldsFieldGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigDomainsDomainFieldsFieldGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigDomainsDomainFieldsFieldGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigDomainsDomainFieldsFieldGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(RootCdashigDomainField.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/root/cdashig/scenarios/{domain}.{scenario}/fields/{field}
    /// - Get Root CDASHIG Scenario Field
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter domain: (path) CDASHIG Domain Identifier 
    /// - parameter scenario: (path) CDASHIG Scenario Identifier 
    /// - parameter field: (path) CDASHIG Field Identifier 
    /// - returns: AnyPublisher<RootCdashigScenarioField, Error> 
    open func mdrRootCdashigScenariosDomainScenarioFieldsFieldGet(domain: String, scenario: String, field: String) -> AnyPublisher<RootCdashigScenarioField, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/root/cdashig/scenarios/{domain}.{scenario}/fields/{field}"
                localVarPath = localVarPath.replacingOccurrences(of: "{domain}", with: domain)
                localVarPath = localVarPath.replacingOccurrences(of: "{scenario}", with: scenario)
                localVarPath = localVarPath.replacingOccurrences(of: "{field}", with: field)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RootCdashigScenarioField, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootCdashigScenariosDomainScenarioFieldsFieldGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(RootCdashigScenarioField.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
