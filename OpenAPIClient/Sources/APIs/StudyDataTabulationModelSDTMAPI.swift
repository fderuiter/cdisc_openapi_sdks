//
// StudyDataTabulationModelSDTMAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class StudyDataTabulationModelSDTMAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://library.cdisc.org/api")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum MdrRootSdtmClassesClassVariablesVarGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrRootSdtmClassesClassVariablesVarGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrRootSdtmClassesClassVariablesVarGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrRootSdtmClassesClassVariablesVarGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrRootSdtmClassesClassVariablesVarGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrRootSdtmClassesClassVariablesVarGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrRootSdtmClassesClassVariablesVarGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrRootSdtmClassesClassVariablesVarGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrRootSdtmClassesClassVariablesVarGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrRootSdtmClassesClassVariablesVarGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/root/sdtm/classes/{class}/variables/{var}
    /// - Get Root of SDTM Class Variable
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter _class: (path) SDTM Class Identifier 
    /// - parameter _var: (path) SDTM Variable Identifier 
    /// - returns: AnyPublisher<RootSdtmClassVariable, Error> 
    open func mdrRootSdtmClassesClassVariablesVarGet(_class: String, _var: String) -> AnyPublisher<RootSdtmClassVariable, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/root/sdtm/classes/{class}/variables/{var}"
                localVarPath = localVarPath.replacingOccurrences(of: "{class}", with: _class)
                localVarPath = localVarPath.replacingOccurrences(of: "{var}", with: _var)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RootSdtmClassVariable, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmClassesClassVariablesVarGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmClassesClassVariablesVarGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmClassesClassVariablesVarGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmClassesClassVariablesVarGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmClassesClassVariablesVarGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmClassesClassVariablesVarGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmClassesClassVariablesVarGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmClassesClassVariablesVarGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmClassesClassVariablesVarGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(RootSdtmClassVariable.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrRootSdtmDatasetsDatasetVariablesVarGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrRootSdtmDatasetsDatasetVariablesVarGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrRootSdtmDatasetsDatasetVariablesVarGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrRootSdtmDatasetsDatasetVariablesVarGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrRootSdtmDatasetsDatasetVariablesVarGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrRootSdtmDatasetsDatasetVariablesVarGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrRootSdtmDatasetsDatasetVariablesVarGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrRootSdtmDatasetsDatasetVariablesVarGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrRootSdtmDatasetsDatasetVariablesVarGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrRootSdtmDatasetsDatasetVariablesVarGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/root/sdtm/datasets/{dataset}/variables/{var}
    /// - Get Root SDTM Dataset Variable
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter dataset: (path) SDTM Dataset Identifier 
    /// - parameter _var: (path) SDTM Variable Identifier 
    /// - returns: AnyPublisher<RootSdtmDatasetVariable, Error> 
    open func mdrRootSdtmDatasetsDatasetVariablesVarGet(dataset: String, _var: String) -> AnyPublisher<RootSdtmDatasetVariable, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/root/sdtm/datasets/{dataset}/variables/{var}"
                localVarPath = localVarPath.replacingOccurrences(of: "{dataset}", with: dataset)
                localVarPath = localVarPath.replacingOccurrences(of: "{var}", with: _var)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RootSdtmDatasetVariable, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmDatasetsDatasetVariablesVarGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmDatasetsDatasetVariablesVarGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmDatasetsDatasetVariablesVarGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmDatasetsDatasetVariablesVarGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmDatasetsDatasetVariablesVarGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmDatasetsDatasetVariablesVarGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmDatasetsDatasetVariablesVarGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmDatasetsDatasetVariablesVarGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrRootSdtmDatasetsDatasetVariablesVarGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(RootSdtmDatasetVariable.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrSdtmVersionClassesClassDatasetsGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrSdtmVersionClassesClassDatasetsGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrSdtmVersionClassesClassDatasetsGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrSdtmVersionClassesClassDatasetsGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrSdtmVersionClassesClassDatasetsGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrSdtmVersionClassesClassDatasetsGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrSdtmVersionClassesClassDatasetsGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrSdtmVersionClassesClassDatasetsGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrSdtmVersionClassesClassDatasetsGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrSdtmVersionClassesClassDatasetsGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/sdtm/{version}/classes/{class}/datasets
    /// - Get SDTM Class Dataset List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter _class: (path) SDTM Class Identifier 
    /// - returns: AnyPublisher<SdtmClassDatasets, Error> 
    open func mdrSdtmVersionClassesClassDatasetsGet(version: String, _class: String) -> AnyPublisher<SdtmClassDatasets, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/sdtm/{version}/classes/{class}/datasets"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{class}", with: _class)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SdtmClassDatasets, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassDatasetsGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassDatasetsGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassDatasetsGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassDatasetsGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassDatasetsGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassDatasetsGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassDatasetsGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassDatasetsGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassDatasetsGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SdtmClassDatasets.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrSdtmVersionClassesClassGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrSdtmVersionClassesClassGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrSdtmVersionClassesClassGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrSdtmVersionClassesClassGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrSdtmVersionClassesClassGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrSdtmVersionClassesClassGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrSdtmVersionClassesClassGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrSdtmVersionClassesClassGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrSdtmVersionClassesClassGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrSdtmVersionClassesClassGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/sdtm/{version}/classes/{class}
    /// - Get SDTM Class
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter _class: (path) SDTM Class Identifier 
    /// - returns: AnyPublisher<SdtmClass, Error> 
    open func mdrSdtmVersionClassesClassGet(version: String, _class: String) -> AnyPublisher<SdtmClass, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/sdtm/{version}/classes/{class}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{class}", with: _class)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SdtmClass, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SdtmClass.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrSdtmVersionClassesClassVariablesGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrSdtmVersionClassesClassVariablesGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrSdtmVersionClassesClassVariablesGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrSdtmVersionClassesClassVariablesGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrSdtmVersionClassesClassVariablesGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrSdtmVersionClassesClassVariablesGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrSdtmVersionClassesClassVariablesGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrSdtmVersionClassesClassVariablesGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrSdtmVersionClassesClassVariablesGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrSdtmVersionClassesClassVariablesGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/sdtm/{version}/classes/{class}/variables
    /// - Get SDTM Class Variable List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter _class: (path) SDTM Class Identifier 
    /// - returns: AnyPublisher<SdtmClassVariables, Error> 
    open func mdrSdtmVersionClassesClassVariablesGet(version: String, _class: String) -> AnyPublisher<SdtmClassVariables, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/sdtm/{version}/classes/{class}/variables"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{class}", with: _class)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SdtmClassVariables, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SdtmClassVariables.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrSdtmVersionClassesClassVariablesVarGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrSdtmVersionClassesClassVariablesVarGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrSdtmVersionClassesClassVariablesVarGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrSdtmVersionClassesClassVariablesVarGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrSdtmVersionClassesClassVariablesVarGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrSdtmVersionClassesClassVariablesVarGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrSdtmVersionClassesClassVariablesVarGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrSdtmVersionClassesClassVariablesVarGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrSdtmVersionClassesClassVariablesVarGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrSdtmVersionClassesClassVariablesVarGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/sdtm/{version}/classes/{class}/variables/{var}
    /// - Get SDTM Class Variable
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter _class: (path) SDTM Class Identifier 
    /// - parameter _var: (path) SDTM Variable Identifier 
    /// - returns: AnyPublisher<SdtmClassVariable, Error> 
    open func mdrSdtmVersionClassesClassVariablesVarGet(version: String, _class: String, _var: String) -> AnyPublisher<SdtmClassVariable, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/sdtm/{version}/classes/{class}/variables/{var}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{class}", with: _class)
                localVarPath = localVarPath.replacingOccurrences(of: "{var}", with: _var)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SdtmClassVariable, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesVarGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesVarGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesVarGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesVarGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesVarGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesVarGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesVarGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesVarGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesClassVariablesVarGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SdtmClassVariable.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrSdtmVersionClassesGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrSdtmVersionClassesGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrSdtmVersionClassesGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrSdtmVersionClassesGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrSdtmVersionClassesGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrSdtmVersionClassesGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrSdtmVersionClassesGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrSdtmVersionClassesGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrSdtmVersionClassesGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrSdtmVersionClassesGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/sdtm/{version}/classes
    /// - Get SDTM Class List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - returns: AnyPublisher<SdtmClasses, Error> 
    open func mdrSdtmVersionClassesGet(version: String) -> AnyPublisher<SdtmClasses, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/sdtm/{version}/classes"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SdtmClasses, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionClassesGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SdtmClasses.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrSdtmVersionDatasetsDatasetGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrSdtmVersionDatasetsDatasetGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrSdtmVersionDatasetsDatasetGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrSdtmVersionDatasetsDatasetGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrSdtmVersionDatasetsDatasetGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrSdtmVersionDatasetsDatasetGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrSdtmVersionDatasetsDatasetGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrSdtmVersionDatasetsDatasetGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrSdtmVersionDatasetsDatasetGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrSdtmVersionDatasetsDatasetGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/sdtm/{version}/datasets/{dataset}
    /// - Get SDTM Dataset
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter dataset: (path) SDTM Dataset Identifier 
    /// - returns: AnyPublisher<SdtmDataset, Error> 
    open func mdrSdtmVersionDatasetsDatasetGet(version: String, dataset: String) -> AnyPublisher<SdtmDataset, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/sdtm/{version}/datasets/{dataset}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{dataset}", with: dataset)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SdtmDataset, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SdtmDataset.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrSdtmVersionDatasetsDatasetVariablesGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/sdtm/{version}/datasets/{dataset}/variables
    /// - Get SDTM Dataset Variable List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter dataset: (path) SDTM Dataset Identifier 
    /// - returns: AnyPublisher<SdtmDatasetVariables, Error> 
    open func mdrSdtmVersionDatasetsDatasetVariablesGet(version: String, dataset: String) -> AnyPublisher<SdtmDatasetVariables, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/sdtm/{version}/datasets/{dataset}/variables"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{dataset}", with: dataset)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SdtmDatasetVariables, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SdtmDatasetVariables.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrSdtmVersionDatasetsDatasetVariablesVarGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesVarGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesVarGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesVarGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesVarGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesVarGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesVarGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesVarGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesVarGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrSdtmVersionDatasetsDatasetVariablesVarGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/sdtm/{version}/datasets/{dataset}/variables/{var}
    /// - Get SDTM Dataset Variable
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - parameter dataset: (path) SDTM Dataset Identifier 
    /// - parameter _var: (path) SDTM Variable Identifier 
    /// - returns: AnyPublisher<SdtmDatasetVariable, Error> 
    open func mdrSdtmVersionDatasetsDatasetVariablesVarGet(version: String, dataset: String, _var: String) -> AnyPublisher<SdtmDatasetVariable, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/sdtm/{version}/datasets/{dataset}/variables/{var}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                localVarPath = localVarPath.replacingOccurrences(of: "{dataset}", with: dataset)
                localVarPath = localVarPath.replacingOccurrences(of: "{var}", with: _var)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SdtmDatasetVariable, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesVarGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesVarGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesVarGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesVarGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesVarGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesVarGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesVarGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesVarGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsDatasetVariablesVarGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SdtmDatasetVariable.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrSdtmVersionDatasetsGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrSdtmVersionDatasetsGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrSdtmVersionDatasetsGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrSdtmVersionDatasetsGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrSdtmVersionDatasetsGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrSdtmVersionDatasetsGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrSdtmVersionDatasetsGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrSdtmVersionDatasetsGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrSdtmVersionDatasetsGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrSdtmVersionDatasetsGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/sdtm/{version}/datasets
    /// - Get SDTM Dataset List
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - returns: AnyPublisher<SdtmDatasets, Error> 
    open func mdrSdtmVersionDatasetsGet(version: String) -> AnyPublisher<SdtmDatasets, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/sdtm/{version}/datasets"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SdtmDatasets, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionDatasetsGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SdtmDatasets.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum MdrSdtmVersionGetError: Error, CustomStringConvertible {
        // Bad Request
        case code400Error(DefaultErrorResponse)
        // Unauthorized
        case code401Error(DefaultErrorResponse)
        // Forbidden
        case code403Error(DefaultErrorResponse)
        // Not Found
        case code404Error(DefaultErrorResponse)
        // Method Not Allowed
        case code405Error(DefaultErrorResponse)
        // Not Acceptable
        case code406Error(DefaultErrorResponse)
        // Internal Server Error
        case code500Error(DefaultErrorResponse)
        // Service Unavailable
        case code503Error(DefaultErrorResponse)
        // Gateway Timeout Error
        case code504Error(DefaultErrorResponse)

        public var description: String {
            switch self {
            case .code400Error(let object):
                return "MdrSdtmVersionGetError: Bad Request: \(object)"
            case .code401Error(let object):
                return "MdrSdtmVersionGetError: Unauthorized: \(object)"
            case .code403Error(let object):
                return "MdrSdtmVersionGetError: Forbidden: \(object)"
            case .code404Error(let object):
                return "MdrSdtmVersionGetError: Not Found: \(object)"
            case .code405Error(let object):
                return "MdrSdtmVersionGetError: Method Not Allowed: \(object)"
            case .code406Error(let object):
                return "MdrSdtmVersionGetError: Not Acceptable: \(object)"
            case .code500Error(let object):
                return "MdrSdtmVersionGetError: Internal Server Error: \(object)"
            case .code503Error(let object):
                return "MdrSdtmVersionGetError: Service Unavailable: \(object)"
            case .code504Error(let object):
                return "MdrSdtmVersionGetError: Gateway Timeout Error: \(object)"
            }
        }
    }

    /// - GET /mdr/sdtm/{version}
    /// - Get SDTM product
    /// - BASIC:
    /// - type: http
    /// - name: basicAuth
    /// - parameter version: (path) CDISC Library Product Version 
    /// - returns: AnyPublisher<SdtmProduct, Error> 
    open func mdrSdtmVersionGet(version: String) -> AnyPublisher<SdtmProduct, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/mdr/sdtm/{version}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: version)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SdtmProduct, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionGetError.code400Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 401 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionGetError.code401Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 403 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionGetError.code403Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 404 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionGetError.code404Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 405 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionGetError.code405Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 406 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionGetError.code406Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 500 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionGetError.code500Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 503 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionGetError.code503Error(error)
                        } catch {
                            return error
                        }
                    }
                    if transportError.statusCode == 504 {
                        do {
                            let error = try self.decoder.decode(DefaultErrorResponse.self, from: transportError.data)
                            return MdrSdtmVersionGetError.code504Error(error)
                        } catch {
                            return error
                        }
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(SdtmProduct.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
