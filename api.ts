/* tslint:disable */
/* eslint-disable */
/**
 * CDISC Library API
 * REST API Documentation for CDISC Library in production server
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: cdisc_library_support@cdisc.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface About {
    '_links'?: AboutLinks;
    'release-notes'?: string;
    'api-documentation'?: string;
}
export interface AboutLinks {
    'self'?: AboutRef;
    'lastupdated'?: LastupdatedRef;
}
export interface AboutRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface AdamDatastructure {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'class'?: string;
    '_links'?: AdamDatastructureLinks;
    'analysisVariableSets'?: Array<AdamVarset>;
}
export interface AdamDatastructureLinks {
    'self'?: AdamDatastructureRef;
    'parentProduct'?: AdamProductRef;
    'priorVersion'?: AdamDatastructureRef;
}
export interface AdamDatastructureRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface AdamDatastructureRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface AdamDatastructureVariables {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'class'?: string;
    '_links'?: AdamDatastructureVariablesLinks;
}
export interface AdamDatastructureVariablesLinks {
    'self'?: AdamDatastructureVariablesRef;
    'parentProduct'?: AdamProductRef;
    'priorVersion'?: AdamDatastructureVariablesRef;
    'analysisVariables'?: Array<AdamVariableRefElement>;
}
export interface AdamDatastructureVariablesRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface AdamDatastructureVarsets {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'class'?: string;
    '_links'?: AdamDatastructureVarsetsLinks;
}
export interface AdamDatastructureVarsetsLinks {
    'self'?: AdamDatastructureVarsetsRef;
    'parentProduct'?: AdamProductRef;
    'priorVersion'?: AdamDatastructureVarsetsRef;
    'analysisVariableSets'?: Array<AdamVarsetRefElement>;
}
export interface AdamDatastructureVarsetsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface AdamProduct {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: AdamProductLinks;
    'dataStructures'?: Array<AdamDatastructure>;
}
export interface AdamProductDatastructures {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: AdamProductDatastructuresLinks;
}
export interface AdamProductDatastructuresLinks {
    'self'?: AdamProductDatastructuresRef;
    'priorVersion'?: AdamProductDatastructuresRef;
    'dataStructures'?: Array<AdamDatastructureRefElement>;
}
export interface AdamProductDatastructuresRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface AdamProductLinks {
    'self'?: AdamProductRef;
    'model'?: AdamProductRef;
    'priorVersion'?: AdamProductRef;
}
export interface AdamProductRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface AdamProductRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface AdamVariable {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'core'?: string;
    'simpleDatatype'?: string;
    'describedValueDomain'?: string;
    'valueList'?: Array<string>;
    '_links'?: AdamVariableLinks;
}
export interface AdamVariableLinks {
    'self'?: AdamVariableRef;
    'codelist'?: RootCtCodelistRef;
    'parentProduct'?: AdamProductRef;
    'parentDatastructure'?: AdamDatastructureRef;
    'parentVariableSet'?: AdamVarsetRef;
    'priorVersion'?: AdamVariableRef;
}
export interface AdamVariableRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface AdamVariableRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface AdamVarset {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    '_links'?: AdamVarsetLinks;
    'analysisVariables'?: Array<AdamVariable>;
}
export interface AdamVarsetLinks {
    'self'?: AdamVarsetRef;
    'parentProduct'?: AdamProductRef;
    'parentDatastructure'?: AdamDatastructureRef;
    'priorVersion'?: AdamVarsetRef;
}
export interface AdamVarsetRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface AdamVarsetRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashClass {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    '_links'?: CdashClassLinks;
    'cdashModelFields'?: Array<CdashClassField>;
}
export interface CdashClassDomains {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    '_links'?: CdashClassDomainsLinks;
}
export interface CdashClassDomainsLinks {
    'self'?: CdashClassDomainsRef;
    'domains'?: Array<CdashDomainRefElement>;
}
export interface CdashClassDomainsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashClassField {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'definition'?: string;
    'questionText'?: string;
    'prompt'?: string;
    'simpleDatatype'?: string;
    'implementationNotes'?: string;
    'mappingInstructions'?: string;
    '_links'?: CdashClassFieldLinks;
}
export interface CdashClassFieldLinks {
    'self'?: CdashClassFieldRef;
    'codelist'?: Array<RootCtCodelistRefElement>;
    'parentProduct'?: CdashProductRef;
    'parentClass'?: CdashClassRef;
    'rootItem'?: RootCdashClassFieldRef;
    'priorVersion'?: CdashClassFieldRef;
    'sdtmClassMappingTargets'?: Array<SdtmClassVariableRefTarget>;
    'sdtmDatasetMappingTargets'?: Array<SdtmDatasetVariableRefTarget>;
}
export interface CdashClassFieldRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashClassFieldRefVersion {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashClassLinks {
    'self'?: CdashClassRef;
    'parentProduct'?: CdashProductRef;
    'priorVersion'?: CdashClassRef;
}
export interface CdashClassRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashClassRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashDomain {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    '_links'?: CdashDomainLinks;
    'fields'?: Array<CdashDomainField>;
}
export interface CdashDomainField {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'definition'?: string;
    'domainSpecific'?: string;
    'questionText'?: string;
    'prompt'?: string;
    'simpleDatatype'?: string;
    'implementationNotes'?: string;
    'mappingInstructions'?: string;
    '_links'?: CdashDomainFieldLinks;
}
export interface CdashDomainFieldLinks {
    'self'?: CdashDomainFieldRef;
    'codelist'?: Array<RootCtCodelistRefElement>;
    'parentProduct'?: CdashProductRef;
    'parentClass'?: CdashClassRef;
    'parentDomain'?: CdashDomainRef;
    'rootItem'?: RootCdashDomainFieldRef;
    'priorVersion'?: CdashDomainFieldRef;
    'sdtmDatasetMappingTargets'?: Array<SdtmDatasetVariableRefTarget>;
    'sdtmigDatasetMappingTargets'?: Array<SdtmigDatasetVariableRefTarget>;
}
export interface CdashDomainFieldRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashDomainFieldRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashDomainFieldRefVersion {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashDomainFields {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    '_links'?: CdashDomainFieldsLinks;
}
export interface CdashDomainFieldsLinks {
    'self'?: CdashDomainFieldsRef;
    'parentProduct'?: CdashProductRef;
    'parentClass'?: CdashClassRef;
    'fields'?: Array<CdashDomainFieldRefElement>;
}
export interface CdashDomainFieldsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashDomainLinks {
    'self'?: CdashDomainRef;
    'parentProduct'?: CdashProductRef;
    'parentClass'?: CdashClassRef;
    'priorVersion'?: CdashDomainRef;
}
export interface CdashDomainRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashDomainRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashProduct {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: CdashProductLinks;
    'classes'?: Array<CdashClass>;
    'domains'?: Array<CdashDomain>;
}
export interface CdashProductClasses {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: CdashProductClassesLinks;
}
export interface CdashProductClassesLinks {
    'self'?: CdashProductClassesRef;
    'parentProduct'?: CdashProductRef;
    'classes'?: Array<CdashClassRefElement>;
}
export interface CdashProductClassesRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashProductDomains {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: CdashProductDomainsLinks;
}
export interface CdashProductDomainsLinks {
    'self'?: CdashProductDomainsRef;
    'parentProduct'?: CdashProductRef;
    'domains'?: Array<CdashDomainRefElement>;
}
export interface CdashProductDomainsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashProductLinks {
    'self'?: CdashProductRef;
    'priorVersion'?: CdashProductRef;
}
export interface CdashProductRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashProductRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigClass {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    '_links'?: CdashigClassLinks;
    'domains'?: Array<CdashigDomain>;
    'scenarios'?: Array<CdashigScenario>;
}
export interface CdashigClassDomains {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    '_links'?: CdashigClassDomainsLinks;
}
export interface CdashigClassDomainsLinks {
    'self'?: CdashigClassDomainsRef;
    'domains'?: Array<CdashigDomainRefElement>;
}
export interface CdashigClassDomainsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigClassLinks {
    'self'?: CdashigClassRef;
    'modelClass'?: CdashClassRef;
    'parentProduct'?: CdashigProductRef;
    'parentClass'?: CdashigClassRef;
    'subclasses'?: Array<CdashigClassRefSubclass>;
    'priorVersion'?: CdashigClassRef;
}
export interface CdashigClassRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigClassRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigClassRefSubclass {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigClassScenarios {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    '_links'?: CdashigClassScenariosLinks;
}
export interface CdashigClassScenariosLinks {
    'self'?: CdashigClassScenariosRef;
    'scenarios'?: Array<CdashigScenarioRefElement>;
}
export interface CdashigClassScenariosRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigDomain {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    '_links'?: CdashigDomainLinks;
    'fields'?: Array<CdashigDomainField>;
}
export interface CdashigDomainField {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'definition'?: string;
    'questionText'?: string;
    'prompt'?: string;
    'completionInstructions'?: string;
    'implementationNotes'?: string;
    'simpleDatatype'?: string;
    'mappingInstructions'?: string;
    'core'?: string;
    '_links'?: CdashigDomainFieldLinks;
}
export interface CdashigDomainFieldLinks {
    'self'?: CdashigDomainFieldRef;
    'codelist'?: Array<RootCtCodelistRefElement>;
    'parentProduct'?: CdashigProductRef;
    'parentDomain'?: CdashigDomainRef;
    'rootItem'?: RootCdashigDomainFieldRef;
    'priorVersion'?: CdashigDomainFieldRef;
    'sdtmClassMappingTargets'?: Array<SdtmClassVariableRefTarget>;
    'sdtmigDatasetMappingTargets'?: Array<SdtmigDatasetVariableRefTarget>;
}
export interface CdashigDomainFieldRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigDomainFieldRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigDomainFieldRefVersion {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigDomainFields {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    '_links'?: CdashigDomainFieldsLinks;
}
export interface CdashigDomainFieldsLinks {
    'self'?: CdashigDomainFieldsRef;
    'parentProduct'?: CdashigProductRef;
    'parentClass'?: CdashigClassRef;
    'fields'?: Array<CdashigDomainFieldRefElement>;
}
export interface CdashigDomainFieldsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigDomainLinks {
    'self'?: CdashigDomainRef;
    'parentProduct'?: CdashigProductRef;
    'parentClass'?: CdashigClassRef;
    'priorVersion'?: CdashigDomainRef;
    'scenarios'?: Array<CdashigScenarioRefElement>;
}
export interface CdashigDomainRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigDomainRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigProduct {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: CdashigProductLinks;
    'classes'?: Array<CdashigClass>;
}
export interface CdashigProductClasses {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: CdashigProductClassesLinks;
}
export interface CdashigProductClassesLinks {
    'self'?: CdashigProductClassesRef;
    'parentProduct'?: CdashigProductRef;
    'classes'?: Array<CdashigClassRefElement>;
}
export interface CdashigProductClassesRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigProductDomains {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: CdashigProductDomainsLinks;
}
export interface CdashigProductDomainsLinks {
    'self'?: CdashigProductDomainsRef;
    'parentProduct'?: CdashigProductRef;
    'domains'?: Array<CdashigDomainRefElement>;
}
export interface CdashigProductDomainsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigProductLinks {
    'self'?: CdashigProductRef;
    'model'?: CdashProductRef;
    'priorVersion'?: CdashigProductRef;
}
export interface CdashigProductRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigProductRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigProductScenarios {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: CdashigProductScenariosLinks;
}
export interface CdashigProductScenariosLinks {
    'self'?: CdashigProductScenariosRef;
    'parentProduct'?: CdashigProductRef;
    'scenarios'?: Array<CdashigScenarioRefElement>;
}
export interface CdashigProductScenariosRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigScenario {
    'ordinal'?: string;
    'domain'?: string;
    'scenario'?: string;
    '_links'?: CdashigScenarioLinks;
    'fields'?: Array<CdashigScenarioField>;
}
export interface CdashigScenarioField {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'definition'?: string;
    'questionText'?: string;
    'prompt'?: string;
    'completionInstructions'?: string;
    'implementationNotes'?: string;
    'simpleDatatype'?: string;
    'mappingInstructions'?: string;
    'core'?: string;
    '_links'?: CdashigScenarioFieldLinks;
}
export interface CdashigScenarioFieldLinks {
    'self'?: CdashigScenarioFieldRef;
    'codelist'?: Array<RootCtCodelistRefElement>;
    'parentProduct'?: CdashigProductRef;
    'parentDomain'?: CdashigDomainRef;
    'parentScenario'?: CdashigScenarioRef;
    'rootItem'?: RootCdashigScenarioFieldRef;
    'priorVersion'?: CdashigScenarioFieldRef;
    'sdtmigDatasetMappingTargets'?: Array<SdtmigDatasetVariableRefTarget>;
}
export interface CdashigScenarioFieldRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigScenarioFieldRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigScenarioFieldRefVersion {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigScenarioFields {
    'ordinal'?: string;
    'domain'?: string;
    'scenario'?: string;
    '_links'?: CdashigScenarioFieldsLinks;
}
export interface CdashigScenarioFieldsLinks {
    'self'?: CdashigScenarioFieldsRef;
    'parentProduct'?: CdashigProductRef;
    'parentClass'?: CdashigClassRef;
    'parentDomain'?: CdashigDomainRef;
    'fields'?: Array<CdashigScenarioFieldRefElement>;
}
export interface CdashigScenarioFieldsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigScenarioLinks {
    'self'?: CdashigScenarioRef;
    'parentProduct'?: CdashigProductRef;
    'parentClass'?: CdashigClassRef;
    'parentDomain'?: CdashigDomainRef;
    'priorVersion'?: CdashigScenarioRef;
}
export interface CdashigScenarioRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CdashigScenarioRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CtCodelist {
    'conceptId'?: string;
    'extensible'?: string;
    'name'?: string;
    'submissionValue'?: string;
    'definition'?: string;
    'preferredTerm'?: string;
    'synonyms'?: Array<string>;
    '_links'?: CtCodelistLinks;
    'terms'?: Array<CtPackageTerm>;
}
export interface CtCodelistLinks {
    'self'?: CtCodelistRef;
    'parentPackage'?: CtPackageRef;
    'rootItem'?: RootCtCodelistRef;
    'priorVersion'?: CtCodelistRef;
}
export interface CtCodelistRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CtCodelistRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CtCodelistRefVersion {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CtCodelistTerms {
    'conceptId'?: string;
    'extensible'?: string;
    'name'?: string;
    'submissionValue'?: string;
    'definition'?: string;
    'preferredTerm'?: string;
    'synonyms'?: Array<string>;
    '_links'?: CtCodelistTermsLinks;
}
export interface CtCodelistTermsLinks {
    'self'?: CtCodelistTermsRef;
    'parentPackage'?: CtPackageRef;
    'rootItem'?: RootCtCodelistRef;
    'priorVersion'?: CtCodelistTermsRef;
    'terms'?: Array<CtTermRefElement>;
}
export interface CtCodelistTermsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CtPackage {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: CtPackageLinks;
    'codelists'?: Array<CtPackageCodelists>;
}
export interface CtPackageCodelists {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: CtPackageCodelistsLinks;
}
export interface CtPackageCodelistsLinks {
    'self'?: CtPackageCodelistsRef;
    'priorVersion'?: CtPackageCodelistsRef;
    'codelists'?: Array<CtCodelistRefElement>;
}
export interface CtPackageCodelistsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CtPackageLinks {
    'self'?: CtPackageRef;
    'priorVersion'?: CtPackageRef;
}
export interface CtPackageRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CtPackageRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CtPackageTerm {
    'conceptId'?: string;
    'submissionValue'?: string;
    'definition'?: string;
    'preferredTerm'?: string;
    'synonyms'?: Array<string>;
}
export interface CtPackages {
    '_links'?: CtPackagesLinks;
}
export interface CtPackagesLinks {
    'self'?: CtPackagesRef;
    'packages'?: Array<CtPackageRefElement>;
}
export interface CtPackagesRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CtTerm {
    'conceptId'?: string;
    'submissionValue'?: string;
    'definition'?: string;
    'preferredTerm'?: string;
    'synonyms'?: Array<string>;
    '_links'?: CtTermLinks;
}
export interface CtTermLinks {
    'self'?: CtTermRef;
    'parentPackage'?: CtPackageRef;
    'parentCodelist'?: CtCodelistRef;
    'rootItem'?: RootCtTermRef;
    'priorVersion'?: CtTermRef;
}
export interface CtTermRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CtTermRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface CtTermRefVersion {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface DefaultErrorResponse {
    /**
     * HTTP Status Code
     */
    'statusCode'?: string;
    /**
     * HTTP Reason Phrase
     */
    'reasonPhrase'?: string;
    /**
     * User Error Message
     */
    'userMessage'?: string;
    /**
     * Admin Error Message
     */
    'adminMessage'?: string;
}
export interface DefaultSearchResponse {
    'hits'?: Array<DefaultSearchResponseHitsInner>;
    'totalHits'?: number;
}
export interface DefaultSearchResponseHitsInner {
    [key: string]: string | any;

    'href': string;
    'type': string;
}

export const DefaultSearchScopes = {
    Class: 'class',
    Codelist: 'codelist',
    ConceptId: 'conceptId',
    Core: 'core',
    DataStructure: 'dataStructure',
    DatasetStructure: 'datasetStructure',
    Definition: 'definition',
    Description: 'description',
    Domain: 'domain',
    EffectiveDate: 'effectiveDate',
    Extensible: 'extensible',
    Href: 'href',
    Label: 'label',
    MeasureType: 'measureType',
    Name: 'name',
    PreferredTerm: 'preferredTerm',
    Product: 'product',
    ProductGroup: 'productGroup',
    RegistrationStatus: 'registrationStatus',
    RoleDescription: 'roleDescription',
    SdtmTarget: 'sdtmTarget',
    SimpleDatatype: 'simpleDatatype',
    SubmissionValue: 'submissionValue',
    Synonyms: 'synonyms',
    Type: 'type',
    UiHref: 'uiHref',
    ValueDomain: 'valueDomain',
    VariableSet: 'variableSet',
    Version: 'version'
} as const;

export type DefaultSearchScopes = typeof DefaultSearchScopes[keyof typeof DefaultSearchScopes];


export interface ExportAdamDatastructuresRow {
    'Version'?: string;
    'Data Structure Name'?: string;
    'Dataset Name'?: string;
    'Dataset Label'?: string;
    'Dataset Description'?: string;
    'Class'?: string;
}
export interface ExportAdamDatastructuresTable {
    'datastructures'?: Array<ExportAdamDatastructuresRow>;
}
export interface ExportAdamVariablesRow {
    'Version'?: string;
    'Data Structure Name'?: string;
    'Dataset Name'?: string;
    'Variable Group'?: string;
    'Variable Name'?: string;
    'Variable Label'?: string;
    'Type'?: string;
    'Codelist/Controlled Terms'?: string;
    'Core'?: string;
    'CDISC Notes'?: string;
}
export interface ExportAdamVariablesTable {
    'variables'?: Array<ExportAdamVariablesRow>;
}
export interface ExportAdamWorkbook {
    'variables'?: Array<ExportAdamVariablesRow>;
    'datastructures'?: Array<ExportAdamDatastructuresRow>;
}
export interface ExportCdashClassVariablesRow {
    'Version'?: string;
    'Class'?: string;
    'Domain'?: string;
    'Variable Order'?: string;
    'CDASH Variable'?: string;
    'CDASH Variable Label'?: string;
    'DRAFT CDASH Definition'?: string;
    'Domain Specific'?: string;
    'Question Text'?: string;
    'Prompt'?: string;
    'Type'?: string;
    'SDTM Target'?: Array<string>;
    'Mapping Instructions'?: string;
    'Controlled Terminology Codelist Name'?: string;
    'Implementation Notes'?: string;
}
export interface ExportCdashDomainVariablesRow {
    'Version'?: string;
    'Class'?: string;
    'Domain'?: string;
    'Variable Order'?: string;
    'CDASH Variable'?: string;
    'CDASH Variable Label'?: string;
    'DRAFT CDASH Definition'?: string;
    'Domain Specific'?: string;
    'Question Text'?: string;
    'Prompt'?: string;
    'Type'?: string;
    'SDTM Target'?: Array<string>;
    'Mapping Instructions'?: string;
    'Controlled Terminology Codelist Name'?: string;
    'Implementation Notes'?: string;
}
export interface ExportCdashTable {
    'class-variables'?: Array<ExportCdashClassVariablesRow>;
    'domain-variables'?: Array<ExportCdashDomainVariablesRow>;
}
export interface ExportCdashigDomainVariablesRow {
    'Version'?: string;
    'Class'?: string;
    'Domain'?: string;
    'Data Collection Scenario'?: string;
    'Variable Order'?: string;
    'CDASHIG Variable'?: string;
    'CDASHIG Variable Label'?: string;
    'DRAFT CDASHIG Definition'?: string;
    'Question Text'?: string;
    'Prompt'?: string;
    'Type'?: string;
    'CDASHIG Core'?: string;
    'Case Report Form Completion Instructions'?: string;
    'SDTMIG Target'?: Array<string>;
    'Mapping Instructions'?: string;
    'Controlled Terminology Codelist Name'?: string;
    'Implementation Notes'?: string;
}
export interface ExportCdashigScenarioVariablesRow {
    'Version'?: string;
    'Class'?: string;
    'Domain'?: string;
    'Data Collection Scenario'?: string;
    'Variable Order'?: string;
    'CDASHIG Variable'?: string;
    'CDASHIG Variable Label'?: string;
    'DRAFT CDASHIG Definition'?: string;
    'Question Text'?: string;
    'Prompt'?: string;
    'Type'?: string;
    'CDASHIG Core'?: string;
    'Case Report Form Completion Instructions'?: string;
    'SDTMIG Target'?: Array<string>;
    'Mapping Instructions'?: string;
    'Controlled Terminology Codelist Name'?: string;
    'Implementation Notes'?: string;
}
export interface ExportCdashigTable {
    'domain-variables'?: Array<ExportCdashigDomainVariablesRow>;
    'scenario-variables'?: Array<ExportCdashigScenarioVariablesRow>;
}
export interface ExportCtCodelist {
    'Code'?: string;
    'Codelist Code'?: string;
    'Codelist Extensible (Yes/No)'?: string;
    'Codelist Name'?: string;
    'CDISC Submission Value'?: string;
    'CDISC Synonym(s)'?: Array<string>;
    'CDISC Definition'?: string;
    'NCI Preferred Term'?: string;
    'Standard and Date'?: string;
    ''?: Array<ExportCtTerm>;
}
export interface ExportCtTable {
    'ct'?: Array<ExportCtCodelist>;
}
export interface ExportCtTerm {
    'bundle-1'?: string;
    'CDISC Synonym(s)'?: Array<string>;
    'bundle-2'?: string;
}
export interface ExportQrsCsvItemsRow {
    'QRS Measure Name'?: string;
    'QRS Measure Label'?: string;
    'QRS Measure Type'?: string;
    'Item Sequence'?: string;
    'Test Name'?: string;
    'Item Text'?: string;
    'Test&#39;s Codelist C-Code'?: string;
    'Test&#39;s Term C-Code'?: string;
    'Test Code&#39;s Codelist C-Code'?: string;
    'Test Code&#39;s Term C-Code'?: string;
    'Subcategory&#39;s Codelist C-Code'?: string;
    'Subcategory&#39;s Term C-Code'?: string;
    'Evaluator&#39;s Codelist C-Code'?: string;
    'Evaluator&#39;s Term C-Code'?: string;
    'Free-form Response&#39;s Datatype'?: string;
    'Response Group'?: string;
}
export interface ExportQrsGeneral {
    'Name'?: string;
    'Label'?: string;
    'Effective Date'?: string;
    'Description'?: string;
    'Type'?: string;
    'Category&#39;s Codelist C-Code'?: string;
    'Category&#39;s Term C-Code'?: string;
}
export interface ExportQrsItemsTable {
    'items'?: Array<ExportQrsCsvItemsRow>;
}
export interface ExportQrsResponses {
    'Response Group'?: string;
    'Sequence'?: string;
    'Response&#39;s Original Result Codelist C-Code'?: string;
    'Response&#39;s Original Result Term C-Code'?: string;
    'Response&#39;s Original Result Unit Codelist C-Code'?: string;
    'Response&#39;s Original Result Unit Term C-Code'?: string;
    'Response&#39;s Standardized Result Codelist C-Code'?: string;
    'Response&#39;s Standardized Result Term C-Code'?: string;
    'Response&#39;s Standardized Result Unit Codelist C-Code'?: string;
    'Response&#39;s Standardized Result Unit Term C-Code'?: string;
}
export interface ExportQrsWorkbook {
    'self'?: ExportQrsGeneral;
    'items'?: Array<ExportQrsWorkbookItemsRow>;
    'responses'?: Array<ExportQrsResponses>;
}
export interface ExportQrsWorkbookItemsRow {
    'Item Sequence'?: string;
    'Test Name'?: string;
    'Item Text'?: string;
    'Test&#39;s Codelist C-Code'?: string;
    'Test&#39;s Term C-Code'?: string;
    'Test Code&#39;s Codelist C-Code'?: string;
    'Test Code&#39;s Term C-Code'?: string;
    'Subcategory&#39;s Codelist C-Code'?: string;
    'Subcategory&#39;s Term C-Code'?: string;
    'Evaluator&#39;s Codelist C-Code'?: string;
    'Evaluator&#39;s Term C-Code'?: string;
    'Free-form Response&#39;s Datatype'?: string;
    'Response Group'?: string;
}
export interface ExportSdtmClassVariablesRow {
    'Version'?: string;
    'Variable Order'?: string;
    'Class'?: string;
    'Dataset Name'?: string;
    'Variable Name'?: string;
    'Variable Label'?: string;
    'Type'?: string;
    'Controlled Terms, Codelist or Format'?: string;
    'Role'?: string;
    'Role Description'?: string;
    'Description'?: string;
}
export interface ExportSdtmDatasetVariablesRow {
    'Version'?: string;
    'Variable Order'?: string;
    'Class'?: string;
    'Dataset Name'?: string;
    'Variable Name'?: string;
    'Variable Label'?: string;
    'Type'?: string;
    'Controlled Terms, Codelist or Format'?: string;
    'Role'?: string;
    'Role Description'?: string;
    'Description'?: string;
}
export interface ExportSdtmDatasetsRow {
    'Version'?: string;
    'Class'?: string;
    'Dataset Name'?: string;
    'Dataset Label'?: string;
    'Structure'?: string;
}
export interface ExportSdtmDatasetsTable {
    'datasets'?: Array<ExportSdtmDatasetsRow>;
}
export interface ExportSdtmVariablesTable {
    'class-variables'?: Array<ExportSdtmClassVariablesRow>;
    'dataset-variables'?: Array<ExportSdtmDatasetVariablesRow>;
}
export interface ExportSdtmWorkbook {
    'class-variables'?: Array<ExportSdtmClassVariablesRow>;
    'dataset-variables'?: Array<ExportSdtmDatasetVariablesRow>;
    'datasets'?: Array<ExportSdtmDatasetsRow>;
}
export interface ExportSdtmigDatasetsRow {
    'Version'?: string;
    'Class'?: string;
    'Dataset Name'?: string;
    'Dataset Label'?: string;
    'Structure'?: string;
}
export interface ExportSdtmigDatasetsTable {
    'datasets'?: Array<ExportSdtmigDatasetsRow>;
}
export interface ExportSdtmigVariablesRow {
    'Version'?: string;
    'Variable Order'?: string;
    'Class'?: string;
    'Dataset Name'?: string;
    'Variable Name'?: string;
    'Variable Label'?: string;
    'Type'?: string;
    'Controlled Terms, Codelist or Format'?: string;
    'Role'?: string;
    'CDISC Notes'?: string;
    'Core'?: string;
}
export interface ExportSdtmigVariablesTable {
    'variables'?: Array<ExportSdtmigVariablesRow>;
}
export interface ExportSdtmigWorkbook {
    'variables'?: Array<ExportSdtmigVariablesRow>;
    'datasets'?: Array<ExportSdtmigDatasetsRow>;
}
export interface ExportSendigDatasetsRow {
    'Version'?: string;
    'Class'?: string;
    'Dataset Name'?: string;
    'Dataset Label'?: string;
    'Structure'?: string;
}
export interface ExportSendigDatasetsTable {
    'datasets'?: Array<ExportSendigDatasetsRow>;
}
export interface ExportSendigVariablesRow {
    'Version'?: string;
    'Variable Order'?: string;
    'Class'?: string;
    'Dataset Name'?: string;
    'Variable Name'?: string;
    'Variable Label'?: string;
    'Type'?: string;
    'Controlled Terms, Codelist or Format'?: string;
    'Role'?: string;
    'CDISC Notes'?: string;
    'Core'?: string;
}
export interface ExportSendigVariablesTable {
    'variables'?: Array<ExportSendigVariablesRow>;
}
export interface ExportSendigWorkbook {
    'variables'?: Array<ExportSendigVariablesRow>;
    'datasets'?: Array<ExportSendigDatasetsRow>;
}
export interface Health {
    'healthy'?: boolean;
    'ldapAuthenticationHealthy'?: boolean;
    'ldapAuthorizationHealthy'?: boolean;
    'databaseHealthy'?: boolean;
    'esHealthy'?: boolean;
}
export interface Lastupdated {
    '_links'?: LastupdatedLinks;
    'overall'?: string;
    'data-analysis'?: string;
    'data-collection'?: string;
    'data-tabulation'?: string;
    'measure'?: string;
    'terminology'?: string;
}
export interface LastupdatedLinks {
    'self'?: LastupdatedRef;
}
export interface LastupdatedRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface MaintenanceBody {
    'maintenanceMode'?: boolean;
    'maintenanceMessage'?: string;
}
export interface MdrSearchScopesGet200Response {
    'scopes'?: Array<DefaultSearchScopes>;
}
export interface ProductgroupDataAnalysis {
    '_links'?: ProductgroupDataAnalysisLinks;
}
export interface ProductgroupDataAnalysisLinks {
    'self'?: ProductgroupRef;
    'adam'?: Array<AdamProductRefElement>;
}
export interface ProductgroupDataCollection {
    '_links'?: ProductgroupDataCollectionLinks;
}
export interface ProductgroupDataCollectionLinks {
    'self'?: ProductgroupRef;
    'cdash'?: Array<CdashProductRefElement>;
    'cdashig'?: Array<CdashigProductRefElement>;
}
export interface ProductgroupDataTabulation {
    '_links'?: ProductgroupDataTabulationLinks;
}
export interface ProductgroupDataTabulationLinks {
    'self'?: ProductgroupRef;
    'sdtm'?: Array<SdtmProductRefElement>;
    'sdtmig'?: Array<SdtmigProductRefElement>;
    'sendig'?: Array<SendigProductRefElement>;
}
export interface ProductgroupQrs {
    '_links'?: ProductgroupQrsLinks;
}
export interface ProductgroupQrsLinks {
    'self'?: ProductgroupRef;
    'qrs'?: Array<QrsRefElement>;
}
export interface ProductgroupRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface ProductgroupTerminology {
    '_links'?: ProductgroupTerminologyLinks;
}
export interface ProductgroupTerminologyLinks {
    'self'?: ProductgroupRef;
    'packages'?: Array<CtPackageRefElement>;
}
export interface Products {
    '_links'?: ProductsLinks;
}
export interface ProductsLinks {
    'self'?: ProductsRef;
    'data-collection'?: ProductgroupDataCollection;
    'data-tabulation'?: ProductgroupDataTabulation;
    'data-analysis'?: ProductgroupDataAnalysis;
    'terminology'?: ProductgroupTerminology;
    'measure'?: ProductgroupQrs;
}
export interface ProductsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface QrsItem {
    'ordinal'?: string;
    'label'?: string;
    'questionText'?: string;
    '_links'?: QrsItemLinks;
}
export interface QrsItemLinks {
    'qrsItemTEST'?: RootCtTermRef;
    'qrsItemTESTCD'?: RootCtTermRef;
    'qrsItemEVAL'?: RootCtTermRef;
    'qrsItemSCAT'?: RootCtTermRef;
    'responsegroup'?: QrsResponsegroup;
}
export interface QrsItemRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface QrsItems {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'effectiveDate'?: string;
    'untilDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    'qrsType'?: string;
    '_links'?: QrsItemsLinks;
}
export interface QrsItemsLinks {
    'self'?: QrsItemsRef;
    'parentProduct'?: QrsProductRef;
    'items'?: Array<QrsItemRefElement>;
}
export interface QrsItemsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface QrsProduct {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'effectiveDate'?: string;
    'untilDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    'qrsType'?: string;
    '_links'?: QrsProductLinks;
    'items'?: Array<QrsItem>;
}
export interface QrsProductLinks {
    'self'?: QrsProductRef;
    'priorVersion'?: QrsProductRef;
    'qrsTermCAT'?: RootCtTermRef;
    'qrsItems'?: QrsItemsRef;
}
export interface QrsProductRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface QrsRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface QrsResponseLinks {
    'qrsResponseORRES'?: RootCtTermRef;
    'qrsResponseORRESU'?: RootCtTermRef;
    'qrsResponseSTRESC'?: RootCtTermRef;
    'qrsResponseSTRESCU'?: RootCtTermRef;
}
export interface QrsResponsegroup {
    'label'?: string;
    '_links'?: QrsResponsegroupLinks;
}
export interface QrsResponsegroupLinks {
    'self'?: QrsResponsegroupRef;
    'responses'?: Array<QrsResponses>;
}
export interface QrsResponsegroupRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface QrsResponsegroupRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface QrsResponsegroups {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'effectiveDate'?: string;
    'untilDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    'qrsType'?: string;
    '_links'?: QrsResponsegroupsLinks;
}
export interface QrsResponsegroupsLinks {
    'self'?: QrsResponsegroupsRef;
    'responsegroups'?: Array<QrsResponsegroupRefElement>;
}
export interface QrsResponsegroupsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface QrsResponses {
    'ordinal'?: string;
    '_links'?: QrsResponseLinks;
}
export interface RootCdashClassField {
    '_links'?: RootCdashClassFieldLinks;
}
export interface RootCdashClassFieldLinks {
    'self'?: RootCdashClassFieldRef;
    'versions'?: Array<CdashClassFieldRefVersion>;
}
export interface RootCdashClassFieldRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface RootCdashDomainField {
    '_links'?: RootCdashDomainFieldLinks;
}
export interface RootCdashDomainFieldLinks {
    'self'?: RootCdashDomainFieldRef;
    'versions'?: Array<CdashDomainFieldRefVersion>;
}
export interface RootCdashDomainFieldRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface RootCdashigDomainField {
    '_links'?: RootCdashigDomainFieldLinks;
}
export interface RootCdashigDomainFieldLinks {
    'self'?: RootCdashigDomainFieldRef;
    'versions'?: Array<CdashigDomainFieldRefVersion>;
}
export interface RootCdashigDomainFieldRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface RootCdashigScenarioField {
    '_links'?: RootCdashigScenarioFieldLinks;
}
export interface RootCdashigScenarioFieldLinks {
    'self'?: RootCdashigScenarioFieldRef;
    'versions'?: Array<CdashigScenarioFieldRefVersion>;
}
export interface RootCdashigScenarioFieldRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface RootCtCodelist {
    '_links'?: RootCtCodelistLinks;
}
export interface RootCtCodelistLinks {
    'self'?: RootCtCodelistRef;
    'versions'?: Array<CtCodelistRefVersion>;
}
export interface RootCtCodelistRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface RootCtCodelistRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface RootCtTerm {
    '_links'?: RootCtTermLinks;
}
export interface RootCtTermLinks {
    'self'?: RootCtTermRef;
    'versions'?: Array<CtTermRefVersion>;
}
export interface RootCtTermRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface RootSdtmClassVariable {
    '_links'?: RootSdtmClassVariableLinks;
}
export interface RootSdtmClassVariableLinks {
    'self'?: RootSdtmClassVariableRef;
    'versions'?: Array<SdtmClassVariableRefVersion>;
}
export interface RootSdtmClassVariableRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface RootSdtmDatasetVariable {
    '_links'?: RootSdtmDatasetVariableLinks;
}
export interface RootSdtmDatasetVariableLinks {
    'self'?: RootSdtmDatasetVariableRef;
    'versions'?: Array<SdtmDatasetVariableRefVersion>;
}
export interface RootSdtmDatasetVariableRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface RootSdtmigDatasetVariable {
    '_links'?: RootSdtmigDatasetVariableLinks;
}
export interface RootSdtmigDatasetVariableLinks {
    'self'?: RootSdtmigDatasetVariableRef;
    'versions'?: Array<SdtmigDatasetVariableRefVersion>;
}
export interface RootSdtmigDatasetVariableRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface RootSendigDatasetVariable {
    '_links'?: RootSendigDatasetVariableLinks;
}
export interface RootSendigDatasetVariableLinks {
    'self'?: RootSendigDatasetVariableRef;
    'versions'?: Array<SendigDatasetVariableRefVersion>;
}
export interface RootSendigDatasetVariableRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface ScopeValues {
    'total'?: number;
    'hasMore'?: boolean;
    'values'?: Array<string>;
}
export interface SdtmClass {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    '_links'?: SdtmClassLinks;
    'classVariables'?: Array<SdtmClassVariable>;
    'datasets'?: Array<SdtmDataset>;
}
export interface SdtmClassDatasets {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    '_links'?: SdtmClassDatasetsLinks;
}
export interface SdtmClassDatasetsLinks {
    'self'?: SdtmClassDatasetsRef;
    'parentProduct'?: SdtmProductRef;
    'priorVersion'?: SdtmClassDatasetsRef;
    'datasets'?: Array<SdtmDatasetRefElement>;
}
export interface SdtmClassDatasetsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmClassLinks {
    'self'?: SdtmClassRef;
    'parentProduct'?: SdtmProductRef;
    'parentClass'?: SdtmClassRef;
    'subclasses'?: Array<SdtmClassRefSubclass>;
    'priorVersion'?: SdtmClassRef;
}
export interface SdtmClassRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmClassRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmClassRefSubclass {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmClassVariable {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'role'?: string;
    'roleDescription'?: string;
    'simpleDatatype'?: string;
    'describedValueDomain'?: string;
    '_links'?: SdtmClassVariableLinks;
}
export interface SdtmClassVariableLinks {
    'self'?: SdtmClassVariableRef;
    'parentProduct'?: SdtmProductRef;
    'parentClass'?: SdtmClassRef;
    'qualifiesVariables'?: Array<SdtmClassVariableRefQualifies>;
    'rootItem'?: RootSdtmClassVariableRef;
    'priorVersion'?: SdtmClassVariableRef;
}
export interface SdtmClassVariableRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmClassVariableRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmClassVariableRefQualifies {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmClassVariableRefTarget {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmClassVariableRefVersion {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmClassVariables {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    '_links'?: SdtmClassVariablesLinks;
}
export interface SdtmClassVariablesLinks {
    'self'?: SdtmClassVariablesRef;
    'parentProduct'?: SdtmProductRef;
    'priorVersion'?: SdtmClassVariablesRef;
    'classVariables'?: Array<SdtmClassVariableRefElement>;
}
export interface SdtmClassVariablesRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmClasses {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: SdtmClassesLinks;
}
export interface SdtmClassesLinks {
    'self'?: SdtmClassesRef;
    'priorVersion'?: SdtmClassesRef;
    'classes'?: Array<SdtmClassRefElement>;
}
export interface SdtmClassesRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmDataset {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'datasetStructure'?: string;
    '_links'?: SdtmDatasetLinks;
    'datasetVariables'?: Array<SdtmDatasetVariable>;
}
export interface SdtmDatasetLinks {
    'self'?: SdtmDatasetRef;
    'parentProduct'?: SdtmProductRef;
    'parentClass'?: SdtmClassRef;
    'priorVersion'?: SdtmDatasetRef;
}
export interface SdtmDatasetRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmDatasetRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmDatasetVariable {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'role'?: string;
    'roleDescription'?: string;
    'simpleDatatype'?: string;
    'describedValueDomain'?: string;
    '_links'?: SdtmDatasetVariableLinks;
}
export interface SdtmDatasetVariableLinks {
    'self'?: SdtmDatasetVariableRef;
    'parentProduct'?: SdtmProductRef;
    'parentDataset'?: SdtmDatasetRef;
    'rootItem'?: RootSdtmDatasetVariableRef;
    'priorVersion'?: SdtmDatasetVariableRef;
}
export interface SdtmDatasetVariableRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmDatasetVariableRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmDatasetVariableRefTarget {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmDatasetVariableRefVersion {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmDatasetVariables {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'datasetStructure'?: string;
    '_links'?: SdtmDatasetVariablesLinks;
}
export interface SdtmDatasetVariablesLinks {
    'self'?: SdtmDatasetVariablesRef;
    'parentProduct'?: SdtmProductRef;
    'parentClass'?: SdtmClassRef;
    'priorVersion'?: SdtmDatasetVariablesRef;
    'datasetVariables'?: Array<SdtmDatasetVariableRefElement>;
}
export interface SdtmDatasetVariablesRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmDatasets {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: SdtmDatasetsLinks;
}
export interface SdtmDatasetsLinks {
    'self'?: SdtmDatasetsRef;
    'parentProduct'?: SdtmProductRef;
    'priorVersion'?: SdtmDatasetsRef;
    'datasets'?: Array<SdtmDatasetRefElement>;
}
export interface SdtmDatasetsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmProduct {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: SdtmProductLinks;
    'classes'?: Array<SdtmClass>;
    'datasets'?: Array<SdtmDataset>;
}
export interface SdtmProductLinks {
    'self'?: SdtmProductRef;
    'priorVersion'?: SdtmProductRef;
}
export interface SdtmProductRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmProductRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmigClass {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    '_links'?: SdtmigClassLinks;
    'datasets'?: Array<SdtmigDataset>;
}
export interface SdtmigClassDatasets {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    '_links'?: SdtmigClassDatasetsLinks;
}
export interface SdtmigClassDatasetsLinks {
    'self'?: SdtmigClassDatasetsRef;
    'parentProduct'?: SdtmigProductRef;
    'priorVersion'?: SdtmigClassDatasetsRef;
    'datasets'?: Array<SdtmigDatasetRefElement>;
}
export interface SdtmigClassDatasetsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmigClassLinks {
    'self'?: SdtmigClassRef;
    'modelClass'?: SdtmClassRef;
    'parentProduct'?: SdtmigProductRef;
    'parentClass'?: SdtmigClassRef;
    'subclasses'?: Array<SdtmigClassRefSubclass>;
    'priorVersion'?: SdtmigClassRef;
}
export interface SdtmigClassRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmigClassRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmigClassRefSubclass {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmigClasses {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: SdtmigClassesLinks;
}
export interface SdtmigClassesLinks {
    'self'?: SdtmigClassesRef;
    'priorVersion'?: SdtmigClassesRef;
    'classes'?: Array<SdtmigClassRefElement>;
}
export interface SdtmigClassesRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmigDataset {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'datasetStructure'?: string;
    '_links'?: SdtmigDatasetLinks;
    'datasetVariables'?: Array<SdtmigDatasetVariable>;
}
export interface SdtmigDatasetLinks {
    'self'?: SdtmigDatasetRef;
    'modelDataset'?: SdtmDatasetRef;
    'parentProduct'?: SdtmigProductRef;
    'parentClass'?: SdtmigClassRef;
    'priorVersion'?: SdtmigDatasetRef;
}
export interface SdtmigDatasetRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmigDatasetRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmigDatasetVariable {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'role'?: string;
    'simpleDatatype'?: string;
    'core'?: string;
    'describedValueDomain'?: string;
    'valueList'?: Array<string>;
    '_links'?: SdtmigDatasetVariableLinks;
}
export interface SdtmigDatasetVariableLinks {
    'self'?: SdtmigDatasetVariableRef;
    'codelist'?: Array<RootCtCodelistRefElement>;
    'modelClassVariable'?: SdtmClassVariableRef;
    'modelDatasetVariable'?: SdtmDatasetVariableRef;
    'parentProduct'?: SdtmigProductRef;
    'parentDataset'?: SdtmigDatasetRef;
    'rootItem'?: RootSdtmigDatasetVariableRef;
    'priorVersion'?: SdtmigDatasetVariableRef;
}
export interface SdtmigDatasetVariableRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmigDatasetVariableRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmigDatasetVariableRefTarget {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmigDatasetVariableRefVersion {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmigDatasetVariables {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'datasetStructure'?: string;
    '_links'?: SdtmigDatasetVariablesLinks;
}
export interface SdtmigDatasetVariablesLinks {
    'self'?: SdtmigDatasetVariablesRef;
    'modelDataset'?: SdtmDatasetRef;
    'parentProduct'?: SdtmigProductRef;
    'parentClass'?: SdtmigClassRef;
    'priorVersion'?: SdtmigDatasetVariablesRef;
    'datasetVariables'?: Array<SdtmigDatasetVariableRefElement>;
}
export interface SdtmigDatasetVariablesRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmigDatasets {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: SdtmigDatasetsLinks;
}
export interface SdtmigDatasetsLinks {
    'self'?: SdtmigDatasetsRef;
    'parentProduct'?: SdtmigProductRef;
    'priorVersion'?: SdtmigDatasetsRef;
    'datasets'?: Array<SdtmigDatasetRefElement>;
}
export interface SdtmigDatasetsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmigProduct {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: SdtmigProductLinks;
    'classes'?: Array<SdtmigClass>;
}
export interface SdtmigProductLinks {
    'self'?: SdtmigProductRef;
    'model'?: SdtmProductRef;
    'priorVersion'?: SdtmigProductRef;
}
export interface SdtmigProductRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SdtmigProductRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SendigClass {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    '_links'?: SendigClassLinks;
    'datasets'?: Array<SendigDataset>;
}
export interface SendigClassDatasets {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    '_links'?: SendigClassDatasetsLinks;
}
export interface SendigClassDatasetsLinks {
    'self'?: SendigClassDatasetsRef;
    'parentProduct'?: SendigProductRef;
    'datasets'?: Array<SendigDatasetRefElement>;
}
export interface SendigClassDatasetsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SendigClassLinks {
    'self'?: SendigClassRef;
    'modelClass'?: SdtmClassRef;
    'parentProduct'?: SendigProductRef;
    'parentClass'?: SendigClassRef;
    'subclasses'?: Array<SendigClassRefSubclass>;
    'priorVersion'?: SendigClassRef;
}
export interface SendigClassRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SendigClassRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SendigClassRefSubclass {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SendigClasses {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: SendigClassesLinks;
}
export interface SendigClassesLinks {
    'self'?: SendigClassesRef;
    'priorVersion'?: SendigClassesRef;
    'classes'?: Array<SendigClassRefElement>;
}
export interface SendigClassesRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SendigDataset {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'datasetStructure'?: string;
    '_links'?: SendigDatasetLinks;
    'datasetVariables'?: Array<SendigDatasetVariable>;
}
export interface SendigDatasetLinks {
    'self'?: SendigDatasetRef;
    'modelDataset'?: SdtmDatasetRef;
    'parentProduct'?: SendigProductRef;
    'parentClass'?: SendigClassRef;
    'priorVersion'?: SendigDatasetRef;
}
export interface SendigDatasetRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SendigDatasetRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SendigDatasetVariable {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'role'?: string;
    'simpleDatatype'?: string;
    'core'?: string;
    'describedValueDomain'?: string;
    'valueList'?: Array<string>;
    '_links'?: SendigDatasetVariableLinks;
}
export interface SendigDatasetVariableLinks {
    'self'?: SendigDatasetVariableRef;
    'codelist'?: Array<RootCtCodelistRefElement>;
    'modelClassVariable'?: SdtmClassVariableRef;
    'modelDatasetVariable'?: SdtmDatasetVariableRef;
    'parentProduct'?: SendigProductRef;
    'parentDataset'?: SendigDatasetRef;
    'rootItem'?: RootSendigDatasetVariableRef;
    'priorVersion'?: SendigDatasetVariableRef;
}
export interface SendigDatasetVariableRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SendigDatasetVariableRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SendigDatasetVariableRefVersion {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SendigDatasetVariables {
    'ordinal'?: string;
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'datasetStructure'?: string;
    '_links'?: SendigDatasetVariablesLinks;
}
export interface SendigDatasetVariablesLinks {
    'self'?: SendigDatasetVariablesRef;
    'modelDataset'?: SdtmDatasetRef;
    'parentProduct'?: SendigProductRef;
    'parentClass'?: SendigClassRef;
    'priorVersion'?: SendigDatasetVariablesRef;
    'datasetVariables'?: Array<SendigDatasetVariableRefElement>;
}
export interface SendigDatasetVariablesRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SendigDatasets {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: SendigDatasetsLinks;
}
export interface SendigDatasetsLinks {
    'self'?: SendigDatasetsRef;
    'parentProduct'?: SendigProductRef;
    'datasets'?: Array<SendigDatasetRefElement>;
}
export interface SendigDatasetsRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SendigProduct {
    'name'?: string;
    'label'?: string;
    'description'?: string;
    'source'?: string;
    'effectiveDate'?: string;
    'registrationStatus'?: string;
    'version'?: string;
    '_links'?: SendigProductLinks;
    'classes'?: Array<SendigClass>;
}
export interface SendigProductLinks {
    'self'?: SendigProductRef;
    'model'?: SdtmProductRef;
    'priorVersion'?: SendigProductRef;
}
export interface SendigProductRef {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface SendigProductRefElement {
    'href'?: string;
    'title'?: string;
    'type'?: string;
}
export interface XmlAbout {
    'self'?: About;
}
export interface XmlAdamDatastructure {
    'self'?: AdamDatastructure;
}
export interface XmlAdamDatastructureVariables {
    'self'?: AdamDatastructureVariables;
}
export interface XmlAdamDatastructureVarsets {
    'self'?: AdamDatastructureVarsets;
}
export interface XmlAdamProduct {
    'self'?: AdamProduct;
}
export interface XmlAdamProductDatastructures {
    'self'?: AdamProductDatastructures;
}
export interface XmlAdamVariable {
    'self'?: AdamVariable;
}
export interface XmlAdamVarset {
    'self'?: AdamVarset;
}
export interface XmlCdashClass {
    'self'?: CdashClass;
}
export interface XmlCdashClassDomains {
    'self'?: CdashClassDomains;
}
export interface XmlCdashClassField {
    'self'?: CdashClassField;
}
export interface XmlCdashDomain {
    'self'?: CdashDomain;
}
export interface XmlCdashDomainField {
    'self'?: CdashDomainField;
}
export interface XmlCdashDomainFields {
    'self'?: CdashDomainFields;
}
export interface XmlCdashProduct {
    'self'?: CdashProduct;
}
export interface XmlCdashProductClasses {
    'self'?: CdashProductClasses;
}
export interface XmlCdashProductDomains {
    'self'?: CdashProductDomains;
}
export interface XmlCdashigClass {
    'self'?: CdashigClass;
}
export interface XmlCdashigClassDomains {
    'self'?: CdashigClassDomains;
}
export interface XmlCdashigClassScenarios {
    'self'?: CdashigClassScenarios;
}
export interface XmlCdashigDomain {
    'self'?: CdashigDomain;
}
export interface XmlCdashigDomainField {
    'self'?: CdashigDomainField;
}
export interface XmlCdashigDomainFields {
    'self'?: CdashigDomainFields;
}
export interface XmlCdashigProduct {
    'self'?: CdashigProduct;
}
export interface XmlCdashigProductClasses {
    'self'?: CdashigProductClasses;
}
export interface XmlCdashigProductDomains {
    'self'?: CdashigProductDomains;
}
export interface XmlCdashigProductScenarios {
    'self'?: CdashigProductScenarios;
}
export interface XmlCdashigScenario {
    'self'?: CdashigScenario;
}
export interface XmlCdashigScenarioField {
    'self'?: CdashigScenarioField;
}
export interface XmlCdashigScenarioFields {
    'self'?: CdashigScenarioFields;
}
export interface XmlCtCodelist {
    'self'?: CtCodelist;
}
export interface XmlCtCodelistTerms {
    'self'?: CtCodelistTerms;
}
export interface XmlCtPackage {
    'self'?: CtPackage;
}
export interface XmlCtPackageCodelists {
    'self'?: CtPackageCodelists;
}
export interface XmlCtPackages {
    'self'?: CtPackages;
}
export interface XmlCtTerm {
    'self'?: CtTerm;
}
export interface XmlLastupdated {
    'self'?: Lastupdated;
}
export interface XmlProductgroupDataAnalysis {
    'self'?: ProductgroupDataAnalysis;
}
export interface XmlProductgroupDataCollection {
    'self'?: ProductgroupDataCollection;
}
export interface XmlProductgroupDataTabulation {
    'self'?: ProductgroupDataTabulation;
}
export interface XmlProductgroupTerminology {
    'self'?: ProductgroupTerminology;
}
export interface XmlProducts {
    'self'?: Products;
}
export interface XmlQrsItem {
    'self'?: QrsItem;
}
export interface XmlQrsItems {
    'self'?: QrsItems;
}
export interface XmlQrsProduct {
    'self'?: QrsProduct;
}
export interface XmlQrsResponsegroup {
    'self'?: QrsResponsegroup;
}
export interface XmlQrsResponsegroups {
    'self'?: QrsResponsegroups;
}
export interface XmlRootCdashClassField {
    'self'?: RootCdashClassField;
}
export interface XmlRootCdashDomainField {
    'self'?: RootCdashDomainField;
}
export interface XmlRootCdashigDomainField {
    'self'?: RootCdashigDomainField;
}
export interface XmlRootCdashigScenarioField {
    'self'?: RootCdashigScenarioField;
}
export interface XmlRootCtCodelist {
    'self'?: RootCtCodelist;
}
export interface XmlRootCtTerm {
    'self'?: RootCtTerm;
}
export interface XmlRootSdtmClassVariable {
    'self'?: RootSdtmClassVariable;
}
export interface XmlRootSdtmDatasetVariable {
    'self'?: RootSdtmDatasetVariable;
}
export interface XmlRootSdtmigDatasetVariable {
    'self'?: RootSdtmigDatasetVariable;
}
export interface XmlRootSendigDatasetVariable {
    'self'?: RootSendigDatasetVariable;
}
export interface XmlSdtmClass {
    'self'?: SdtmClass;
}
export interface XmlSdtmClassDatasets {
    'self'?: SdtmClassDatasets;
}
export interface XmlSdtmClassVariable {
    'self'?: SdtmClassVariable;
}
export interface XmlSdtmClassVariables {
    'self'?: SdtmClassVariables;
}
export interface XmlSdtmClasses {
    'self'?: SdtmClasses;
}
export interface XmlSdtmDataset {
    'self'?: SdtmDataset;
}
export interface XmlSdtmDatasetVariable {
    'self'?: SdtmDatasetVariable;
}
export interface XmlSdtmDatasetVariables {
    'self'?: SdtmDatasetVariables;
}
export interface XmlSdtmDatasets {
    'self'?: SdtmDatasets;
}
export interface XmlSdtmProduct {
    'self'?: SdtmProduct;
}
export interface XmlSdtmigClass {
    'self'?: SdtmigClass;
}
export interface XmlSdtmigClassDatasets {
    'self'?: SdtmigClassDatasets;
}
export interface XmlSdtmigClasses {
    'self'?: SdtmigClasses;
}
export interface XmlSdtmigDataset {
    'self'?: SdtmigDataset;
}
export interface XmlSdtmigDatasetVariable {
    'self'?: SdtmigDatasetVariable;
}
export interface XmlSdtmigDatasetVariables {
    'self'?: SdtmigDatasetVariables;
}
export interface XmlSdtmigDatasets {
    'self'?: SdtmigDatasets;
}
export interface XmlSdtmigProduct {
    'self'?: SdtmigProduct;
}
export interface XmlSendigClass {
    'self'?: SendigClass;
}
export interface XmlSendigClassDatasets {
    'self'?: SendigClassDatasets;
}
export interface XmlSendigClasses {
    'self'?: SendigClasses;
}
export interface XmlSendigDataset {
    'self'?: SendigDataset;
}
export interface XmlSendigDatasetVariable {
    'self'?: SendigDatasetVariable;
}
export interface XmlSendigDatasetVariables {
    'self'?: SendigDatasetVariables;
}
export interface XmlSendigDatasets {
    'self'?: SendigDatasets;
}
export interface XmlSendigProduct {
    'self'?: SendigProduct;
}

/**
 * AnalysisDataModelAndImplementationGuideADaMAndADaMIGApi - axios parameter creator
 */
export const AnalysisDataModelAndImplementationGuideADaMAndADaMIGApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get ADaM Data Structure List
         * @param {string} product CDISC Library Product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAdamProductDatastructuresGet: async (product: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('mdrAdamProductDatastructuresGet', 'product', product)
            const localVarPath = `/mdr/adam/{product}/datastructures`
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get ADaM Data Structure
         * @param {string} product CDISC Library Product
         * @param {string} structure Data structure Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAdamProductDatastructuresStructureGet: async (product: string, structure: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('mdrAdamProductDatastructuresStructureGet', 'product', product)
            // verify required parameter 'structure' is not null or undefined
            assertParamExists('mdrAdamProductDatastructuresStructureGet', 'structure', structure)
            const localVarPath = `/mdr/adam/{product}/datastructures/{structure}`
                .replace(`{${"product"}}`, encodeURIComponent(String(product)))
                .replace(`{${"structure"}}`, encodeURIComponent(String(structure)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get ADaM Variable List
         * @param {string} product CDISC Library Product
         * @param {string} structure ADaM Data Structure Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAdamProductDatastructuresStructureVariablesGet: async (product: string, structure: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('mdrAdamProductDatastructuresStructureVariablesGet', 'product', product)
            // verify required parameter 'structure' is not null or undefined
            assertParamExists('mdrAdamProductDatastructuresStructureVariablesGet', 'structure', structure)
            const localVarPath = `/mdr/adam/{product}/datastructures/{structure}/variables`
                .replace(`{${"product"}}`, encodeURIComponent(String(product)))
                .replace(`{${"structure"}}`, encodeURIComponent(String(structure)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get ADaM Variable
         * @param {string} product CDISC Library Product
         * @param {string} structure ADaM Data Structure Identifier
         * @param {string} _var ADaM Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAdamProductDatastructuresStructureVariablesVarGet: async (product: string, structure: string, _var: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('mdrAdamProductDatastructuresStructureVariablesVarGet', 'product', product)
            // verify required parameter 'structure' is not null or undefined
            assertParamExists('mdrAdamProductDatastructuresStructureVariablesVarGet', 'structure', structure)
            // verify required parameter '_var' is not null or undefined
            assertParamExists('mdrAdamProductDatastructuresStructureVariablesVarGet', '_var', _var)
            const localVarPath = `/mdr/adam/{product}/datastructures/{structure}/variables/{var}`
                .replace(`{${"product"}}`, encodeURIComponent(String(product)))
                .replace(`{${"structure"}}`, encodeURIComponent(String(structure)))
                .replace(`{${"var"}}`, encodeURIComponent(String(_var)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get ADaM Variable Set List
         * @param {string} product CDISC Library Product
         * @param {string} structure ADaM Data Structure Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAdamProductDatastructuresStructureVarsetsGet: async (product: string, structure: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('mdrAdamProductDatastructuresStructureVarsetsGet', 'product', product)
            // verify required parameter 'structure' is not null or undefined
            assertParamExists('mdrAdamProductDatastructuresStructureVarsetsGet', 'structure', structure)
            const localVarPath = `/mdr/adam/{product}/datastructures/{structure}/varsets`
                .replace(`{${"product"}}`, encodeURIComponent(String(product)))
                .replace(`{${"structure"}}`, encodeURIComponent(String(structure)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get ADaM Variable Set
         * @param {string} product CDISC Library Product
         * @param {string} structure ADaM Data Structure Identifier
         * @param {string} varset ADaM Variable Set Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAdamProductDatastructuresStructureVarsetsVarsetGet: async (product: string, structure: string, varset: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('mdrAdamProductDatastructuresStructureVarsetsVarsetGet', 'product', product)
            // verify required parameter 'structure' is not null or undefined
            assertParamExists('mdrAdamProductDatastructuresStructureVarsetsVarsetGet', 'structure', structure)
            // verify required parameter 'varset' is not null or undefined
            assertParamExists('mdrAdamProductDatastructuresStructureVarsetsVarsetGet', 'varset', varset)
            const localVarPath = `/mdr/adam/{product}/datastructures/{structure}/varsets/{varset}`
                .replace(`{${"product"}}`, encodeURIComponent(String(product)))
                .replace(`{${"structure"}}`, encodeURIComponent(String(structure)))
                .replace(`{${"varset"}}`, encodeURIComponent(String(varset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get ADaM Product
         * @param {string} product CDISC Library Product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAdamProductGet: async (product: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('mdrAdamProductGet', 'product', product)
            const localVarPath = `/mdr/adam/{product}`
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalysisDataModelAndImplementationGuideADaMAndADaMIGApi - functional programming interface
 */
export const AnalysisDataModelAndImplementationGuideADaMAndADaMIGApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalysisDataModelAndImplementationGuideADaMAndADaMIGApiAxiosParamCreator(configuration)
    return {
        /**
         * Get ADaM Data Structure List
         * @param {string} product CDISC Library Product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrAdamProductDatastructuresGet(product: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdamProductDatastructures>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrAdamProductDatastructuresGet(product, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysisDataModelAndImplementationGuideADaMAndADaMIGApi.mdrAdamProductDatastructuresGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get ADaM Data Structure
         * @param {string} product CDISC Library Product
         * @param {string} structure Data structure Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrAdamProductDatastructuresStructureGet(product: string, structure: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdamDatastructure>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrAdamProductDatastructuresStructureGet(product, structure, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysisDataModelAndImplementationGuideADaMAndADaMIGApi.mdrAdamProductDatastructuresStructureGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get ADaM Variable List
         * @param {string} product CDISC Library Product
         * @param {string} structure ADaM Data Structure Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrAdamProductDatastructuresStructureVariablesGet(product: string, structure: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdamDatastructureVariables>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrAdamProductDatastructuresStructureVariablesGet(product, structure, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysisDataModelAndImplementationGuideADaMAndADaMIGApi.mdrAdamProductDatastructuresStructureVariablesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get ADaM Variable
         * @param {string} product CDISC Library Product
         * @param {string} structure ADaM Data Structure Identifier
         * @param {string} _var ADaM Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrAdamProductDatastructuresStructureVariablesVarGet(product: string, structure: string, _var: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdamVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrAdamProductDatastructuresStructureVariablesVarGet(product, structure, _var, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysisDataModelAndImplementationGuideADaMAndADaMIGApi.mdrAdamProductDatastructuresStructureVariablesVarGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get ADaM Variable Set List
         * @param {string} product CDISC Library Product
         * @param {string} structure ADaM Data Structure Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrAdamProductDatastructuresStructureVarsetsGet(product: string, structure: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdamDatastructureVarsets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrAdamProductDatastructuresStructureVarsetsGet(product, structure, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysisDataModelAndImplementationGuideADaMAndADaMIGApi.mdrAdamProductDatastructuresStructureVarsetsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get ADaM Variable Set
         * @param {string} product CDISC Library Product
         * @param {string} structure ADaM Data Structure Identifier
         * @param {string} varset ADaM Variable Set Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrAdamProductDatastructuresStructureVarsetsVarsetGet(product: string, structure: string, varset: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdamVarset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrAdamProductDatastructuresStructureVarsetsVarsetGet(product, structure, varset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysisDataModelAndImplementationGuideADaMAndADaMIGApi.mdrAdamProductDatastructuresStructureVarsetsVarsetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get ADaM Product
         * @param {string} product CDISC Library Product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrAdamProductGet(product: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdamProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrAdamProductGet(product, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysisDataModelAndImplementationGuideADaMAndADaMIGApi.mdrAdamProductGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalysisDataModelAndImplementationGuideADaMAndADaMIGApi - factory interface
 */
export const AnalysisDataModelAndImplementationGuideADaMAndADaMIGApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalysisDataModelAndImplementationGuideADaMAndADaMIGApiFp(configuration)
    return {
        /**
         * Get ADaM Data Structure List
         * @param {string} product CDISC Library Product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAdamProductDatastructuresGet(product: string, options?: RawAxiosRequestConfig): AxiosPromise<AdamProductDatastructures> {
            return localVarFp.mdrAdamProductDatastructuresGet(product, options).then((request) => request(axios, basePath));
        },
        /**
         * Get ADaM Data Structure
         * @param {string} product CDISC Library Product
         * @param {string} structure Data structure Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAdamProductDatastructuresStructureGet(product: string, structure: string, options?: RawAxiosRequestConfig): AxiosPromise<AdamDatastructure> {
            return localVarFp.mdrAdamProductDatastructuresStructureGet(product, structure, options).then((request) => request(axios, basePath));
        },
        /**
         * Get ADaM Variable List
         * @param {string} product CDISC Library Product
         * @param {string} structure ADaM Data Structure Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAdamProductDatastructuresStructureVariablesGet(product: string, structure: string, options?: RawAxiosRequestConfig): AxiosPromise<AdamDatastructureVariables> {
            return localVarFp.mdrAdamProductDatastructuresStructureVariablesGet(product, structure, options).then((request) => request(axios, basePath));
        },
        /**
         * Get ADaM Variable
         * @param {string} product CDISC Library Product
         * @param {string} structure ADaM Data Structure Identifier
         * @param {string} _var ADaM Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAdamProductDatastructuresStructureVariablesVarGet(product: string, structure: string, _var: string, options?: RawAxiosRequestConfig): AxiosPromise<AdamVariable> {
            return localVarFp.mdrAdamProductDatastructuresStructureVariablesVarGet(product, structure, _var, options).then((request) => request(axios, basePath));
        },
        /**
         * Get ADaM Variable Set List
         * @param {string} product CDISC Library Product
         * @param {string} structure ADaM Data Structure Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAdamProductDatastructuresStructureVarsetsGet(product: string, structure: string, options?: RawAxiosRequestConfig): AxiosPromise<AdamDatastructureVarsets> {
            return localVarFp.mdrAdamProductDatastructuresStructureVarsetsGet(product, structure, options).then((request) => request(axios, basePath));
        },
        /**
         * Get ADaM Variable Set
         * @param {string} product CDISC Library Product
         * @param {string} structure ADaM Data Structure Identifier
         * @param {string} varset ADaM Variable Set Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAdamProductDatastructuresStructureVarsetsVarsetGet(product: string, structure: string, varset: string, options?: RawAxiosRequestConfig): AxiosPromise<AdamVarset> {
            return localVarFp.mdrAdamProductDatastructuresStructureVarsetsVarsetGet(product, structure, varset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get ADaM Product
         * @param {string} product CDISC Library Product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAdamProductGet(product: string, options?: RawAxiosRequestConfig): AxiosPromise<AdamProduct> {
            return localVarFp.mdrAdamProductGet(product, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalysisDataModelAndImplementationGuideADaMAndADaMIGApi - object-oriented interface
 */
export class AnalysisDataModelAndImplementationGuideADaMAndADaMIGApi extends BaseAPI {
    /**
     * Get ADaM Data Structure List
     * @param {string} product CDISC Library Product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrAdamProductDatastructuresGet(product: string, options?: RawAxiosRequestConfig) {
        return AnalysisDataModelAndImplementationGuideADaMAndADaMIGApiFp(this.configuration).mdrAdamProductDatastructuresGet(product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get ADaM Data Structure
     * @param {string} product CDISC Library Product
     * @param {string} structure Data structure Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrAdamProductDatastructuresStructureGet(product: string, structure: string, options?: RawAxiosRequestConfig) {
        return AnalysisDataModelAndImplementationGuideADaMAndADaMIGApiFp(this.configuration).mdrAdamProductDatastructuresStructureGet(product, structure, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get ADaM Variable List
     * @param {string} product CDISC Library Product
     * @param {string} structure ADaM Data Structure Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrAdamProductDatastructuresStructureVariablesGet(product: string, structure: string, options?: RawAxiosRequestConfig) {
        return AnalysisDataModelAndImplementationGuideADaMAndADaMIGApiFp(this.configuration).mdrAdamProductDatastructuresStructureVariablesGet(product, structure, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get ADaM Variable
     * @param {string} product CDISC Library Product
     * @param {string} structure ADaM Data Structure Identifier
     * @param {string} _var ADaM Variable Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrAdamProductDatastructuresStructureVariablesVarGet(product: string, structure: string, _var: string, options?: RawAxiosRequestConfig) {
        return AnalysisDataModelAndImplementationGuideADaMAndADaMIGApiFp(this.configuration).mdrAdamProductDatastructuresStructureVariablesVarGet(product, structure, _var, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get ADaM Variable Set List
     * @param {string} product CDISC Library Product
     * @param {string} structure ADaM Data Structure Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrAdamProductDatastructuresStructureVarsetsGet(product: string, structure: string, options?: RawAxiosRequestConfig) {
        return AnalysisDataModelAndImplementationGuideADaMAndADaMIGApiFp(this.configuration).mdrAdamProductDatastructuresStructureVarsetsGet(product, structure, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get ADaM Variable Set
     * @param {string} product CDISC Library Product
     * @param {string} structure ADaM Data Structure Identifier
     * @param {string} varset ADaM Variable Set Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrAdamProductDatastructuresStructureVarsetsVarsetGet(product: string, structure: string, varset: string, options?: RawAxiosRequestConfig) {
        return AnalysisDataModelAndImplementationGuideADaMAndADaMIGApiFp(this.configuration).mdrAdamProductDatastructuresStructureVarsetsVarsetGet(product, structure, varset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get ADaM Product
     * @param {string} product CDISC Library Product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrAdamProductGet(product: string, options?: RawAxiosRequestConfig) {
        return AnalysisDataModelAndImplementationGuideADaMAndADaMIGApiFp(this.configuration).mdrAdamProductGet(product, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CDASHImplementationGuideCDASHIGApi - axios parameter creator
 */
export const CDASHImplementationGuideCDASHIGApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get CDASHIG Class Domain List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASHIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionClassesClassDomainsGet: async (version: string, _class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashigVersionClassesClassDomainsGet', 'version', version)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrCdashigVersionClassesClassDomainsGet', '_class', _class)
            const localVarPath = `/mdr/cdashig/{version}/classes/{class}/domains`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASHIG Class
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASHIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionClassesClassGet: async (version: string, _class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashigVersionClassesClassGet', 'version', version)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrCdashigVersionClassesClassGet', '_class', _class)
            const localVarPath = `/mdr/cdashig/{version}/classes/{class}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASHIG Class Scenario List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASHIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionClassesClassScenariosGet: async (version: string, _class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashigVersionClassesClassScenariosGet', 'version', version)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrCdashigVersionClassesClassScenariosGet', '_class', _class)
            const localVarPath = `/mdr/cdashig/{version}/classes/{class}/scenarios`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASHIG Class List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionClassesGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashigVersionClassesGet', 'version', version)
            const localVarPath = `/mdr/cdashig/{version}/classes`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASHIG Domain Field
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} field CDASHIG Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionDomainsDomainFieldsFieldGet: async (version: string, domain: string, field: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashigVersionDomainsDomainFieldsFieldGet', 'version', version)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('mdrCdashigVersionDomainsDomainFieldsFieldGet', 'domain', domain)
            // verify required parameter 'field' is not null or undefined
            assertParamExists('mdrCdashigVersionDomainsDomainFieldsFieldGet', 'field', field)
            const localVarPath = `/mdr/cdashig/{version}/domains/{domain}/fields/{field}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
                .replace(`{${"field"}}`, encodeURIComponent(String(field)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASHIG Domain Field List
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionDomainsDomainFieldsGet: async (version: string, domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashigVersionDomainsDomainFieldsGet', 'version', version)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('mdrCdashigVersionDomainsDomainFieldsGet', 'domain', domain)
            const localVarPath = `/mdr/cdashig/{version}/domains/{domain}/fields`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASHIG Domain
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionDomainsDomainGet: async (version: string, domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashigVersionDomainsDomainGet', 'version', version)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('mdrCdashigVersionDomainsDomainGet', 'domain', domain)
            const localVarPath = `/mdr/cdashig/{version}/domains/{domain}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASHIG Domain List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionDomainsGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashigVersionDomainsGet', 'version', version)
            const localVarPath = `/mdr/cdashig/{version}/domains`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASHIG Product
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashigVersionGet', 'version', version)
            const localVarPath = `/mdr/cdashig/{version}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASHIG Scenario Field
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} scenario CDASHIG Scenario Identifier
         * @param {string} field CDASHIG Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionScenariosDomainScenarioFieldsFieldGet: async (version: string, domain: string, scenario: string, field: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashigVersionScenariosDomainScenarioFieldsFieldGet', 'version', version)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('mdrCdashigVersionScenariosDomainScenarioFieldsFieldGet', 'domain', domain)
            // verify required parameter 'scenario' is not null or undefined
            assertParamExists('mdrCdashigVersionScenariosDomainScenarioFieldsFieldGet', 'scenario', scenario)
            // verify required parameter 'field' is not null or undefined
            assertParamExists('mdrCdashigVersionScenariosDomainScenarioFieldsFieldGet', 'field', field)
            const localVarPath = `/mdr/cdashig/{version}/scenarios/{domain}.{scenario}/fields/{field}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
                .replace(`{${"scenario"}}`, encodeURIComponent(String(scenario)))
                .replace(`{${"field"}}`, encodeURIComponent(String(field)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASHIG Scenario Field List
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} scenario CDASHIG Scenario Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionScenariosDomainScenarioFieldsGet: async (version: string, domain: string, scenario: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashigVersionScenariosDomainScenarioFieldsGet', 'version', version)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('mdrCdashigVersionScenariosDomainScenarioFieldsGet', 'domain', domain)
            // verify required parameter 'scenario' is not null or undefined
            assertParamExists('mdrCdashigVersionScenariosDomainScenarioFieldsGet', 'scenario', scenario)
            const localVarPath = `/mdr/cdashig/{version}/scenarios/{domain}.{scenario}/fields`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
                .replace(`{${"scenario"}}`, encodeURIComponent(String(scenario)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASHIG Scenario
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} scenario CDASHIG Scenario Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionScenariosDomainScenarioGet: async (version: string, domain: string, scenario: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashigVersionScenariosDomainScenarioGet', 'version', version)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('mdrCdashigVersionScenariosDomainScenarioGet', 'domain', domain)
            // verify required parameter 'scenario' is not null or undefined
            assertParamExists('mdrCdashigVersionScenariosDomainScenarioGet', 'scenario', scenario)
            const localVarPath = `/mdr/cdashig/{version}/scenarios/{domain}.{scenario}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
                .replace(`{${"scenario"}}`, encodeURIComponent(String(scenario)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASHIG Scenario List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionScenariosGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashigVersionScenariosGet', 'version', version)
            const localVarPath = `/mdr/cdashig/{version}/scenarios`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Root CDASHIG Domain Field
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} field CDASHIG Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootCdashigDomainsDomainFieldsFieldGet: async (domain: string, field: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('mdrRootCdashigDomainsDomainFieldsFieldGet', 'domain', domain)
            // verify required parameter 'field' is not null or undefined
            assertParamExists('mdrRootCdashigDomainsDomainFieldsFieldGet', 'field', field)
            const localVarPath = `/mdr/root/cdashig/domains/{domain}/fields/{field}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
                .replace(`{${"field"}}`, encodeURIComponent(String(field)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Root CDASHIG Scenario Field
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} scenario CDASHIG Scenario Identifier
         * @param {string} field CDASHIG Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootCdashigScenariosDomainScenarioFieldsFieldGet: async (domain: string, scenario: string, field: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('mdrRootCdashigScenariosDomainScenarioFieldsFieldGet', 'domain', domain)
            // verify required parameter 'scenario' is not null or undefined
            assertParamExists('mdrRootCdashigScenariosDomainScenarioFieldsFieldGet', 'scenario', scenario)
            // verify required parameter 'field' is not null or undefined
            assertParamExists('mdrRootCdashigScenariosDomainScenarioFieldsFieldGet', 'field', field)
            const localVarPath = `/mdr/root/cdashig/scenarios/{domain}.{scenario}/fields/{field}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
                .replace(`{${"scenario"}}`, encodeURIComponent(String(scenario)))
                .replace(`{${"field"}}`, encodeURIComponent(String(field)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CDASHImplementationGuideCDASHIGApi - functional programming interface
 */
export const CDASHImplementationGuideCDASHIGApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CDASHImplementationGuideCDASHIGApiAxiosParamCreator(configuration)
    return {
        /**
         * Get CDASHIG Class Domain List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASHIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashigVersionClassesClassDomainsGet(version: string, _class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashigClassDomains>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashigVersionClassesClassDomainsGet(version, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDASHImplementationGuideCDASHIGApi.mdrCdashigVersionClassesClassDomainsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASHIG Class
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASHIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashigVersionClassesClassGet(version: string, _class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashigClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashigVersionClassesClassGet(version, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDASHImplementationGuideCDASHIGApi.mdrCdashigVersionClassesClassGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASHIG Class Scenario List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASHIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashigVersionClassesClassScenariosGet(version: string, _class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashigClassScenarios>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashigVersionClassesClassScenariosGet(version, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDASHImplementationGuideCDASHIGApi.mdrCdashigVersionClassesClassScenariosGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASHIG Class List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashigVersionClassesGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashigProductClasses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashigVersionClassesGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDASHImplementationGuideCDASHIGApi.mdrCdashigVersionClassesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASHIG Domain Field
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} field CDASHIG Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashigVersionDomainsDomainFieldsFieldGet(version: string, domain: string, field: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashigDomainField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashigVersionDomainsDomainFieldsFieldGet(version, domain, field, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDASHImplementationGuideCDASHIGApi.mdrCdashigVersionDomainsDomainFieldsFieldGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASHIG Domain Field List
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashigVersionDomainsDomainFieldsGet(version: string, domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashigDomainFields>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashigVersionDomainsDomainFieldsGet(version, domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDASHImplementationGuideCDASHIGApi.mdrCdashigVersionDomainsDomainFieldsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASHIG Domain
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashigVersionDomainsDomainGet(version: string, domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashigDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashigVersionDomainsDomainGet(version, domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDASHImplementationGuideCDASHIGApi.mdrCdashigVersionDomainsDomainGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASHIG Domain List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashigVersionDomainsGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashigProductDomains>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashigVersionDomainsGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDASHImplementationGuideCDASHIGApi.mdrCdashigVersionDomainsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASHIG Product
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashigVersionGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashigProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashigVersionGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDASHImplementationGuideCDASHIGApi.mdrCdashigVersionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASHIG Scenario Field
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} scenario CDASHIG Scenario Identifier
         * @param {string} field CDASHIG Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashigVersionScenariosDomainScenarioFieldsFieldGet(version: string, domain: string, scenario: string, field: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashigScenarioField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashigVersionScenariosDomainScenarioFieldsFieldGet(version, domain, scenario, field, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDASHImplementationGuideCDASHIGApi.mdrCdashigVersionScenariosDomainScenarioFieldsFieldGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASHIG Scenario Field List
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} scenario CDASHIG Scenario Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashigVersionScenariosDomainScenarioFieldsGet(version: string, domain: string, scenario: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashigScenarioFields>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashigVersionScenariosDomainScenarioFieldsGet(version, domain, scenario, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDASHImplementationGuideCDASHIGApi.mdrCdashigVersionScenariosDomainScenarioFieldsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASHIG Scenario
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} scenario CDASHIG Scenario Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashigVersionScenariosDomainScenarioGet(version: string, domain: string, scenario: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashigScenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashigVersionScenariosDomainScenarioGet(version, domain, scenario, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDASHImplementationGuideCDASHIGApi.mdrCdashigVersionScenariosDomainScenarioGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASHIG Scenario List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashigVersionScenariosGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashigProductScenarios>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashigVersionScenariosGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDASHImplementationGuideCDASHIGApi.mdrCdashigVersionScenariosGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Root CDASHIG Domain Field
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} field CDASHIG Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrRootCdashigDomainsDomainFieldsFieldGet(domain: string, field: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootCdashigDomainField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrRootCdashigDomainsDomainFieldsFieldGet(domain, field, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDASHImplementationGuideCDASHIGApi.mdrRootCdashigDomainsDomainFieldsFieldGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Root CDASHIG Scenario Field
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} scenario CDASHIG Scenario Identifier
         * @param {string} field CDASHIG Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrRootCdashigScenariosDomainScenarioFieldsFieldGet(domain: string, scenario: string, field: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootCdashigScenarioField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrRootCdashigScenariosDomainScenarioFieldsFieldGet(domain, scenario, field, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDASHImplementationGuideCDASHIGApi.mdrRootCdashigScenariosDomainScenarioFieldsFieldGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CDASHImplementationGuideCDASHIGApi - factory interface
 */
export const CDASHImplementationGuideCDASHIGApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CDASHImplementationGuideCDASHIGApiFp(configuration)
    return {
        /**
         * Get CDASHIG Class Domain List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASHIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionClassesClassDomainsGet(version: string, _class: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashigClassDomains> {
            return localVarFp.mdrCdashigVersionClassesClassDomainsGet(version, _class, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASHIG Class
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASHIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionClassesClassGet(version: string, _class: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashigClass> {
            return localVarFp.mdrCdashigVersionClassesClassGet(version, _class, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASHIG Class Scenario List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASHIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionClassesClassScenariosGet(version: string, _class: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashigClassScenarios> {
            return localVarFp.mdrCdashigVersionClassesClassScenariosGet(version, _class, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASHIG Class List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionClassesGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashigProductClasses> {
            return localVarFp.mdrCdashigVersionClassesGet(version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASHIG Domain Field
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} field CDASHIG Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionDomainsDomainFieldsFieldGet(version: string, domain: string, field: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashigDomainField> {
            return localVarFp.mdrCdashigVersionDomainsDomainFieldsFieldGet(version, domain, field, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASHIG Domain Field List
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionDomainsDomainFieldsGet(version: string, domain: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashigDomainFields> {
            return localVarFp.mdrCdashigVersionDomainsDomainFieldsGet(version, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASHIG Domain
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionDomainsDomainGet(version: string, domain: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashigDomain> {
            return localVarFp.mdrCdashigVersionDomainsDomainGet(version, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASHIG Domain List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionDomainsGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashigProductDomains> {
            return localVarFp.mdrCdashigVersionDomainsGet(version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASHIG Product
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashigProduct> {
            return localVarFp.mdrCdashigVersionGet(version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASHIG Scenario Field
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} scenario CDASHIG Scenario Identifier
         * @param {string} field CDASHIG Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionScenariosDomainScenarioFieldsFieldGet(version: string, domain: string, scenario: string, field: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashigScenarioField> {
            return localVarFp.mdrCdashigVersionScenariosDomainScenarioFieldsFieldGet(version, domain, scenario, field, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASHIG Scenario Field List
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} scenario CDASHIG Scenario Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionScenariosDomainScenarioFieldsGet(version: string, domain: string, scenario: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashigScenarioFields> {
            return localVarFp.mdrCdashigVersionScenariosDomainScenarioFieldsGet(version, domain, scenario, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASHIG Scenario
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} scenario CDASHIG Scenario Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionScenariosDomainScenarioGet(version: string, domain: string, scenario: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashigScenario> {
            return localVarFp.mdrCdashigVersionScenariosDomainScenarioGet(version, domain, scenario, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASHIG Scenario List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashigVersionScenariosGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashigProductScenarios> {
            return localVarFp.mdrCdashigVersionScenariosGet(version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Root CDASHIG Domain Field
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} field CDASHIG Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootCdashigDomainsDomainFieldsFieldGet(domain: string, field: string, options?: RawAxiosRequestConfig): AxiosPromise<RootCdashigDomainField> {
            return localVarFp.mdrRootCdashigDomainsDomainFieldsFieldGet(domain, field, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Root CDASHIG Scenario Field
         * @param {string} domain CDASHIG Domain Identifier
         * @param {string} scenario CDASHIG Scenario Identifier
         * @param {string} field CDASHIG Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootCdashigScenariosDomainScenarioFieldsFieldGet(domain: string, scenario: string, field: string, options?: RawAxiosRequestConfig): AxiosPromise<RootCdashigScenarioField> {
            return localVarFp.mdrRootCdashigScenariosDomainScenarioFieldsFieldGet(domain, scenario, field, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CDASHImplementationGuideCDASHIGApi - object-oriented interface
 */
export class CDASHImplementationGuideCDASHIGApi extends BaseAPI {
    /**
     * Get CDASHIG Class Domain List
     * @param {string} version CDISC Library Product Version
     * @param {string} _class CDASHIG Class Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashigVersionClassesClassDomainsGet(version: string, _class: string, options?: RawAxiosRequestConfig) {
        return CDASHImplementationGuideCDASHIGApiFp(this.configuration).mdrCdashigVersionClassesClassDomainsGet(version, _class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASHIG Class
     * @param {string} version CDISC Library Product Version
     * @param {string} _class CDASHIG Class Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashigVersionClassesClassGet(version: string, _class: string, options?: RawAxiosRequestConfig) {
        return CDASHImplementationGuideCDASHIGApiFp(this.configuration).mdrCdashigVersionClassesClassGet(version, _class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASHIG Class Scenario List
     * @param {string} version CDISC Library Product Version
     * @param {string} _class CDASHIG Class Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashigVersionClassesClassScenariosGet(version: string, _class: string, options?: RawAxiosRequestConfig) {
        return CDASHImplementationGuideCDASHIGApiFp(this.configuration).mdrCdashigVersionClassesClassScenariosGet(version, _class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASHIG Class List
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashigVersionClassesGet(version: string, options?: RawAxiosRequestConfig) {
        return CDASHImplementationGuideCDASHIGApiFp(this.configuration).mdrCdashigVersionClassesGet(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASHIG Domain Field
     * @param {string} version CDISC Library Product Version
     * @param {string} domain CDASHIG Domain Identifier
     * @param {string} field CDASHIG Field Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashigVersionDomainsDomainFieldsFieldGet(version: string, domain: string, field: string, options?: RawAxiosRequestConfig) {
        return CDASHImplementationGuideCDASHIGApiFp(this.configuration).mdrCdashigVersionDomainsDomainFieldsFieldGet(version, domain, field, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASHIG Domain Field List
     * @param {string} version CDISC Library Product Version
     * @param {string} domain CDASHIG Domain Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashigVersionDomainsDomainFieldsGet(version: string, domain: string, options?: RawAxiosRequestConfig) {
        return CDASHImplementationGuideCDASHIGApiFp(this.configuration).mdrCdashigVersionDomainsDomainFieldsGet(version, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASHIG Domain
     * @param {string} version CDISC Library Product Version
     * @param {string} domain CDASHIG Domain Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashigVersionDomainsDomainGet(version: string, domain: string, options?: RawAxiosRequestConfig) {
        return CDASHImplementationGuideCDASHIGApiFp(this.configuration).mdrCdashigVersionDomainsDomainGet(version, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASHIG Domain List
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashigVersionDomainsGet(version: string, options?: RawAxiosRequestConfig) {
        return CDASHImplementationGuideCDASHIGApiFp(this.configuration).mdrCdashigVersionDomainsGet(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASHIG Product
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashigVersionGet(version: string, options?: RawAxiosRequestConfig) {
        return CDASHImplementationGuideCDASHIGApiFp(this.configuration).mdrCdashigVersionGet(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASHIG Scenario Field
     * @param {string} version CDISC Library Product Version
     * @param {string} domain CDASHIG Domain Identifier
     * @param {string} scenario CDASHIG Scenario Identifier
     * @param {string} field CDASHIG Field Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashigVersionScenariosDomainScenarioFieldsFieldGet(version: string, domain: string, scenario: string, field: string, options?: RawAxiosRequestConfig) {
        return CDASHImplementationGuideCDASHIGApiFp(this.configuration).mdrCdashigVersionScenariosDomainScenarioFieldsFieldGet(version, domain, scenario, field, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASHIG Scenario Field List
     * @param {string} version CDISC Library Product Version
     * @param {string} domain CDASHIG Domain Identifier
     * @param {string} scenario CDASHIG Scenario Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashigVersionScenariosDomainScenarioFieldsGet(version: string, domain: string, scenario: string, options?: RawAxiosRequestConfig) {
        return CDASHImplementationGuideCDASHIGApiFp(this.configuration).mdrCdashigVersionScenariosDomainScenarioFieldsGet(version, domain, scenario, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASHIG Scenario
     * @param {string} version CDISC Library Product Version
     * @param {string} domain CDASHIG Domain Identifier
     * @param {string} scenario CDASHIG Scenario Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashigVersionScenariosDomainScenarioGet(version: string, domain: string, scenario: string, options?: RawAxiosRequestConfig) {
        return CDASHImplementationGuideCDASHIGApiFp(this.configuration).mdrCdashigVersionScenariosDomainScenarioGet(version, domain, scenario, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASHIG Scenario List
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashigVersionScenariosGet(version: string, options?: RawAxiosRequestConfig) {
        return CDASHImplementationGuideCDASHIGApiFp(this.configuration).mdrCdashigVersionScenariosGet(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Root CDASHIG Domain Field
     * @param {string} domain CDASHIG Domain Identifier
     * @param {string} field CDASHIG Field Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrRootCdashigDomainsDomainFieldsFieldGet(domain: string, field: string, options?: RawAxiosRequestConfig) {
        return CDASHImplementationGuideCDASHIGApiFp(this.configuration).mdrRootCdashigDomainsDomainFieldsFieldGet(domain, field, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Root CDASHIG Scenario Field
     * @param {string} domain CDASHIG Domain Identifier
     * @param {string} scenario CDASHIG Scenario Identifier
     * @param {string} field CDASHIG Field Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrRootCdashigScenariosDomainScenarioFieldsFieldGet(domain: string, scenario: string, field: string, options?: RawAxiosRequestConfig) {
        return CDASHImplementationGuideCDASHIGApiFp(this.configuration).mdrRootCdashigScenariosDomainScenarioFieldsFieldGet(domain, scenario, field, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClinicalDataAcquisitionStandardsHarmonizationCDASHApi - axios parameter creator
 */
export const ClinicalDataAcquisitionStandardsHarmonizationCDASHApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get CDASH Class Domain List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASH Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionClassesClassDomainsGet: async (version: string, _class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashVersionClassesClassDomainsGet', 'version', version)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrCdashVersionClassesClassDomainsGet', '_class', _class)
            const localVarPath = `/mdr/cdash/{version}/classes/{class}/domains`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASH Class Field
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASH Class Identifier
         * @param {string} field CDASH Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionClassesClassFieldsFieldGet: async (version: string, _class: string, field: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashVersionClassesClassFieldsFieldGet', 'version', version)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrCdashVersionClassesClassFieldsFieldGet', '_class', _class)
            // verify required parameter 'field' is not null or undefined
            assertParamExists('mdrCdashVersionClassesClassFieldsFieldGet', 'field', field)
            const localVarPath = `/mdr/cdash/{version}/classes/{class}/fields/{field}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"field"}}`, encodeURIComponent(String(field)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASH Class
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASH Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionClassesClassGet: async (version: string, _class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashVersionClassesClassGet', 'version', version)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrCdashVersionClassesClassGet', '_class', _class)
            const localVarPath = `/mdr/cdash/{version}/classes/{class}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASH Class List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionClassesGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashVersionClassesGet', 'version', version)
            const localVarPath = `/mdr/cdash/{version}/classes`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASH Domain Field
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASH Domain Identifier
         * @param {string} field CDASH Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionDomainsDomainFieldsFieldGet: async (version: string, domain: string, field: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashVersionDomainsDomainFieldsFieldGet', 'version', version)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('mdrCdashVersionDomainsDomainFieldsFieldGet', 'domain', domain)
            // verify required parameter 'field' is not null or undefined
            assertParamExists('mdrCdashVersionDomainsDomainFieldsFieldGet', 'field', field)
            const localVarPath = `/mdr/cdash/{version}/domains/{domain}/fields/{field}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
                .replace(`{${"field"}}`, encodeURIComponent(String(field)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASH Domain Field List
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASH Domain Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionDomainsDomainFieldsGet: async (version: string, domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashVersionDomainsDomainFieldsGet', 'version', version)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('mdrCdashVersionDomainsDomainFieldsGet', 'domain', domain)
            const localVarPath = `/mdr/cdash/{version}/domains/{domain}/fields`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASH Domain
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASH Domain Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionDomainsDomainGet: async (version: string, domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashVersionDomainsDomainGet', 'version', version)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('mdrCdashVersionDomainsDomainGet', 'domain', domain)
            const localVarPath = `/mdr/cdash/{version}/domains/{domain}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASH Domain List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionDomainsGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashVersionDomainsGet', 'version', version)
            const localVarPath = `/mdr/cdash/{version}/domains`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDASH Product
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrCdashVersionGet', 'version', version)
            const localVarPath = `/mdr/cdash/{version}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Root CDASH Class Field
         * @param {string} _class CDASH Class Identifier
         * @param {string} field CDASH Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootCdashClassesClassFieldsFieldGet: async (_class: string, field: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrRootCdashClassesClassFieldsFieldGet', '_class', _class)
            // verify required parameter 'field' is not null or undefined
            assertParamExists('mdrRootCdashClassesClassFieldsFieldGet', 'field', field)
            const localVarPath = `/mdr/root/cdash/classes/{class}/fields/{field}`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"field"}}`, encodeURIComponent(String(field)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Root CDASH Domain Field
         * @param {string} domain CDASH Domain Identifier
         * @param {string} field CDASH Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootCdashDomainsDomainFieldsFieldGet: async (domain: string, field: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('mdrRootCdashDomainsDomainFieldsFieldGet', 'domain', domain)
            // verify required parameter 'field' is not null or undefined
            assertParamExists('mdrRootCdashDomainsDomainFieldsFieldGet', 'field', field)
            const localVarPath = `/mdr/root/cdash/domains/{domain}/fields/{field}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
                .replace(`{${"field"}}`, encodeURIComponent(String(field)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClinicalDataAcquisitionStandardsHarmonizationCDASHApi - functional programming interface
 */
export const ClinicalDataAcquisitionStandardsHarmonizationCDASHApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClinicalDataAcquisitionStandardsHarmonizationCDASHApiAxiosParamCreator(configuration)
    return {
        /**
         * Get CDASH Class Domain List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASH Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashVersionClassesClassDomainsGet(version: string, _class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashClassDomains>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashVersionClassesClassDomainsGet(version, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicalDataAcquisitionStandardsHarmonizationCDASHApi.mdrCdashVersionClassesClassDomainsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASH Class Field
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASH Class Identifier
         * @param {string} field CDASH Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashVersionClassesClassFieldsFieldGet(version: string, _class: string, field: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashClassField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashVersionClassesClassFieldsFieldGet(version, _class, field, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicalDataAcquisitionStandardsHarmonizationCDASHApi.mdrCdashVersionClassesClassFieldsFieldGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASH Class
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASH Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashVersionClassesClassGet(version: string, _class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashVersionClassesClassGet(version, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicalDataAcquisitionStandardsHarmonizationCDASHApi.mdrCdashVersionClassesClassGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASH Class List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashVersionClassesGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashProductClasses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashVersionClassesGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicalDataAcquisitionStandardsHarmonizationCDASHApi.mdrCdashVersionClassesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASH Domain Field
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASH Domain Identifier
         * @param {string} field CDASH Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashVersionDomainsDomainFieldsFieldGet(version: string, domain: string, field: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashDomainField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashVersionDomainsDomainFieldsFieldGet(version, domain, field, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicalDataAcquisitionStandardsHarmonizationCDASHApi.mdrCdashVersionDomainsDomainFieldsFieldGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASH Domain Field List
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASH Domain Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashVersionDomainsDomainFieldsGet(version: string, domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashDomainFields>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashVersionDomainsDomainFieldsGet(version, domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicalDataAcquisitionStandardsHarmonizationCDASHApi.mdrCdashVersionDomainsDomainFieldsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASH Domain
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASH Domain Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashVersionDomainsDomainGet(version: string, domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashVersionDomainsDomainGet(version, domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicalDataAcquisitionStandardsHarmonizationCDASHApi.mdrCdashVersionDomainsDomainGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASH Domain List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashVersionDomainsGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashProductDomains>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashVersionDomainsGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicalDataAcquisitionStandardsHarmonizationCDASHApi.mdrCdashVersionDomainsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDASH Product
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCdashVersionGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdashProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCdashVersionGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicalDataAcquisitionStandardsHarmonizationCDASHApi.mdrCdashVersionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Root CDASH Class Field
         * @param {string} _class CDASH Class Identifier
         * @param {string} field CDASH Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrRootCdashClassesClassFieldsFieldGet(_class: string, field: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootCdashClassField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrRootCdashClassesClassFieldsFieldGet(_class, field, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicalDataAcquisitionStandardsHarmonizationCDASHApi.mdrRootCdashClassesClassFieldsFieldGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Root CDASH Domain Field
         * @param {string} domain CDASH Domain Identifier
         * @param {string} field CDASH Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrRootCdashDomainsDomainFieldsFieldGet(domain: string, field: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootCdashDomainField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrRootCdashDomainsDomainFieldsFieldGet(domain, field, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicalDataAcquisitionStandardsHarmonizationCDASHApi.mdrRootCdashDomainsDomainFieldsFieldGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClinicalDataAcquisitionStandardsHarmonizationCDASHApi - factory interface
 */
export const ClinicalDataAcquisitionStandardsHarmonizationCDASHApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClinicalDataAcquisitionStandardsHarmonizationCDASHApiFp(configuration)
    return {
        /**
         * Get CDASH Class Domain List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASH Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionClassesClassDomainsGet(version: string, _class: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashClassDomains> {
            return localVarFp.mdrCdashVersionClassesClassDomainsGet(version, _class, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASH Class Field
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASH Class Identifier
         * @param {string} field CDASH Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionClassesClassFieldsFieldGet(version: string, _class: string, field: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashClassField> {
            return localVarFp.mdrCdashVersionClassesClassFieldsFieldGet(version, _class, field, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASH Class
         * @param {string} version CDISC Library Product Version
         * @param {string} _class CDASH Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionClassesClassGet(version: string, _class: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashClass> {
            return localVarFp.mdrCdashVersionClassesClassGet(version, _class, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASH Class List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionClassesGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashProductClasses> {
            return localVarFp.mdrCdashVersionClassesGet(version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASH Domain Field
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASH Domain Identifier
         * @param {string} field CDASH Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionDomainsDomainFieldsFieldGet(version: string, domain: string, field: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashDomainField> {
            return localVarFp.mdrCdashVersionDomainsDomainFieldsFieldGet(version, domain, field, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASH Domain Field List
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASH Domain Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionDomainsDomainFieldsGet(version: string, domain: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashDomainFields> {
            return localVarFp.mdrCdashVersionDomainsDomainFieldsGet(version, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASH Domain
         * @param {string} version CDISC Library Product Version
         * @param {string} domain CDASH Domain Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionDomainsDomainGet(version: string, domain: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashDomain> {
            return localVarFp.mdrCdashVersionDomainsDomainGet(version, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASH Domain List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionDomainsGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashProductDomains> {
            return localVarFp.mdrCdashVersionDomainsGet(version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDASH Product
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCdashVersionGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<CdashProduct> {
            return localVarFp.mdrCdashVersionGet(version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Root CDASH Class Field
         * @param {string} _class CDASH Class Identifier
         * @param {string} field CDASH Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootCdashClassesClassFieldsFieldGet(_class: string, field: string, options?: RawAxiosRequestConfig): AxiosPromise<RootCdashClassField> {
            return localVarFp.mdrRootCdashClassesClassFieldsFieldGet(_class, field, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Root CDASH Domain Field
         * @param {string} domain CDASH Domain Identifier
         * @param {string} field CDASH Field Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootCdashDomainsDomainFieldsFieldGet(domain: string, field: string, options?: RawAxiosRequestConfig): AxiosPromise<RootCdashDomainField> {
            return localVarFp.mdrRootCdashDomainsDomainFieldsFieldGet(domain, field, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClinicalDataAcquisitionStandardsHarmonizationCDASHApi - object-oriented interface
 */
export class ClinicalDataAcquisitionStandardsHarmonizationCDASHApi extends BaseAPI {
    /**
     * Get CDASH Class Domain List
     * @param {string} version CDISC Library Product Version
     * @param {string} _class CDASH Class Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashVersionClassesClassDomainsGet(version: string, _class: string, options?: RawAxiosRequestConfig) {
        return ClinicalDataAcquisitionStandardsHarmonizationCDASHApiFp(this.configuration).mdrCdashVersionClassesClassDomainsGet(version, _class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASH Class Field
     * @param {string} version CDISC Library Product Version
     * @param {string} _class CDASH Class Identifier
     * @param {string} field CDASH Field Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashVersionClassesClassFieldsFieldGet(version: string, _class: string, field: string, options?: RawAxiosRequestConfig) {
        return ClinicalDataAcquisitionStandardsHarmonizationCDASHApiFp(this.configuration).mdrCdashVersionClassesClassFieldsFieldGet(version, _class, field, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASH Class
     * @param {string} version CDISC Library Product Version
     * @param {string} _class CDASH Class Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashVersionClassesClassGet(version: string, _class: string, options?: RawAxiosRequestConfig) {
        return ClinicalDataAcquisitionStandardsHarmonizationCDASHApiFp(this.configuration).mdrCdashVersionClassesClassGet(version, _class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASH Class List
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashVersionClassesGet(version: string, options?: RawAxiosRequestConfig) {
        return ClinicalDataAcquisitionStandardsHarmonizationCDASHApiFp(this.configuration).mdrCdashVersionClassesGet(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASH Domain Field
     * @param {string} version CDISC Library Product Version
     * @param {string} domain CDASH Domain Identifier
     * @param {string} field CDASH Field Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashVersionDomainsDomainFieldsFieldGet(version: string, domain: string, field: string, options?: RawAxiosRequestConfig) {
        return ClinicalDataAcquisitionStandardsHarmonizationCDASHApiFp(this.configuration).mdrCdashVersionDomainsDomainFieldsFieldGet(version, domain, field, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASH Domain Field List
     * @param {string} version CDISC Library Product Version
     * @param {string} domain CDASH Domain Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashVersionDomainsDomainFieldsGet(version: string, domain: string, options?: RawAxiosRequestConfig) {
        return ClinicalDataAcquisitionStandardsHarmonizationCDASHApiFp(this.configuration).mdrCdashVersionDomainsDomainFieldsGet(version, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASH Domain
     * @param {string} version CDISC Library Product Version
     * @param {string} domain CDASH Domain Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashVersionDomainsDomainGet(version: string, domain: string, options?: RawAxiosRequestConfig) {
        return ClinicalDataAcquisitionStandardsHarmonizationCDASHApiFp(this.configuration).mdrCdashVersionDomainsDomainGet(version, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASH Domain List
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashVersionDomainsGet(version: string, options?: RawAxiosRequestConfig) {
        return ClinicalDataAcquisitionStandardsHarmonizationCDASHApiFp(this.configuration).mdrCdashVersionDomainsGet(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDASH Product
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCdashVersionGet(version: string, options?: RawAxiosRequestConfig) {
        return ClinicalDataAcquisitionStandardsHarmonizationCDASHApiFp(this.configuration).mdrCdashVersionGet(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Root CDASH Class Field
     * @param {string} _class CDASH Class Identifier
     * @param {string} field CDASH Field Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrRootCdashClassesClassFieldsFieldGet(_class: string, field: string, options?: RawAxiosRequestConfig) {
        return ClinicalDataAcquisitionStandardsHarmonizationCDASHApiFp(this.configuration).mdrRootCdashClassesClassFieldsFieldGet(_class, field, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Root CDASH Domain Field
     * @param {string} domain CDASH Domain Identifier
     * @param {string} field CDASH Field Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrRootCdashDomainsDomainFieldsFieldGet(domain: string, field: string, options?: RawAxiosRequestConfig) {
        return ClinicalDataAcquisitionStandardsHarmonizationCDASHApiFp(this.configuration).mdrRootCdashDomainsDomainFieldsFieldGet(domain, field, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ControlledTerminologyCTApi - axios parameter creator
 */
export const ControlledTerminologyCTApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get CDISC Library CT Package List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCtPackagesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mdr/ct/packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDISC Library CT Package Codelist
         * @param {string} _package CT Package Identifier
         * @param {string} codelist CT Codelist Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCtPackagesPackageCodelistsCodelistGet: async (_package: string, codelist: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_package' is not null or undefined
            assertParamExists('mdrCtPackagesPackageCodelistsCodelistGet', '_package', _package)
            // verify required parameter 'codelist' is not null or undefined
            assertParamExists('mdrCtPackagesPackageCodelistsCodelistGet', 'codelist', codelist)
            const localVarPath = `/mdr/ct/packages/{package}/codelists/{codelist}`
                .replace(`{${"package"}}`, encodeURIComponent(String(_package)))
                .replace(`{${"codelist"}}`, encodeURIComponent(String(codelist)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDISC Library CT Package Codelist Term List
         * @param {string} _package CT Package Identifier
         * @param {string} codelist CT Codelist Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCtPackagesPackageCodelistsCodelistTermsGet: async (_package: string, codelist: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_package' is not null or undefined
            assertParamExists('mdrCtPackagesPackageCodelistsCodelistTermsGet', '_package', _package)
            // verify required parameter 'codelist' is not null or undefined
            assertParamExists('mdrCtPackagesPackageCodelistsCodelistTermsGet', 'codelist', codelist)
            const localVarPath = `/mdr/ct/packages/{package}/codelists/{codelist}/terms`
                .replace(`{${"package"}}`, encodeURIComponent(String(_package)))
                .replace(`{${"codelist"}}`, encodeURIComponent(String(codelist)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDISC Library CT Package Codelist Term
         * @param {string} _package CT Package Product Identifier
         * @param {string} codelist CT Codelist Identifier
         * @param {string} term CT Codelist Term Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCtPackagesPackageCodelistsCodelistTermsTermGet: async (_package: string, codelist: string, term: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_package' is not null or undefined
            assertParamExists('mdrCtPackagesPackageCodelistsCodelistTermsTermGet', '_package', _package)
            // verify required parameter 'codelist' is not null or undefined
            assertParamExists('mdrCtPackagesPackageCodelistsCodelistTermsTermGet', 'codelist', codelist)
            // verify required parameter 'term' is not null or undefined
            assertParamExists('mdrCtPackagesPackageCodelistsCodelistTermsTermGet', 'term', term)
            const localVarPath = `/mdr/ct/packages/{package}/codelists/{codelist}/terms/{term}`
                .replace(`{${"package"}}`, encodeURIComponent(String(_package)))
                .replace(`{${"codelist"}}`, encodeURIComponent(String(codelist)))
                .replace(`{${"term"}}`, encodeURIComponent(String(term)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDISC Library CT Package Codelist List
         * @param {string} _package CT Package Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCtPackagesPackageCodelistsGet: async (_package: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_package' is not null or undefined
            assertParamExists('mdrCtPackagesPackageCodelistsGet', '_package', _package)
            const localVarPath = `/mdr/ct/packages/{package}/codelists`
                .replace(`{${"package"}}`, encodeURIComponent(String(_package)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDISC Library CT Package
         * @param {string} product CT Package Product Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCtPackagesProductGet: async (product: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('mdrCtPackagesProductGet', 'product', product)
            const localVarPath = `/mdr/ct/packages/{product}`
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDISC Library Root CT Codelist
         * @param {string} productGroup CT Product Group Identifier
         * @param {string} codelist CT Codelist Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootCtProductGroupCodelistsCodelistGet: async (productGroup: string, codelist: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productGroup' is not null or undefined
            assertParamExists('mdrRootCtProductGroupCodelistsCodelistGet', 'productGroup', productGroup)
            // verify required parameter 'codelist' is not null or undefined
            assertParamExists('mdrRootCtProductGroupCodelistsCodelistGet', 'codelist', codelist)
            const localVarPath = `/mdr/root/ct/{productGroup}/codelists/{codelist}`
                .replace(`{${"productGroup"}}`, encodeURIComponent(String(productGroup)))
                .replace(`{${"codelist"}}`, encodeURIComponent(String(codelist)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDISC Library Root CT Term
         * @param {string} productGroup CT Product Group Identifier
         * @param {string} codelist CT Codelist Identifier
         * @param {string} term CT Codelist Term Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootCtProductGroupCodelistsCodelistTermsTermGet: async (productGroup: string, codelist: string, term: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productGroup' is not null or undefined
            assertParamExists('mdrRootCtProductGroupCodelistsCodelistTermsTermGet', 'productGroup', productGroup)
            // verify required parameter 'codelist' is not null or undefined
            assertParamExists('mdrRootCtProductGroupCodelistsCodelistTermsTermGet', 'codelist', codelist)
            // verify required parameter 'term' is not null or undefined
            assertParamExists('mdrRootCtProductGroupCodelistsCodelistTermsTermGet', 'term', term)
            const localVarPath = `/mdr/root/ct/{productGroup}/codelists/{codelist}/terms/{term}`
                .replace(`{${"productGroup"}}`, encodeURIComponent(String(productGroup)))
                .replace(`{${"codelist"}}`, encodeURIComponent(String(codelist)))
                .replace(`{${"term"}}`, encodeURIComponent(String(term)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ControlledTerminologyCTApi - functional programming interface
 */
export const ControlledTerminologyCTApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ControlledTerminologyCTApiAxiosParamCreator(configuration)
    return {
        /**
         * Get CDISC Library CT Package List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCtPackagesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CtPackages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCtPackagesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlledTerminologyCTApi.mdrCtPackagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDISC Library CT Package Codelist
         * @param {string} _package CT Package Identifier
         * @param {string} codelist CT Codelist Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCtPackagesPackageCodelistsCodelistGet(_package: string, codelist: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CtCodelist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCtPackagesPackageCodelistsCodelistGet(_package, codelist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlledTerminologyCTApi.mdrCtPackagesPackageCodelistsCodelistGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDISC Library CT Package Codelist Term List
         * @param {string} _package CT Package Identifier
         * @param {string} codelist CT Codelist Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCtPackagesPackageCodelistsCodelistTermsGet(_package: string, codelist: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CtCodelistTerms>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCtPackagesPackageCodelistsCodelistTermsGet(_package, codelist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlledTerminologyCTApi.mdrCtPackagesPackageCodelistsCodelistTermsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDISC Library CT Package Codelist Term
         * @param {string} _package CT Package Product Identifier
         * @param {string} codelist CT Codelist Identifier
         * @param {string} term CT Codelist Term Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCtPackagesPackageCodelistsCodelistTermsTermGet(_package: string, codelist: string, term: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CtTerm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCtPackagesPackageCodelistsCodelistTermsTermGet(_package, codelist, term, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlledTerminologyCTApi.mdrCtPackagesPackageCodelistsCodelistTermsTermGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDISC Library CT Package Codelist List
         * @param {string} _package CT Package Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCtPackagesPackageCodelistsGet(_package: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CtPackageCodelists>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCtPackagesPackageCodelistsGet(_package, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlledTerminologyCTApi.mdrCtPackagesPackageCodelistsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDISC Library CT Package
         * @param {string} product CT Package Product Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrCtPackagesProductGet(product: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CtPackage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrCtPackagesProductGet(product, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlledTerminologyCTApi.mdrCtPackagesProductGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDISC Library Root CT Codelist
         * @param {string} productGroup CT Product Group Identifier
         * @param {string} codelist CT Codelist Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrRootCtProductGroupCodelistsCodelistGet(productGroup: string, codelist: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootCtCodelist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrRootCtProductGroupCodelistsCodelistGet(productGroup, codelist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlledTerminologyCTApi.mdrRootCtProductGroupCodelistsCodelistGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDISC Library Root CT Term
         * @param {string} productGroup CT Product Group Identifier
         * @param {string} codelist CT Codelist Identifier
         * @param {string} term CT Codelist Term Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrRootCtProductGroupCodelistsCodelistTermsTermGet(productGroup: string, codelist: string, term: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootCtTerm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrRootCtProductGroupCodelistsCodelistTermsTermGet(productGroup, codelist, term, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlledTerminologyCTApi.mdrRootCtProductGroupCodelistsCodelistTermsTermGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ControlledTerminologyCTApi - factory interface
 */
export const ControlledTerminologyCTApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ControlledTerminologyCTApiFp(configuration)
    return {
        /**
         * Get CDISC Library CT Package List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCtPackagesGet(options?: RawAxiosRequestConfig): AxiosPromise<CtPackages> {
            return localVarFp.mdrCtPackagesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDISC Library CT Package Codelist
         * @param {string} _package CT Package Identifier
         * @param {string} codelist CT Codelist Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCtPackagesPackageCodelistsCodelistGet(_package: string, codelist: string, options?: RawAxiosRequestConfig): AxiosPromise<CtCodelist> {
            return localVarFp.mdrCtPackagesPackageCodelistsCodelistGet(_package, codelist, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDISC Library CT Package Codelist Term List
         * @param {string} _package CT Package Identifier
         * @param {string} codelist CT Codelist Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCtPackagesPackageCodelistsCodelistTermsGet(_package: string, codelist: string, options?: RawAxiosRequestConfig): AxiosPromise<CtCodelistTerms> {
            return localVarFp.mdrCtPackagesPackageCodelistsCodelistTermsGet(_package, codelist, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDISC Library CT Package Codelist Term
         * @param {string} _package CT Package Product Identifier
         * @param {string} codelist CT Codelist Identifier
         * @param {string} term CT Codelist Term Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCtPackagesPackageCodelistsCodelistTermsTermGet(_package: string, codelist: string, term: string, options?: RawAxiosRequestConfig): AxiosPromise<CtTerm> {
            return localVarFp.mdrCtPackagesPackageCodelistsCodelistTermsTermGet(_package, codelist, term, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDISC Library CT Package Codelist List
         * @param {string} _package CT Package Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCtPackagesPackageCodelistsGet(_package: string, options?: RawAxiosRequestConfig): AxiosPromise<CtPackageCodelists> {
            return localVarFp.mdrCtPackagesPackageCodelistsGet(_package, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDISC Library CT Package
         * @param {string} product CT Package Product Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrCtPackagesProductGet(product: string, options?: RawAxiosRequestConfig): AxiosPromise<CtPackage> {
            return localVarFp.mdrCtPackagesProductGet(product, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDISC Library Root CT Codelist
         * @param {string} productGroup CT Product Group Identifier
         * @param {string} codelist CT Codelist Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootCtProductGroupCodelistsCodelistGet(productGroup: string, codelist: string, options?: RawAxiosRequestConfig): AxiosPromise<RootCtCodelist> {
            return localVarFp.mdrRootCtProductGroupCodelistsCodelistGet(productGroup, codelist, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDISC Library Root CT Term
         * @param {string} productGroup CT Product Group Identifier
         * @param {string} codelist CT Codelist Identifier
         * @param {string} term CT Codelist Term Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootCtProductGroupCodelistsCodelistTermsTermGet(productGroup: string, codelist: string, term: string, options?: RawAxiosRequestConfig): AxiosPromise<RootCtTerm> {
            return localVarFp.mdrRootCtProductGroupCodelistsCodelistTermsTermGet(productGroup, codelist, term, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ControlledTerminologyCTApi - object-oriented interface
 */
export class ControlledTerminologyCTApi extends BaseAPI {
    /**
     * Get CDISC Library CT Package List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCtPackagesGet(options?: RawAxiosRequestConfig) {
        return ControlledTerminologyCTApiFp(this.configuration).mdrCtPackagesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDISC Library CT Package Codelist
     * @param {string} _package CT Package Identifier
     * @param {string} codelist CT Codelist Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCtPackagesPackageCodelistsCodelistGet(_package: string, codelist: string, options?: RawAxiosRequestConfig) {
        return ControlledTerminologyCTApiFp(this.configuration).mdrCtPackagesPackageCodelistsCodelistGet(_package, codelist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDISC Library CT Package Codelist Term List
     * @param {string} _package CT Package Identifier
     * @param {string} codelist CT Codelist Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCtPackagesPackageCodelistsCodelistTermsGet(_package: string, codelist: string, options?: RawAxiosRequestConfig) {
        return ControlledTerminologyCTApiFp(this.configuration).mdrCtPackagesPackageCodelistsCodelistTermsGet(_package, codelist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDISC Library CT Package Codelist Term
     * @param {string} _package CT Package Product Identifier
     * @param {string} codelist CT Codelist Identifier
     * @param {string} term CT Codelist Term Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCtPackagesPackageCodelistsCodelistTermsTermGet(_package: string, codelist: string, term: string, options?: RawAxiosRequestConfig) {
        return ControlledTerminologyCTApiFp(this.configuration).mdrCtPackagesPackageCodelistsCodelistTermsTermGet(_package, codelist, term, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDISC Library CT Package Codelist List
     * @param {string} _package CT Package Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCtPackagesPackageCodelistsGet(_package: string, options?: RawAxiosRequestConfig) {
        return ControlledTerminologyCTApiFp(this.configuration).mdrCtPackagesPackageCodelistsGet(_package, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDISC Library CT Package
     * @param {string} product CT Package Product Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrCtPackagesProductGet(product: string, options?: RawAxiosRequestConfig) {
        return ControlledTerminologyCTApiFp(this.configuration).mdrCtPackagesProductGet(product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDISC Library Root CT Codelist
     * @param {string} productGroup CT Product Group Identifier
     * @param {string} codelist CT Codelist Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrRootCtProductGroupCodelistsCodelistGet(productGroup: string, codelist: string, options?: RawAxiosRequestConfig) {
        return ControlledTerminologyCTApiFp(this.configuration).mdrRootCtProductGroupCodelistsCodelistGet(productGroup, codelist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDISC Library Root CT Term
     * @param {string} productGroup CT Product Group Identifier
     * @param {string} codelist CT Codelist Identifier
     * @param {string} term CT Codelist Term Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrRootCtProductGroupCodelistsCodelistTermsTermGet(productGroup: string, codelist: string, term: string, options?: RawAxiosRequestConfig) {
        return ControlledTerminologyCTApiFp(this.configuration).mdrRootCtProductGroupCodelistsCodelistTermsTermGet(productGroup, codelist, term, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Information About CDISC Library
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAboutGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mdr/about`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDISC Library Last Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrLastupdatedGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mdr/lastupdated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDISC Library Product Group Data Analysis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrProductsDataAnalysisGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mdr/products/DataAnalysis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDISC Library Product Group Data Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrProductsDataCollectionGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mdr/products/DataCollection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDISC Library Product Group Data Tabulation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrProductsDataTabulationGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mdr/products/DataTabulation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDISC Library Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrProductsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mdr/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDISC Library Product Group QRS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrProductsMeasuresGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mdr/products/Measures`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CDISC Library Product Group Terminology
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrProductsTerminologyGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mdr/products/Terminology`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Information About CDISC Library
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrAboutGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<About>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrAboutGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.mdrAboutGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDISC Library Last Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrLastupdatedGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lastupdated>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrLastupdatedGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.mdrLastupdatedGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDISC Library Product Group Data Analysis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrProductsDataAnalysisGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductgroupDataAnalysis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrProductsDataAnalysisGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.mdrProductsDataAnalysisGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDISC Library Product Group Data Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrProductsDataCollectionGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductgroupDataCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrProductsDataCollectionGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.mdrProductsDataCollectionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDISC Library Product Group Data Tabulation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrProductsDataTabulationGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductgroupDataTabulation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrProductsDataTabulationGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.mdrProductsDataTabulationGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDISC Library Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrProductsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Products>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrProductsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.mdrProductsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDISC Library Product Group QRS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrProductsMeasuresGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductgroupQrs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrProductsMeasuresGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.mdrProductsMeasuresGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CDISC Library Product Group Terminology
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrProductsTerminologyGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductgroupTerminology>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrProductsTerminologyGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.mdrProductsTerminologyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Get Information About CDISC Library
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrAboutGet(options?: RawAxiosRequestConfig): AxiosPromise<About> {
            return localVarFp.mdrAboutGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDISC Library Last Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrLastupdatedGet(options?: RawAxiosRequestConfig): AxiosPromise<Lastupdated> {
            return localVarFp.mdrLastupdatedGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDISC Library Product Group Data Analysis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrProductsDataAnalysisGet(options?: RawAxiosRequestConfig): AxiosPromise<ProductgroupDataAnalysis> {
            return localVarFp.mdrProductsDataAnalysisGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDISC Library Product Group Data Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrProductsDataCollectionGet(options?: RawAxiosRequestConfig): AxiosPromise<ProductgroupDataCollection> {
            return localVarFp.mdrProductsDataCollectionGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDISC Library Product Group Data Tabulation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrProductsDataTabulationGet(options?: RawAxiosRequestConfig): AxiosPromise<ProductgroupDataTabulation> {
            return localVarFp.mdrProductsDataTabulationGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDISC Library Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrProductsGet(options?: RawAxiosRequestConfig): AxiosPromise<Products> {
            return localVarFp.mdrProductsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDISC Library Product Group QRS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrProductsMeasuresGet(options?: RawAxiosRequestConfig): AxiosPromise<ProductgroupQrs> {
            return localVarFp.mdrProductsMeasuresGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get CDISC Library Product Group Terminology
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrProductsTerminologyGet(options?: RawAxiosRequestConfig): AxiosPromise<ProductgroupTerminology> {
            return localVarFp.mdrProductsTerminologyGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * Get Information About CDISC Library
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrAboutGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).mdrAboutGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDISC Library Last Updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrLastupdatedGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).mdrLastupdatedGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDISC Library Product Group Data Analysis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrProductsDataAnalysisGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).mdrProductsDataAnalysisGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDISC Library Product Group Data Collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrProductsDataCollectionGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).mdrProductsDataCollectionGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDISC Library Product Group Data Tabulation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrProductsDataTabulationGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).mdrProductsDataTabulationGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDISC Library Products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrProductsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).mdrProductsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDISC Library Product Group QRS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrProductsMeasuresGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).mdrProductsMeasuresGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CDISC Library Product Group Terminology
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrProductsTerminologyGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).mdrProductsTerminologyGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeasuresApi - axios parameter creator
 */
export const MeasuresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get QRS Product
         * @param {string} measure QRS Measure Identifier
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrQrsMeasureVersionGet: async (measure: string, version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'measure' is not null or undefined
            assertParamExists('mdrQrsMeasureVersionGet', 'measure', measure)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrQrsMeasureVersionGet', 'version', version)
            const localVarPath = `/mdr/qrs/{measure}/{version}`
                .replace(`{${"measure"}}`, encodeURIComponent(String(measure)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get QRS Item List
         * @param {string} measure QRS Measure Identifier
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrQrsMeasureVersionItemsGet: async (measure: string, version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'measure' is not null or undefined
            assertParamExists('mdrQrsMeasureVersionItemsGet', 'measure', measure)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrQrsMeasureVersionItemsGet', 'version', version)
            const localVarPath = `/mdr/qrs/{measure}/{version}/items`
                .replace(`{${"measure"}}`, encodeURIComponent(String(measure)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get QRS Item
         * @param {string} measure QRS Measure Identifier
         * @param {string} version CDISC Library Product Version
         * @param {string} item QRS Measure Item Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrQrsMeasureVersionItemsItemGet: async (measure: string, version: string, item: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'measure' is not null or undefined
            assertParamExists('mdrQrsMeasureVersionItemsItemGet', 'measure', measure)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrQrsMeasureVersionItemsItemGet', 'version', version)
            // verify required parameter 'item' is not null or undefined
            assertParamExists('mdrQrsMeasureVersionItemsItemGet', 'item', item)
            const localVarPath = `/mdr/qrs/{measure}/{version}/items/{item}`
                .replace(`{${"measure"}}`, encodeURIComponent(String(measure)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get QRS Response Group List
         * @param {string} measure QRS Measure Identifier
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrQrsMeasureVersionResponsegroupsGet: async (measure: string, version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'measure' is not null or undefined
            assertParamExists('mdrQrsMeasureVersionResponsegroupsGet', 'measure', measure)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrQrsMeasureVersionResponsegroupsGet', 'version', version)
            const localVarPath = `/mdr/qrs/{measure}/{version}/responsegroups`
                .replace(`{${"measure"}}`, encodeURIComponent(String(measure)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get QRS Response Group
         * @param {string} measure QRS Measure Identifier
         * @param {string} version CDISC Library Product Version
         * @param {string} responsegroup QRS Measure\&#39;s Response Group Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrQrsMeasureVersionResponsegroupsResponsegroupGet: async (measure: string, version: string, responsegroup: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'measure' is not null or undefined
            assertParamExists('mdrQrsMeasureVersionResponsegroupsResponsegroupGet', 'measure', measure)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrQrsMeasureVersionResponsegroupsResponsegroupGet', 'version', version)
            // verify required parameter 'responsegroup' is not null or undefined
            assertParamExists('mdrQrsMeasureVersionResponsegroupsResponsegroupGet', 'responsegroup', responsegroup)
            const localVarPath = `/mdr/qrs/{measure}/{version}/responsegroups/{responsegroup}`
                .replace(`{${"measure"}}`, encodeURIComponent(String(measure)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"responsegroup"}}`, encodeURIComponent(String(responsegroup)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeasuresApi - functional programming interface
 */
export const MeasuresApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeasuresApiAxiosParamCreator(configuration)
    return {
        /**
         * Get QRS Product
         * @param {string} measure QRS Measure Identifier
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrQrsMeasureVersionGet(measure: string, version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QrsProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrQrsMeasureVersionGet(measure, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeasuresApi.mdrQrsMeasureVersionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get QRS Item List
         * @param {string} measure QRS Measure Identifier
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrQrsMeasureVersionItemsGet(measure: string, version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QrsItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrQrsMeasureVersionItemsGet(measure, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeasuresApi.mdrQrsMeasureVersionItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get QRS Item
         * @param {string} measure QRS Measure Identifier
         * @param {string} version CDISC Library Product Version
         * @param {string} item QRS Measure Item Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrQrsMeasureVersionItemsItemGet(measure: string, version: string, item: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QrsItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrQrsMeasureVersionItemsItemGet(measure, version, item, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeasuresApi.mdrQrsMeasureVersionItemsItemGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get QRS Response Group List
         * @param {string} measure QRS Measure Identifier
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrQrsMeasureVersionResponsegroupsGet(measure: string, version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QrsResponsegroups>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrQrsMeasureVersionResponsegroupsGet(measure, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeasuresApi.mdrQrsMeasureVersionResponsegroupsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get QRS Response Group
         * @param {string} measure QRS Measure Identifier
         * @param {string} version CDISC Library Product Version
         * @param {string} responsegroup QRS Measure\&#39;s Response Group Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrQrsMeasureVersionResponsegroupsResponsegroupGet(measure: string, version: string, responsegroup: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QrsResponsegroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrQrsMeasureVersionResponsegroupsResponsegroupGet(measure, version, responsegroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeasuresApi.mdrQrsMeasureVersionResponsegroupsResponsegroupGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeasuresApi - factory interface
 */
export const MeasuresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeasuresApiFp(configuration)
    return {
        /**
         * Get QRS Product
         * @param {string} measure QRS Measure Identifier
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrQrsMeasureVersionGet(measure: string, version: string, options?: RawAxiosRequestConfig): AxiosPromise<QrsProduct> {
            return localVarFp.mdrQrsMeasureVersionGet(measure, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get QRS Item List
         * @param {string} measure QRS Measure Identifier
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrQrsMeasureVersionItemsGet(measure: string, version: string, options?: RawAxiosRequestConfig): AxiosPromise<QrsItems> {
            return localVarFp.mdrQrsMeasureVersionItemsGet(measure, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get QRS Item
         * @param {string} measure QRS Measure Identifier
         * @param {string} version CDISC Library Product Version
         * @param {string} item QRS Measure Item Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrQrsMeasureVersionItemsItemGet(measure: string, version: string, item: string, options?: RawAxiosRequestConfig): AxiosPromise<QrsItem> {
            return localVarFp.mdrQrsMeasureVersionItemsItemGet(measure, version, item, options).then((request) => request(axios, basePath));
        },
        /**
         * Get QRS Response Group List
         * @param {string} measure QRS Measure Identifier
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrQrsMeasureVersionResponsegroupsGet(measure: string, version: string, options?: RawAxiosRequestConfig): AxiosPromise<QrsResponsegroups> {
            return localVarFp.mdrQrsMeasureVersionResponsegroupsGet(measure, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get QRS Response Group
         * @param {string} measure QRS Measure Identifier
         * @param {string} version CDISC Library Product Version
         * @param {string} responsegroup QRS Measure\&#39;s Response Group Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrQrsMeasureVersionResponsegroupsResponsegroupGet(measure: string, version: string, responsegroup: string, options?: RawAxiosRequestConfig): AxiosPromise<QrsResponsegroup> {
            return localVarFp.mdrQrsMeasureVersionResponsegroupsResponsegroupGet(measure, version, responsegroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeasuresApi - object-oriented interface
 */
export class MeasuresApi extends BaseAPI {
    /**
     * Get QRS Product
     * @param {string} measure QRS Measure Identifier
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrQrsMeasureVersionGet(measure: string, version: string, options?: RawAxiosRequestConfig) {
        return MeasuresApiFp(this.configuration).mdrQrsMeasureVersionGet(measure, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get QRS Item List
     * @param {string} measure QRS Measure Identifier
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrQrsMeasureVersionItemsGet(measure: string, version: string, options?: RawAxiosRequestConfig) {
        return MeasuresApiFp(this.configuration).mdrQrsMeasureVersionItemsGet(measure, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get QRS Item
     * @param {string} measure QRS Measure Identifier
     * @param {string} version CDISC Library Product Version
     * @param {string} item QRS Measure Item Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrQrsMeasureVersionItemsItemGet(measure: string, version: string, item: string, options?: RawAxiosRequestConfig) {
        return MeasuresApiFp(this.configuration).mdrQrsMeasureVersionItemsItemGet(measure, version, item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get QRS Response Group List
     * @param {string} measure QRS Measure Identifier
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrQrsMeasureVersionResponsegroupsGet(measure: string, version: string, options?: RawAxiosRequestConfig) {
        return MeasuresApiFp(this.configuration).mdrQrsMeasureVersionResponsegroupsGet(measure, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get QRS Response Group
     * @param {string} measure QRS Measure Identifier
     * @param {string} version CDISC Library Product Version
     * @param {string} responsegroup QRS Measure\&#39;s Response Group Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrQrsMeasureVersionResponsegroupsResponsegroupGet(measure: string, version: string, responsegroup: string, options?: RawAxiosRequestConfig) {
        return MeasuresApiFp(this.configuration).mdrQrsMeasureVersionResponsegroupsResponsegroupGet(measure, version, responsegroup, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SDTMImplementationGuideSDTMIGApi - axios parameter creator
 */
export const SDTMImplementationGuideSDTMIGApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Root SDTMIG Dataset Variable
         * @param {string} dataset SDTMIG Dataset Identifier
         * @param {string} _var SDTMIG Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootSdtmigDatasetsDatasetVariablesVarGet: async (dataset: string, _var: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('mdrRootSdtmigDatasetsDatasetVariablesVarGet', 'dataset', dataset)
            // verify required parameter '_var' is not null or undefined
            assertParamExists('mdrRootSdtmigDatasetsDatasetVariablesVarGet', '_var', _var)
            const localVarPath = `/mdr/root/sdtmig/datasets/{dataset}/variables/{var}`
                .replace(`{${"dataset"}}`, encodeURIComponent(String(dataset)))
                .replace(`{${"var"}}`, encodeURIComponent(String(_var)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTMIG Class Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTMIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionClassesClassDatasetsGet: async (version: string, _class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmigVersionClassesClassDatasetsGet', 'version', version)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrSdtmigVersionClassesClassDatasetsGet', '_class', _class)
            const localVarPath = `/mdr/sdtmig/{version}/classes/{class}/datasets`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTMIG Class
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTMIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionClassesClassGet: async (version: string, _class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmigVersionClassesClassGet', 'version', version)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrSdtmigVersionClassesClassGet', '_class', _class)
            const localVarPath = `/mdr/sdtmig/{version}/classes/{class}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTMIG Class List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionClassesGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmigVersionClassesGet', 'version', version)
            const localVarPath = `/mdr/sdtmig/{version}/classes`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTMIG Dataset
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTMIG Dataset Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionDatasetsDatasetGet: async (version: string, dataset: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmigVersionDatasetsDatasetGet', 'version', version)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('mdrSdtmigVersionDatasetsDatasetGet', 'dataset', dataset)
            const localVarPath = `/mdr/sdtmig/{version}/datasets/{dataset}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"dataset"}}`, encodeURIComponent(String(dataset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTMIG Dataset Variable List
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTMIG Dataset Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionDatasetsDatasetVariablesGet: async (version: string, dataset: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmigVersionDatasetsDatasetVariablesGet', 'version', version)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('mdrSdtmigVersionDatasetsDatasetVariablesGet', 'dataset', dataset)
            const localVarPath = `/mdr/sdtmig/{version}/datasets/{dataset}/variables`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"dataset"}}`, encodeURIComponent(String(dataset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTMIG Dataset Variable
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTMIG Dataset Identifier
         * @param {string} _var SDTMIG Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionDatasetsDatasetVariablesVarGet: async (version: string, dataset: string, _var: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmigVersionDatasetsDatasetVariablesVarGet', 'version', version)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('mdrSdtmigVersionDatasetsDatasetVariablesVarGet', 'dataset', dataset)
            // verify required parameter '_var' is not null or undefined
            assertParamExists('mdrSdtmigVersionDatasetsDatasetVariablesVarGet', '_var', _var)
            const localVarPath = `/mdr/sdtmig/{version}/datasets/{dataset}/variables/{var}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"dataset"}}`, encodeURIComponent(String(dataset)))
                .replace(`{${"var"}}`, encodeURIComponent(String(_var)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTMIG Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionDatasetsGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmigVersionDatasetsGet', 'version', version)
            const localVarPath = `/mdr/sdtmig/{version}/datasets`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTMIG product
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmigVersionGet', 'version', version)
            const localVarPath = `/mdr/sdtmig/{version}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SDTMImplementationGuideSDTMIGApi - functional programming interface
 */
export const SDTMImplementationGuideSDTMIGApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SDTMImplementationGuideSDTMIGApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Root SDTMIG Dataset Variable
         * @param {string} dataset SDTMIG Dataset Identifier
         * @param {string} _var SDTMIG Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrRootSdtmigDatasetsDatasetVariablesVarGet(dataset: string, _var: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootSdtmigDatasetVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrRootSdtmigDatasetsDatasetVariablesVarGet(dataset, _var, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SDTMImplementationGuideSDTMIGApi.mdrRootSdtmigDatasetsDatasetVariablesVarGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTMIG Class Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTMIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmigVersionClassesClassDatasetsGet(version: string, _class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmigClassDatasets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmigVersionClassesClassDatasetsGet(version, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SDTMImplementationGuideSDTMIGApi.mdrSdtmigVersionClassesClassDatasetsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTMIG Class
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTMIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmigVersionClassesClassGet(version: string, _class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmigClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmigVersionClassesClassGet(version, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SDTMImplementationGuideSDTMIGApi.mdrSdtmigVersionClassesClassGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTMIG Class List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmigVersionClassesGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmigClasses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmigVersionClassesGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SDTMImplementationGuideSDTMIGApi.mdrSdtmigVersionClassesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTMIG Dataset
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTMIG Dataset Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmigVersionDatasetsDatasetGet(version: string, dataset: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmigDataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmigVersionDatasetsDatasetGet(version, dataset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SDTMImplementationGuideSDTMIGApi.mdrSdtmigVersionDatasetsDatasetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTMIG Dataset Variable List
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTMIG Dataset Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmigVersionDatasetsDatasetVariablesGet(version: string, dataset: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmigDatasetVariables>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmigVersionDatasetsDatasetVariablesGet(version, dataset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SDTMImplementationGuideSDTMIGApi.mdrSdtmigVersionDatasetsDatasetVariablesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTMIG Dataset Variable
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTMIG Dataset Identifier
         * @param {string} _var SDTMIG Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmigVersionDatasetsDatasetVariablesVarGet(version: string, dataset: string, _var: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmigDatasetVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmigVersionDatasetsDatasetVariablesVarGet(version, dataset, _var, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SDTMImplementationGuideSDTMIGApi.mdrSdtmigVersionDatasetsDatasetVariablesVarGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTMIG Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmigVersionDatasetsGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmigDatasets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmigVersionDatasetsGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SDTMImplementationGuideSDTMIGApi.mdrSdtmigVersionDatasetsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTMIG product
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmigVersionGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmigProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmigVersionGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SDTMImplementationGuideSDTMIGApi.mdrSdtmigVersionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SDTMImplementationGuideSDTMIGApi - factory interface
 */
export const SDTMImplementationGuideSDTMIGApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SDTMImplementationGuideSDTMIGApiFp(configuration)
    return {
        /**
         * Get Root SDTMIG Dataset Variable
         * @param {string} dataset SDTMIG Dataset Identifier
         * @param {string} _var SDTMIG Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootSdtmigDatasetsDatasetVariablesVarGet(dataset: string, _var: string, options?: RawAxiosRequestConfig): AxiosPromise<RootSdtmigDatasetVariable> {
            return localVarFp.mdrRootSdtmigDatasetsDatasetVariablesVarGet(dataset, _var, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTMIG Class Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTMIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionClassesClassDatasetsGet(version: string, _class: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmigClassDatasets> {
            return localVarFp.mdrSdtmigVersionClassesClassDatasetsGet(version, _class, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTMIG Class
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTMIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionClassesClassGet(version: string, _class: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmigClass> {
            return localVarFp.mdrSdtmigVersionClassesClassGet(version, _class, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTMIG Class List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionClassesGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmigClasses> {
            return localVarFp.mdrSdtmigVersionClassesGet(version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTMIG Dataset
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTMIG Dataset Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionDatasetsDatasetGet(version: string, dataset: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmigDataset> {
            return localVarFp.mdrSdtmigVersionDatasetsDatasetGet(version, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTMIG Dataset Variable List
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTMIG Dataset Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionDatasetsDatasetVariablesGet(version: string, dataset: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmigDatasetVariables> {
            return localVarFp.mdrSdtmigVersionDatasetsDatasetVariablesGet(version, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTMIG Dataset Variable
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTMIG Dataset Identifier
         * @param {string} _var SDTMIG Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionDatasetsDatasetVariablesVarGet(version: string, dataset: string, _var: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmigDatasetVariable> {
            return localVarFp.mdrSdtmigVersionDatasetsDatasetVariablesVarGet(version, dataset, _var, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTMIG Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionDatasetsGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmigDatasets> {
            return localVarFp.mdrSdtmigVersionDatasetsGet(version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTMIG product
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmigVersionGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmigProduct> {
            return localVarFp.mdrSdtmigVersionGet(version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SDTMImplementationGuideSDTMIGApi - object-oriented interface
 */
export class SDTMImplementationGuideSDTMIGApi extends BaseAPI {
    /**
     * Get Root SDTMIG Dataset Variable
     * @param {string} dataset SDTMIG Dataset Identifier
     * @param {string} _var SDTMIG Variable Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrRootSdtmigDatasetsDatasetVariablesVarGet(dataset: string, _var: string, options?: RawAxiosRequestConfig) {
        return SDTMImplementationGuideSDTMIGApiFp(this.configuration).mdrRootSdtmigDatasetsDatasetVariablesVarGet(dataset, _var, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTMIG Class Dataset List
     * @param {string} version CDISC Library Product Version
     * @param {string} _class SDTMIG Class Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmigVersionClassesClassDatasetsGet(version: string, _class: string, options?: RawAxiosRequestConfig) {
        return SDTMImplementationGuideSDTMIGApiFp(this.configuration).mdrSdtmigVersionClassesClassDatasetsGet(version, _class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTMIG Class
     * @param {string} version CDISC Library Product Version
     * @param {string} _class SDTMIG Class Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmigVersionClassesClassGet(version: string, _class: string, options?: RawAxiosRequestConfig) {
        return SDTMImplementationGuideSDTMIGApiFp(this.configuration).mdrSdtmigVersionClassesClassGet(version, _class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTMIG Class List
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmigVersionClassesGet(version: string, options?: RawAxiosRequestConfig) {
        return SDTMImplementationGuideSDTMIGApiFp(this.configuration).mdrSdtmigVersionClassesGet(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTMIG Dataset
     * @param {string} version CDISC Library Product Version
     * @param {string} dataset SDTMIG Dataset Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmigVersionDatasetsDatasetGet(version: string, dataset: string, options?: RawAxiosRequestConfig) {
        return SDTMImplementationGuideSDTMIGApiFp(this.configuration).mdrSdtmigVersionDatasetsDatasetGet(version, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTMIG Dataset Variable List
     * @param {string} version CDISC Library Product Version
     * @param {string} dataset SDTMIG Dataset Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmigVersionDatasetsDatasetVariablesGet(version: string, dataset: string, options?: RawAxiosRequestConfig) {
        return SDTMImplementationGuideSDTMIGApiFp(this.configuration).mdrSdtmigVersionDatasetsDatasetVariablesGet(version, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTMIG Dataset Variable
     * @param {string} version CDISC Library Product Version
     * @param {string} dataset SDTMIG Dataset Identifier
     * @param {string} _var SDTMIG Variable Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmigVersionDatasetsDatasetVariablesVarGet(version: string, dataset: string, _var: string, options?: RawAxiosRequestConfig) {
        return SDTMImplementationGuideSDTMIGApiFp(this.configuration).mdrSdtmigVersionDatasetsDatasetVariablesVarGet(version, dataset, _var, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTMIG Dataset List
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmigVersionDatasetsGet(version: string, options?: RawAxiosRequestConfig) {
        return SDTMImplementationGuideSDTMIGApiFp(this.configuration).mdrSdtmigVersionDatasetsGet(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTMIG product
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmigVersionGet(version: string, options?: RawAxiosRequestConfig) {
        return SDTMImplementationGuideSDTMIGApiFp(this.configuration).mdrSdtmigVersionGet(version, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SENDImplementationGuideSENDIGApi - axios parameter creator
 */
export const SENDImplementationGuideSENDIGApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Root SENDIG Dataset Variable
         * @param {string} dataset SENDIG Dataset Identifier
         * @param {string} _var SENDIG Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootSendigDatasetsDatasetVariablesVarGet: async (dataset: string, _var: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('mdrRootSendigDatasetsDatasetVariablesVarGet', 'dataset', dataset)
            // verify required parameter '_var' is not null or undefined
            assertParamExists('mdrRootSendigDatasetsDatasetVariablesVarGet', '_var', _var)
            const localVarPath = `/mdr/root/sendig/datasets/{dataset}/variables/{var}`
                .replace(`{${"dataset"}}`, encodeURIComponent(String(dataset)))
                .replace(`{${"var"}}`, encodeURIComponent(String(_var)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SENDIG Class Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SENDIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionClassesClassDatasetsGet: async (version: string, _class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSendigVersionClassesClassDatasetsGet', 'version', version)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrSendigVersionClassesClassDatasetsGet', '_class', _class)
            const localVarPath = `/mdr/sendig/{version}/classes/{class}/datasets`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SENDIG Class
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SENDIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionClassesClassGet: async (version: string, _class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSendigVersionClassesClassGet', 'version', version)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrSendigVersionClassesClassGet', '_class', _class)
            const localVarPath = `/mdr/sendig/{version}/classes/{class}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SENDIG Class List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionClassesGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSendigVersionClassesGet', 'version', version)
            const localVarPath = `/mdr/sendig/{version}/classes`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SENDIG Dataset
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SENDIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionDatasetsDatasetGet: async (version: string, dataset: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSendigVersionDatasetsDatasetGet', 'version', version)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('mdrSendigVersionDatasetsDatasetGet', 'dataset', dataset)
            const localVarPath = `/mdr/sendig/{version}/datasets/{dataset}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"dataset"}}`, encodeURIComponent(String(dataset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SENDIG Dataset Variable List
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SENDIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionDatasetsDatasetVariablesGet: async (version: string, dataset: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSendigVersionDatasetsDatasetVariablesGet', 'version', version)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('mdrSendigVersionDatasetsDatasetVariablesGet', 'dataset', dataset)
            const localVarPath = `/mdr/sendig/{version}/datasets/{dataset}/variables`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"dataset"}}`, encodeURIComponent(String(dataset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SENDIG Dataset Variable
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SENDIG Class Identifier
         * @param {string} _var SENDIG Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionDatasetsDatasetVariablesVarGet: async (version: string, dataset: string, _var: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSendigVersionDatasetsDatasetVariablesVarGet', 'version', version)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('mdrSendigVersionDatasetsDatasetVariablesVarGet', 'dataset', dataset)
            // verify required parameter '_var' is not null or undefined
            assertParamExists('mdrSendigVersionDatasetsDatasetVariablesVarGet', '_var', _var)
            const localVarPath = `/mdr/sendig/{version}/datasets/{dataset}/variables/{var}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"dataset"}}`, encodeURIComponent(String(dataset)))
                .replace(`{${"var"}}`, encodeURIComponent(String(_var)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SENDIG Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionDatasetsGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSendigVersionDatasetsGet', 'version', version)
            const localVarPath = `/mdr/sendig/{version}/datasets`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SENDIG product
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSendigVersionGet', 'version', version)
            const localVarPath = `/mdr/sendig/{version}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SENDImplementationGuideSENDIGApi - functional programming interface
 */
export const SENDImplementationGuideSENDIGApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SENDImplementationGuideSENDIGApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Root SENDIG Dataset Variable
         * @param {string} dataset SENDIG Dataset Identifier
         * @param {string} _var SENDIG Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrRootSendigDatasetsDatasetVariablesVarGet(dataset: string, _var: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootSendigDatasetVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrRootSendigDatasetsDatasetVariablesVarGet(dataset, _var, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SENDImplementationGuideSENDIGApi.mdrRootSendigDatasetsDatasetVariablesVarGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SENDIG Class Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SENDIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSendigVersionClassesClassDatasetsGet(version: string, _class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendigClassDatasets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSendigVersionClassesClassDatasetsGet(version, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SENDImplementationGuideSENDIGApi.mdrSendigVersionClassesClassDatasetsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SENDIG Class
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SENDIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSendigVersionClassesClassGet(version: string, _class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendigClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSendigVersionClassesClassGet(version, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SENDImplementationGuideSENDIGApi.mdrSendigVersionClassesClassGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SENDIG Class List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSendigVersionClassesGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendigClasses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSendigVersionClassesGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SENDImplementationGuideSENDIGApi.mdrSendigVersionClassesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SENDIG Dataset
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SENDIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSendigVersionDatasetsDatasetGet(version: string, dataset: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendigDataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSendigVersionDatasetsDatasetGet(version, dataset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SENDImplementationGuideSENDIGApi.mdrSendigVersionDatasetsDatasetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SENDIG Dataset Variable List
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SENDIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSendigVersionDatasetsDatasetVariablesGet(version: string, dataset: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendigDatasetVariables>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSendigVersionDatasetsDatasetVariablesGet(version, dataset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SENDImplementationGuideSENDIGApi.mdrSendigVersionDatasetsDatasetVariablesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SENDIG Dataset Variable
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SENDIG Class Identifier
         * @param {string} _var SENDIG Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSendigVersionDatasetsDatasetVariablesVarGet(version: string, dataset: string, _var: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendigDatasetVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSendigVersionDatasetsDatasetVariablesVarGet(version, dataset, _var, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SENDImplementationGuideSENDIGApi.mdrSendigVersionDatasetsDatasetVariablesVarGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SENDIG Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSendigVersionDatasetsGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendigDatasets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSendigVersionDatasetsGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SENDImplementationGuideSENDIGApi.mdrSendigVersionDatasetsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SENDIG product
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSendigVersionGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendigProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSendigVersionGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SENDImplementationGuideSENDIGApi.mdrSendigVersionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SENDImplementationGuideSENDIGApi - factory interface
 */
export const SENDImplementationGuideSENDIGApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SENDImplementationGuideSENDIGApiFp(configuration)
    return {
        /**
         * Get Root SENDIG Dataset Variable
         * @param {string} dataset SENDIG Dataset Identifier
         * @param {string} _var SENDIG Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootSendigDatasetsDatasetVariablesVarGet(dataset: string, _var: string, options?: RawAxiosRequestConfig): AxiosPromise<RootSendigDatasetVariable> {
            return localVarFp.mdrRootSendigDatasetsDatasetVariablesVarGet(dataset, _var, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SENDIG Class Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SENDIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionClassesClassDatasetsGet(version: string, _class: string, options?: RawAxiosRequestConfig): AxiosPromise<SendigClassDatasets> {
            return localVarFp.mdrSendigVersionClassesClassDatasetsGet(version, _class, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SENDIG Class
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SENDIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionClassesClassGet(version: string, _class: string, options?: RawAxiosRequestConfig): AxiosPromise<SendigClass> {
            return localVarFp.mdrSendigVersionClassesClassGet(version, _class, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SENDIG Class List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionClassesGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<SendigClasses> {
            return localVarFp.mdrSendigVersionClassesGet(version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SENDIG Dataset
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SENDIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionDatasetsDatasetGet(version: string, dataset: string, options?: RawAxiosRequestConfig): AxiosPromise<SendigDataset> {
            return localVarFp.mdrSendigVersionDatasetsDatasetGet(version, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SENDIG Dataset Variable List
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SENDIG Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionDatasetsDatasetVariablesGet(version: string, dataset: string, options?: RawAxiosRequestConfig): AxiosPromise<SendigDatasetVariables> {
            return localVarFp.mdrSendigVersionDatasetsDatasetVariablesGet(version, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SENDIG Dataset Variable
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SENDIG Class Identifier
         * @param {string} _var SENDIG Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionDatasetsDatasetVariablesVarGet(version: string, dataset: string, _var: string, options?: RawAxiosRequestConfig): AxiosPromise<SendigDatasetVariable> {
            return localVarFp.mdrSendigVersionDatasetsDatasetVariablesVarGet(version, dataset, _var, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SENDIG Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionDatasetsGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<SendigDatasets> {
            return localVarFp.mdrSendigVersionDatasetsGet(version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SENDIG product
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSendigVersionGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<SendigProduct> {
            return localVarFp.mdrSendigVersionGet(version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SENDImplementationGuideSENDIGApi - object-oriented interface
 */
export class SENDImplementationGuideSENDIGApi extends BaseAPI {
    /**
     * Get Root SENDIG Dataset Variable
     * @param {string} dataset SENDIG Dataset Identifier
     * @param {string} _var SENDIG Variable Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrRootSendigDatasetsDatasetVariablesVarGet(dataset: string, _var: string, options?: RawAxiosRequestConfig) {
        return SENDImplementationGuideSENDIGApiFp(this.configuration).mdrRootSendigDatasetsDatasetVariablesVarGet(dataset, _var, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SENDIG Class Dataset List
     * @param {string} version CDISC Library Product Version
     * @param {string} _class SENDIG Class Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSendigVersionClassesClassDatasetsGet(version: string, _class: string, options?: RawAxiosRequestConfig) {
        return SENDImplementationGuideSENDIGApiFp(this.configuration).mdrSendigVersionClassesClassDatasetsGet(version, _class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SENDIG Class
     * @param {string} version CDISC Library Product Version
     * @param {string} _class SENDIG Class Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSendigVersionClassesClassGet(version: string, _class: string, options?: RawAxiosRequestConfig) {
        return SENDImplementationGuideSENDIGApiFp(this.configuration).mdrSendigVersionClassesClassGet(version, _class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SENDIG Class List
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSendigVersionClassesGet(version: string, options?: RawAxiosRequestConfig) {
        return SENDImplementationGuideSENDIGApiFp(this.configuration).mdrSendigVersionClassesGet(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SENDIG Dataset
     * @param {string} version CDISC Library Product Version
     * @param {string} dataset SENDIG Class Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSendigVersionDatasetsDatasetGet(version: string, dataset: string, options?: RawAxiosRequestConfig) {
        return SENDImplementationGuideSENDIGApiFp(this.configuration).mdrSendigVersionDatasetsDatasetGet(version, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SENDIG Dataset Variable List
     * @param {string} version CDISC Library Product Version
     * @param {string} dataset SENDIG Class Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSendigVersionDatasetsDatasetVariablesGet(version: string, dataset: string, options?: RawAxiosRequestConfig) {
        return SENDImplementationGuideSENDIGApiFp(this.configuration).mdrSendigVersionDatasetsDatasetVariablesGet(version, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SENDIG Dataset Variable
     * @param {string} version CDISC Library Product Version
     * @param {string} dataset SENDIG Class Identifier
     * @param {string} _var SENDIG Variable Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSendigVersionDatasetsDatasetVariablesVarGet(version: string, dataset: string, _var: string, options?: RawAxiosRequestConfig) {
        return SENDImplementationGuideSENDIGApiFp(this.configuration).mdrSendigVersionDatasetsDatasetVariablesVarGet(version, dataset, _var, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SENDIG Dataset List
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSendigVersionDatasetsGet(version: string, options?: RawAxiosRequestConfig) {
        return SENDImplementationGuideSENDIGApiFp(this.configuration).mdrSendigVersionDatasetsGet(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SENDIG product
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSendigVersionGet(version: string, options?: RawAxiosRequestConfig) {
        return SENDImplementationGuideSENDIGApiFp(this.configuration).mdrSendigVersionGet(version, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SearchesApi - axios parameter creator
 */
export const SearchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Search Results Across CDISC Library
         * @param {string} q Search Term Expression
         * @param {string} [highlight] Search Highlight Expression
         * @param {number} [start] Initial Search Result Index
         * @param {number} [pageSize] Number of Search Results to Return
         * @param {string} [_class] Limit Search by Setting Scope to Class
         * @param {string} [codelist] Limit Search by Setting Scope to Codelist
         * @param {string} [conceptId] Limit Search by Setting Scope to Concept ID
         * @param {string} [core] Limit Search by Setting Scope to Core
         * @param {string} [dataStructure] Limit Search by Setting Scope to Data Structure
         * @param {string} [datasetStructure] Limit Search by Setting Scope to Dataset Structure
         * @param {string} [definition] Limit Search by Setting Scope to Definition
         * @param {string} [description] Limit Search by Setting Scope to Description
         * @param {string} [domain] Limit Search by Setting Scope to Domain
         * @param {string} [effectiveDate] Limit Search by Setting Scope to Effective Date
         * @param {string} [extensible] Limit Search by Setting Scope to Extensible
         * @param {string} [href] Limit Search by Setting Scope to Href
         * @param {string} [label] Limit Search by Setting Scope to Label
         * @param {string} [measureType] SLimit Search by Setting Scope to Measure Type
         * @param {string} [name] Limit Search by Setting Scope to Name
         * @param {string} [preferredTerm] Limit Search by Setting Scope to Preferred Term
         * @param {string} [product] Limit Search by Setting Scope to Product
         * @param {string} [productGroup] Limit Search by Setting Scope to Product Group
         * @param {string} [registrationStatus] Limit Search by Setting Scope to Registration Status
         * @param {string} [roleDescription] Limit Search by Setting Scope to Role Description
         * @param {string} [sdtmTarget] Limit Search by Setting Scope to SDTM Target
         * @param {string} [simpleDatatype] Limit Search by Setting Scope to Simple Datatype
         * @param {string} [submissionValue] Limit Search by Setting Scope to Submission Value
         * @param {string} [synonyms] Limit Search by Setting Scope to Synonyms
         * @param {string} [type] Limit Search by Setting Scope to Type
         * @param {string} [uiHref] Limit Search by Setting Scope to UI Href
         * @param {string} [valueDomain] Limit Search by Setting Scope to Value Domain
         * @param {string} [variableSet] Limit Search by Setting Scope to Variable Set
         * @param {string} [version] Limit Search by Setting Scope to Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSearchGet: async (q: string, highlight?: string, start?: number, pageSize?: number, _class?: string, codelist?: string, conceptId?: string, core?: string, dataStructure?: string, datasetStructure?: string, definition?: string, description?: string, domain?: string, effectiveDate?: string, extensible?: string, href?: string, label?: string, measureType?: string, name?: string, preferredTerm?: string, product?: string, productGroup?: string, registrationStatus?: string, roleDescription?: string, sdtmTarget?: string, simpleDatatype?: string, submissionValue?: string, synonyms?: string, type?: string, uiHref?: string, valueDomain?: string, variableSet?: string, version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('mdrSearchGet', 'q', q)
            const localVarPath = `/mdr/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (highlight !== undefined) {
                localVarQueryParameter['highlight'] = highlight;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (_class !== undefined) {
                localVarQueryParameter['class'] = _class;
            }

            if (codelist !== undefined) {
                localVarQueryParameter['codelist'] = codelist;
            }

            if (conceptId !== undefined) {
                localVarQueryParameter['conceptId'] = conceptId;
            }

            if (core !== undefined) {
                localVarQueryParameter['core'] = core;
            }

            if (dataStructure !== undefined) {
                localVarQueryParameter['dataStructure'] = dataStructure;
            }

            if (datasetStructure !== undefined) {
                localVarQueryParameter['datasetStructure'] = datasetStructure;
            }

            if (definition !== undefined) {
                localVarQueryParameter['definition'] = definition;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }

            if (effectiveDate !== undefined) {
                localVarQueryParameter['effectiveDate'] = effectiveDate;
            }

            if (extensible !== undefined) {
                localVarQueryParameter['extensible'] = extensible;
            }

            if (href !== undefined) {
                localVarQueryParameter['href'] = href;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (measureType !== undefined) {
                localVarQueryParameter['measureType'] = measureType;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (preferredTerm !== undefined) {
                localVarQueryParameter['preferredTerm'] = preferredTerm;
            }

            if (product !== undefined) {
                localVarQueryParameter['product'] = product;
            }

            if (productGroup !== undefined) {
                localVarQueryParameter['productGroup'] = productGroup;
            }

            if (registrationStatus !== undefined) {
                localVarQueryParameter['registrationStatus'] = registrationStatus;
            }

            if (roleDescription !== undefined) {
                localVarQueryParameter['roleDescription'] = roleDescription;
            }

            if (sdtmTarget !== undefined) {
                localVarQueryParameter['sdtmTarget'] = sdtmTarget;
            }

            if (simpleDatatype !== undefined) {
                localVarQueryParameter['simpleDatatype'] = simpleDatatype;
            }

            if (submissionValue !== undefined) {
                localVarQueryParameter['submissionValue'] = submissionValue;
            }

            if (synonyms !== undefined) {
                localVarQueryParameter['synonyms'] = synonyms;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (uiHref !== undefined) {
                localVarQueryParameter['uiHref'] = uiHref;
            }

            if (valueDomain !== undefined) {
                localVarQueryParameter['valueDomain'] = valueDomain;
            }

            if (variableSet !== undefined) {
                localVarQueryParameter['variableSet'] = variableSet;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Search Results Across CDISC Library
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSearchScopesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mdr/search/scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Search Results Limited to Scope
         * @param {DefaultSearchScopes} scope Search Scope
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSearchScopesScopeGet: async (scope: DefaultSearchScopes, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('mdrSearchScopesScopeGet', 'scope', scope)
            const localVarPath = `/mdr/search/scopes/{scope}`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchesApi - functional programming interface
 */
export const SearchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Search Results Across CDISC Library
         * @param {string} q Search Term Expression
         * @param {string} [highlight] Search Highlight Expression
         * @param {number} [start] Initial Search Result Index
         * @param {number} [pageSize] Number of Search Results to Return
         * @param {string} [_class] Limit Search by Setting Scope to Class
         * @param {string} [codelist] Limit Search by Setting Scope to Codelist
         * @param {string} [conceptId] Limit Search by Setting Scope to Concept ID
         * @param {string} [core] Limit Search by Setting Scope to Core
         * @param {string} [dataStructure] Limit Search by Setting Scope to Data Structure
         * @param {string} [datasetStructure] Limit Search by Setting Scope to Dataset Structure
         * @param {string} [definition] Limit Search by Setting Scope to Definition
         * @param {string} [description] Limit Search by Setting Scope to Description
         * @param {string} [domain] Limit Search by Setting Scope to Domain
         * @param {string} [effectiveDate] Limit Search by Setting Scope to Effective Date
         * @param {string} [extensible] Limit Search by Setting Scope to Extensible
         * @param {string} [href] Limit Search by Setting Scope to Href
         * @param {string} [label] Limit Search by Setting Scope to Label
         * @param {string} [measureType] SLimit Search by Setting Scope to Measure Type
         * @param {string} [name] Limit Search by Setting Scope to Name
         * @param {string} [preferredTerm] Limit Search by Setting Scope to Preferred Term
         * @param {string} [product] Limit Search by Setting Scope to Product
         * @param {string} [productGroup] Limit Search by Setting Scope to Product Group
         * @param {string} [registrationStatus] Limit Search by Setting Scope to Registration Status
         * @param {string} [roleDescription] Limit Search by Setting Scope to Role Description
         * @param {string} [sdtmTarget] Limit Search by Setting Scope to SDTM Target
         * @param {string} [simpleDatatype] Limit Search by Setting Scope to Simple Datatype
         * @param {string} [submissionValue] Limit Search by Setting Scope to Submission Value
         * @param {string} [synonyms] Limit Search by Setting Scope to Synonyms
         * @param {string} [type] Limit Search by Setting Scope to Type
         * @param {string} [uiHref] Limit Search by Setting Scope to UI Href
         * @param {string} [valueDomain] Limit Search by Setting Scope to Value Domain
         * @param {string} [variableSet] Limit Search by Setting Scope to Variable Set
         * @param {string} [version] Limit Search by Setting Scope to Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSearchGet(q: string, highlight?: string, start?: number, pageSize?: number, _class?: string, codelist?: string, conceptId?: string, core?: string, dataStructure?: string, datasetStructure?: string, definition?: string, description?: string, domain?: string, effectiveDate?: string, extensible?: string, href?: string, label?: string, measureType?: string, name?: string, preferredTerm?: string, product?: string, productGroup?: string, registrationStatus?: string, roleDescription?: string, sdtmTarget?: string, simpleDatatype?: string, submissionValue?: string, synonyms?: string, type?: string, uiHref?: string, valueDomain?: string, variableSet?: string, version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSearchGet(q, highlight, start, pageSize, _class, codelist, conceptId, core, dataStructure, datasetStructure, definition, description, domain, effectiveDate, extensible, href, label, measureType, name, preferredTerm, product, productGroup, registrationStatus, roleDescription, sdtmTarget, simpleDatatype, submissionValue, synonyms, type, uiHref, valueDomain, variableSet, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchesApi.mdrSearchGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Search Results Across CDISC Library
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSearchScopesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MdrSearchScopesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSearchScopesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchesApi.mdrSearchScopesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Search Results Limited to Scope
         * @param {DefaultSearchScopes} scope Search Scope
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSearchScopesScopeGet(scope: DefaultSearchScopes, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScopeValues>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSearchScopesScopeGet(scope, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchesApi.mdrSearchScopesScopeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchesApi - factory interface
 */
export const SearchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchesApiFp(configuration)
    return {
        /**
         * Get Search Results Across CDISC Library
         * @param {string} q Search Term Expression
         * @param {string} [highlight] Search Highlight Expression
         * @param {number} [start] Initial Search Result Index
         * @param {number} [pageSize] Number of Search Results to Return
         * @param {string} [_class] Limit Search by Setting Scope to Class
         * @param {string} [codelist] Limit Search by Setting Scope to Codelist
         * @param {string} [conceptId] Limit Search by Setting Scope to Concept ID
         * @param {string} [core] Limit Search by Setting Scope to Core
         * @param {string} [dataStructure] Limit Search by Setting Scope to Data Structure
         * @param {string} [datasetStructure] Limit Search by Setting Scope to Dataset Structure
         * @param {string} [definition] Limit Search by Setting Scope to Definition
         * @param {string} [description] Limit Search by Setting Scope to Description
         * @param {string} [domain] Limit Search by Setting Scope to Domain
         * @param {string} [effectiveDate] Limit Search by Setting Scope to Effective Date
         * @param {string} [extensible] Limit Search by Setting Scope to Extensible
         * @param {string} [href] Limit Search by Setting Scope to Href
         * @param {string} [label] Limit Search by Setting Scope to Label
         * @param {string} [measureType] SLimit Search by Setting Scope to Measure Type
         * @param {string} [name] Limit Search by Setting Scope to Name
         * @param {string} [preferredTerm] Limit Search by Setting Scope to Preferred Term
         * @param {string} [product] Limit Search by Setting Scope to Product
         * @param {string} [productGroup] Limit Search by Setting Scope to Product Group
         * @param {string} [registrationStatus] Limit Search by Setting Scope to Registration Status
         * @param {string} [roleDescription] Limit Search by Setting Scope to Role Description
         * @param {string} [sdtmTarget] Limit Search by Setting Scope to SDTM Target
         * @param {string} [simpleDatatype] Limit Search by Setting Scope to Simple Datatype
         * @param {string} [submissionValue] Limit Search by Setting Scope to Submission Value
         * @param {string} [synonyms] Limit Search by Setting Scope to Synonyms
         * @param {string} [type] Limit Search by Setting Scope to Type
         * @param {string} [uiHref] Limit Search by Setting Scope to UI Href
         * @param {string} [valueDomain] Limit Search by Setting Scope to Value Domain
         * @param {string} [variableSet] Limit Search by Setting Scope to Variable Set
         * @param {string} [version] Limit Search by Setting Scope to Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSearchGet(q: string, highlight?: string, start?: number, pageSize?: number, _class?: string, codelist?: string, conceptId?: string, core?: string, dataStructure?: string, datasetStructure?: string, definition?: string, description?: string, domain?: string, effectiveDate?: string, extensible?: string, href?: string, label?: string, measureType?: string, name?: string, preferredTerm?: string, product?: string, productGroup?: string, registrationStatus?: string, roleDescription?: string, sdtmTarget?: string, simpleDatatype?: string, submissionValue?: string, synonyms?: string, type?: string, uiHref?: string, valueDomain?: string, variableSet?: string, version?: string, options?: RawAxiosRequestConfig): AxiosPromise<DefaultSearchResponse> {
            return localVarFp.mdrSearchGet(q, highlight, start, pageSize, _class, codelist, conceptId, core, dataStructure, datasetStructure, definition, description, domain, effectiveDate, extensible, href, label, measureType, name, preferredTerm, product, productGroup, registrationStatus, roleDescription, sdtmTarget, simpleDatatype, submissionValue, synonyms, type, uiHref, valueDomain, variableSet, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Search Results Across CDISC Library
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSearchScopesGet(options?: RawAxiosRequestConfig): AxiosPromise<MdrSearchScopesGet200Response> {
            return localVarFp.mdrSearchScopesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Search Results Limited to Scope
         * @param {DefaultSearchScopes} scope Search Scope
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSearchScopesScopeGet(scope: DefaultSearchScopes, options?: RawAxiosRequestConfig): AxiosPromise<ScopeValues> {
            return localVarFp.mdrSearchScopesScopeGet(scope, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchesApi - object-oriented interface
 */
export class SearchesApi extends BaseAPI {
    /**
     * Get Search Results Across CDISC Library
     * @param {string} q Search Term Expression
     * @param {string} [highlight] Search Highlight Expression
     * @param {number} [start] Initial Search Result Index
     * @param {number} [pageSize] Number of Search Results to Return
     * @param {string} [_class] Limit Search by Setting Scope to Class
     * @param {string} [codelist] Limit Search by Setting Scope to Codelist
     * @param {string} [conceptId] Limit Search by Setting Scope to Concept ID
     * @param {string} [core] Limit Search by Setting Scope to Core
     * @param {string} [dataStructure] Limit Search by Setting Scope to Data Structure
     * @param {string} [datasetStructure] Limit Search by Setting Scope to Dataset Structure
     * @param {string} [definition] Limit Search by Setting Scope to Definition
     * @param {string} [description] Limit Search by Setting Scope to Description
     * @param {string} [domain] Limit Search by Setting Scope to Domain
     * @param {string} [effectiveDate] Limit Search by Setting Scope to Effective Date
     * @param {string} [extensible] Limit Search by Setting Scope to Extensible
     * @param {string} [href] Limit Search by Setting Scope to Href
     * @param {string} [label] Limit Search by Setting Scope to Label
     * @param {string} [measureType] SLimit Search by Setting Scope to Measure Type
     * @param {string} [name] Limit Search by Setting Scope to Name
     * @param {string} [preferredTerm] Limit Search by Setting Scope to Preferred Term
     * @param {string} [product] Limit Search by Setting Scope to Product
     * @param {string} [productGroup] Limit Search by Setting Scope to Product Group
     * @param {string} [registrationStatus] Limit Search by Setting Scope to Registration Status
     * @param {string} [roleDescription] Limit Search by Setting Scope to Role Description
     * @param {string} [sdtmTarget] Limit Search by Setting Scope to SDTM Target
     * @param {string} [simpleDatatype] Limit Search by Setting Scope to Simple Datatype
     * @param {string} [submissionValue] Limit Search by Setting Scope to Submission Value
     * @param {string} [synonyms] Limit Search by Setting Scope to Synonyms
     * @param {string} [type] Limit Search by Setting Scope to Type
     * @param {string} [uiHref] Limit Search by Setting Scope to UI Href
     * @param {string} [valueDomain] Limit Search by Setting Scope to Value Domain
     * @param {string} [variableSet] Limit Search by Setting Scope to Variable Set
     * @param {string} [version] Limit Search by Setting Scope to Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSearchGet(q: string, highlight?: string, start?: number, pageSize?: number, _class?: string, codelist?: string, conceptId?: string, core?: string, dataStructure?: string, datasetStructure?: string, definition?: string, description?: string, domain?: string, effectiveDate?: string, extensible?: string, href?: string, label?: string, measureType?: string, name?: string, preferredTerm?: string, product?: string, productGroup?: string, registrationStatus?: string, roleDescription?: string, sdtmTarget?: string, simpleDatatype?: string, submissionValue?: string, synonyms?: string, type?: string, uiHref?: string, valueDomain?: string, variableSet?: string, version?: string, options?: RawAxiosRequestConfig) {
        return SearchesApiFp(this.configuration).mdrSearchGet(q, highlight, start, pageSize, _class, codelist, conceptId, core, dataStructure, datasetStructure, definition, description, domain, effectiveDate, extensible, href, label, measureType, name, preferredTerm, product, productGroup, registrationStatus, roleDescription, sdtmTarget, simpleDatatype, submissionValue, synonyms, type, uiHref, valueDomain, variableSet, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Search Results Across CDISC Library
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSearchScopesGet(options?: RawAxiosRequestConfig) {
        return SearchesApiFp(this.configuration).mdrSearchScopesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Search Results Limited to Scope
     * @param {DefaultSearchScopes} scope Search Scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSearchScopesScopeGet(scope: DefaultSearchScopes, options?: RawAxiosRequestConfig) {
        return SearchesApiFp(this.configuration).mdrSearchScopesScopeGet(scope, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusesApi - axios parameter creator
 */
export const StatusesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check health of system components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set maintenance mode and message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrMaintenanceGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mdr/maintenance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusesApi - functional programming interface
 */
export const StatusesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusesApiAxiosParamCreator(configuration)
    return {
        /**
         * Check health of system components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusesApi.healthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set maintenance mode and message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrMaintenanceGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrMaintenanceGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusesApi.mdrMaintenanceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusesApi - factory interface
 */
export const StatusesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusesApiFp(configuration)
    return {
        /**
         * Check health of system components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options?: RawAxiosRequestConfig): AxiosPromise<Health> {
            return localVarFp.healthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Set maintenance mode and message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrMaintenanceGet(options?: RawAxiosRequestConfig): AxiosPromise<MaintenanceBody> {
            return localVarFp.mdrMaintenanceGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusesApi - object-oriented interface
 */
export class StatusesApi extends BaseAPI {
    /**
     * Check health of system components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthGet(options?: RawAxiosRequestConfig) {
        return StatusesApiFp(this.configuration).healthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set maintenance mode and message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrMaintenanceGet(options?: RawAxiosRequestConfig) {
        return StatusesApiFp(this.configuration).mdrMaintenanceGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StudyDataTabulationModelSDTMApi - axios parameter creator
 */
export const StudyDataTabulationModelSDTMApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Root of SDTM Class Variable
         * @param {string} _class SDTM Class Identifier
         * @param {string} _var SDTM Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootSdtmClassesClassVariablesVarGet: async (_class: string, _var: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrRootSdtmClassesClassVariablesVarGet', '_class', _class)
            // verify required parameter '_var' is not null or undefined
            assertParamExists('mdrRootSdtmClassesClassVariablesVarGet', '_var', _var)
            const localVarPath = `/mdr/root/sdtm/classes/{class}/variables/{var}`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"var"}}`, encodeURIComponent(String(_var)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Root SDTM Dataset Variable
         * @param {string} dataset SDTM Dataset Identifier
         * @param {string} _var SDTM Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootSdtmDatasetsDatasetVariablesVarGet: async (dataset: string, _var: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('mdrRootSdtmDatasetsDatasetVariablesVarGet', 'dataset', dataset)
            // verify required parameter '_var' is not null or undefined
            assertParamExists('mdrRootSdtmDatasetsDatasetVariablesVarGet', '_var', _var)
            const localVarPath = `/mdr/root/sdtm/datasets/{dataset}/variables/{var}`
                .replace(`{${"dataset"}}`, encodeURIComponent(String(dataset)))
                .replace(`{${"var"}}`, encodeURIComponent(String(_var)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTM Class Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTM Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionClassesClassDatasetsGet: async (version: string, _class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmVersionClassesClassDatasetsGet', 'version', version)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrSdtmVersionClassesClassDatasetsGet', '_class', _class)
            const localVarPath = `/mdr/sdtm/{version}/classes/{class}/datasets`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTM Class
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTM Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionClassesClassGet: async (version: string, _class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmVersionClassesClassGet', 'version', version)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrSdtmVersionClassesClassGet', '_class', _class)
            const localVarPath = `/mdr/sdtm/{version}/classes/{class}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTM Class Variable List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTM Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionClassesClassVariablesGet: async (version: string, _class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmVersionClassesClassVariablesGet', 'version', version)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrSdtmVersionClassesClassVariablesGet', '_class', _class)
            const localVarPath = `/mdr/sdtm/{version}/classes/{class}/variables`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTM Class Variable
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTM Class Identifier
         * @param {string} _var SDTM Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionClassesClassVariablesVarGet: async (version: string, _class: string, _var: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmVersionClassesClassVariablesVarGet', 'version', version)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('mdrSdtmVersionClassesClassVariablesVarGet', '_class', _class)
            // verify required parameter '_var' is not null or undefined
            assertParamExists('mdrSdtmVersionClassesClassVariablesVarGet', '_var', _var)
            const localVarPath = `/mdr/sdtm/{version}/classes/{class}/variables/{var}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"var"}}`, encodeURIComponent(String(_var)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTM Class List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionClassesGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmVersionClassesGet', 'version', version)
            const localVarPath = `/mdr/sdtm/{version}/classes`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTM Dataset
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTM Dataset Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionDatasetsDatasetGet: async (version: string, dataset: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmVersionDatasetsDatasetGet', 'version', version)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('mdrSdtmVersionDatasetsDatasetGet', 'dataset', dataset)
            const localVarPath = `/mdr/sdtm/{version}/datasets/{dataset}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"dataset"}}`, encodeURIComponent(String(dataset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTM Dataset Variable List
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTM Dataset Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionDatasetsDatasetVariablesGet: async (version: string, dataset: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmVersionDatasetsDatasetVariablesGet', 'version', version)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('mdrSdtmVersionDatasetsDatasetVariablesGet', 'dataset', dataset)
            const localVarPath = `/mdr/sdtm/{version}/datasets/{dataset}/variables`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"dataset"}}`, encodeURIComponent(String(dataset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTM Dataset Variable
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTM Dataset Identifier
         * @param {string} _var SDTM Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionDatasetsDatasetVariablesVarGet: async (version: string, dataset: string, _var: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmVersionDatasetsDatasetVariablesVarGet', 'version', version)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('mdrSdtmVersionDatasetsDatasetVariablesVarGet', 'dataset', dataset)
            // verify required parameter '_var' is not null or undefined
            assertParamExists('mdrSdtmVersionDatasetsDatasetVariablesVarGet', '_var', _var)
            const localVarPath = `/mdr/sdtm/{version}/datasets/{dataset}/variables/{var}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"dataset"}}`, encodeURIComponent(String(dataset)))
                .replace(`{${"var"}}`, encodeURIComponent(String(_var)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTM Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionDatasetsGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmVersionDatasetsGet', 'version', version)
            const localVarPath = `/mdr/sdtm/{version}/datasets`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDTM product
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionGet: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('mdrSdtmVersionGet', 'version', version)
            const localVarPath = `/mdr/sdtm/{version}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudyDataTabulationModelSDTMApi - functional programming interface
 */
export const StudyDataTabulationModelSDTMApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudyDataTabulationModelSDTMApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Root of SDTM Class Variable
         * @param {string} _class SDTM Class Identifier
         * @param {string} _var SDTM Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrRootSdtmClassesClassVariablesVarGet(_class: string, _var: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootSdtmClassVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrRootSdtmClassesClassVariablesVarGet(_class, _var, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyDataTabulationModelSDTMApi.mdrRootSdtmClassesClassVariablesVarGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Root SDTM Dataset Variable
         * @param {string} dataset SDTM Dataset Identifier
         * @param {string} _var SDTM Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrRootSdtmDatasetsDatasetVariablesVarGet(dataset: string, _var: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootSdtmDatasetVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrRootSdtmDatasetsDatasetVariablesVarGet(dataset, _var, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyDataTabulationModelSDTMApi.mdrRootSdtmDatasetsDatasetVariablesVarGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTM Class Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTM Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmVersionClassesClassDatasetsGet(version: string, _class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmClassDatasets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmVersionClassesClassDatasetsGet(version, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyDataTabulationModelSDTMApi.mdrSdtmVersionClassesClassDatasetsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTM Class
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTM Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmVersionClassesClassGet(version: string, _class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmVersionClassesClassGet(version, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyDataTabulationModelSDTMApi.mdrSdtmVersionClassesClassGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTM Class Variable List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTM Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmVersionClassesClassVariablesGet(version: string, _class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmClassVariables>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmVersionClassesClassVariablesGet(version, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyDataTabulationModelSDTMApi.mdrSdtmVersionClassesClassVariablesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTM Class Variable
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTM Class Identifier
         * @param {string} _var SDTM Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmVersionClassesClassVariablesVarGet(version: string, _class: string, _var: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmClassVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmVersionClassesClassVariablesVarGet(version, _class, _var, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyDataTabulationModelSDTMApi.mdrSdtmVersionClassesClassVariablesVarGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTM Class List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmVersionClassesGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmClasses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmVersionClassesGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyDataTabulationModelSDTMApi.mdrSdtmVersionClassesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTM Dataset
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTM Dataset Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmVersionDatasetsDatasetGet(version: string, dataset: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmDataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmVersionDatasetsDatasetGet(version, dataset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyDataTabulationModelSDTMApi.mdrSdtmVersionDatasetsDatasetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTM Dataset Variable List
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTM Dataset Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmVersionDatasetsDatasetVariablesGet(version: string, dataset: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmDatasetVariables>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmVersionDatasetsDatasetVariablesGet(version, dataset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyDataTabulationModelSDTMApi.mdrSdtmVersionDatasetsDatasetVariablesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTM Dataset Variable
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTM Dataset Identifier
         * @param {string} _var SDTM Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmVersionDatasetsDatasetVariablesVarGet(version: string, dataset: string, _var: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmDatasetVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmVersionDatasetsDatasetVariablesVarGet(version, dataset, _var, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyDataTabulationModelSDTMApi.mdrSdtmVersionDatasetsDatasetVariablesVarGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTM Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmVersionDatasetsGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmDatasets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmVersionDatasetsGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyDataTabulationModelSDTMApi.mdrSdtmVersionDatasetsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDTM product
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdrSdtmVersionGet(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdtmProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdrSdtmVersionGet(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudyDataTabulationModelSDTMApi.mdrSdtmVersionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StudyDataTabulationModelSDTMApi - factory interface
 */
export const StudyDataTabulationModelSDTMApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudyDataTabulationModelSDTMApiFp(configuration)
    return {
        /**
         * Get Root of SDTM Class Variable
         * @param {string} _class SDTM Class Identifier
         * @param {string} _var SDTM Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootSdtmClassesClassVariablesVarGet(_class: string, _var: string, options?: RawAxiosRequestConfig): AxiosPromise<RootSdtmClassVariable> {
            return localVarFp.mdrRootSdtmClassesClassVariablesVarGet(_class, _var, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Root SDTM Dataset Variable
         * @param {string} dataset SDTM Dataset Identifier
         * @param {string} _var SDTM Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrRootSdtmDatasetsDatasetVariablesVarGet(dataset: string, _var: string, options?: RawAxiosRequestConfig): AxiosPromise<RootSdtmDatasetVariable> {
            return localVarFp.mdrRootSdtmDatasetsDatasetVariablesVarGet(dataset, _var, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTM Class Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTM Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionClassesClassDatasetsGet(version: string, _class: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmClassDatasets> {
            return localVarFp.mdrSdtmVersionClassesClassDatasetsGet(version, _class, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTM Class
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTM Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionClassesClassGet(version: string, _class: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmClass> {
            return localVarFp.mdrSdtmVersionClassesClassGet(version, _class, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTM Class Variable List
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTM Class Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionClassesClassVariablesGet(version: string, _class: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmClassVariables> {
            return localVarFp.mdrSdtmVersionClassesClassVariablesGet(version, _class, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTM Class Variable
         * @param {string} version CDISC Library Product Version
         * @param {string} _class SDTM Class Identifier
         * @param {string} _var SDTM Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionClassesClassVariablesVarGet(version: string, _class: string, _var: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmClassVariable> {
            return localVarFp.mdrSdtmVersionClassesClassVariablesVarGet(version, _class, _var, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTM Class List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionClassesGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmClasses> {
            return localVarFp.mdrSdtmVersionClassesGet(version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTM Dataset
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTM Dataset Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionDatasetsDatasetGet(version: string, dataset: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmDataset> {
            return localVarFp.mdrSdtmVersionDatasetsDatasetGet(version, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTM Dataset Variable List
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTM Dataset Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionDatasetsDatasetVariablesGet(version: string, dataset: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmDatasetVariables> {
            return localVarFp.mdrSdtmVersionDatasetsDatasetVariablesGet(version, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTM Dataset Variable
         * @param {string} version CDISC Library Product Version
         * @param {string} dataset SDTM Dataset Identifier
         * @param {string} _var SDTM Variable Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionDatasetsDatasetVariablesVarGet(version: string, dataset: string, _var: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmDatasetVariable> {
            return localVarFp.mdrSdtmVersionDatasetsDatasetVariablesVarGet(version, dataset, _var, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTM Dataset List
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionDatasetsGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmDatasets> {
            return localVarFp.mdrSdtmVersionDatasetsGet(version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDTM product
         * @param {string} version CDISC Library Product Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdrSdtmVersionGet(version: string, options?: RawAxiosRequestConfig): AxiosPromise<SdtmProduct> {
            return localVarFp.mdrSdtmVersionGet(version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudyDataTabulationModelSDTMApi - object-oriented interface
 */
export class StudyDataTabulationModelSDTMApi extends BaseAPI {
    /**
     * Get Root of SDTM Class Variable
     * @param {string} _class SDTM Class Identifier
     * @param {string} _var SDTM Variable Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrRootSdtmClassesClassVariablesVarGet(_class: string, _var: string, options?: RawAxiosRequestConfig) {
        return StudyDataTabulationModelSDTMApiFp(this.configuration).mdrRootSdtmClassesClassVariablesVarGet(_class, _var, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Root SDTM Dataset Variable
     * @param {string} dataset SDTM Dataset Identifier
     * @param {string} _var SDTM Variable Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrRootSdtmDatasetsDatasetVariablesVarGet(dataset: string, _var: string, options?: RawAxiosRequestConfig) {
        return StudyDataTabulationModelSDTMApiFp(this.configuration).mdrRootSdtmDatasetsDatasetVariablesVarGet(dataset, _var, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTM Class Dataset List
     * @param {string} version CDISC Library Product Version
     * @param {string} _class SDTM Class Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmVersionClassesClassDatasetsGet(version: string, _class: string, options?: RawAxiosRequestConfig) {
        return StudyDataTabulationModelSDTMApiFp(this.configuration).mdrSdtmVersionClassesClassDatasetsGet(version, _class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTM Class
     * @param {string} version CDISC Library Product Version
     * @param {string} _class SDTM Class Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmVersionClassesClassGet(version: string, _class: string, options?: RawAxiosRequestConfig) {
        return StudyDataTabulationModelSDTMApiFp(this.configuration).mdrSdtmVersionClassesClassGet(version, _class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTM Class Variable List
     * @param {string} version CDISC Library Product Version
     * @param {string} _class SDTM Class Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmVersionClassesClassVariablesGet(version: string, _class: string, options?: RawAxiosRequestConfig) {
        return StudyDataTabulationModelSDTMApiFp(this.configuration).mdrSdtmVersionClassesClassVariablesGet(version, _class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTM Class Variable
     * @param {string} version CDISC Library Product Version
     * @param {string} _class SDTM Class Identifier
     * @param {string} _var SDTM Variable Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmVersionClassesClassVariablesVarGet(version: string, _class: string, _var: string, options?: RawAxiosRequestConfig) {
        return StudyDataTabulationModelSDTMApiFp(this.configuration).mdrSdtmVersionClassesClassVariablesVarGet(version, _class, _var, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTM Class List
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmVersionClassesGet(version: string, options?: RawAxiosRequestConfig) {
        return StudyDataTabulationModelSDTMApiFp(this.configuration).mdrSdtmVersionClassesGet(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTM Dataset
     * @param {string} version CDISC Library Product Version
     * @param {string} dataset SDTM Dataset Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmVersionDatasetsDatasetGet(version: string, dataset: string, options?: RawAxiosRequestConfig) {
        return StudyDataTabulationModelSDTMApiFp(this.configuration).mdrSdtmVersionDatasetsDatasetGet(version, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTM Dataset Variable List
     * @param {string} version CDISC Library Product Version
     * @param {string} dataset SDTM Dataset Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmVersionDatasetsDatasetVariablesGet(version: string, dataset: string, options?: RawAxiosRequestConfig) {
        return StudyDataTabulationModelSDTMApiFp(this.configuration).mdrSdtmVersionDatasetsDatasetVariablesGet(version, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTM Dataset Variable
     * @param {string} version CDISC Library Product Version
     * @param {string} dataset SDTM Dataset Identifier
     * @param {string} _var SDTM Variable Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmVersionDatasetsDatasetVariablesVarGet(version: string, dataset: string, _var: string, options?: RawAxiosRequestConfig) {
        return StudyDataTabulationModelSDTMApiFp(this.configuration).mdrSdtmVersionDatasetsDatasetVariablesVarGet(version, dataset, _var, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTM Dataset List
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmVersionDatasetsGet(version: string, options?: RawAxiosRequestConfig) {
        return StudyDataTabulationModelSDTMApiFp(this.configuration).mdrSdtmVersionDatasetsGet(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDTM product
     * @param {string} version CDISC Library Product Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mdrSdtmVersionGet(version: string, options?: RawAxiosRequestConfig) {
        return StudyDataTabulationModelSDTMApiFp(this.configuration).mdrSdtmVersionGet(version, options).then((request) => request(this.axios, this.basePath));
    }
}



