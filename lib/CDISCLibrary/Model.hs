{-
   CDISC Library API

   REST API Documentation for CDISC Library in production server

   OpenAPI Version: 3.0.0
   CDISC Library API API version: 1.1.0
   Contact: cdisc_library_support@cdisc.org
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : CDISCLibrary.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module CDISCLibrary.Model where

import CDISCLibrary.Core
import CDISCLibrary.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Codelist
newtype Codelist = Codelist { unCodelist :: Text } deriving (P.Eq, P.Show)

-- ** ConceptId
newtype ConceptId = ConceptId { unConceptId :: Text } deriving (P.Eq, P.Show)

-- ** Core
newtype Core = Core { unCore :: Text } deriving (P.Eq, P.Show)

-- ** DataStructure
newtype DataStructure = DataStructure { unDataStructure :: Text } deriving (P.Eq, P.Show)

-- ** Dataset
newtype Dataset = Dataset { unDataset :: Text } deriving (P.Eq, P.Show)

-- ** DatasetStructure
newtype DatasetStructure = DatasetStructure { unDatasetStructure :: Text } deriving (P.Eq, P.Show)

-- ** Definition
newtype Definition = Definition { unDefinition :: Text } deriving (P.Eq, P.Show)

-- ** Description
newtype Description = Description { unDescription :: Text } deriving (P.Eq, P.Show)

-- ** Domain
newtype Domain = Domain { unDomain :: Text } deriving (P.Eq, P.Show)

-- ** EffectiveDate
newtype EffectiveDate = EffectiveDate { unEffectiveDate :: Text } deriving (P.Eq, P.Show)

-- ** Extensible
newtype Extensible = Extensible { unExtensible :: Text } deriving (P.Eq, P.Show)

-- ** Field
newtype Field = Field { unField :: Text } deriving (P.Eq, P.Show)

-- ** Highlight
newtype Highlight = Highlight { unHighlight :: Text } deriving (P.Eq, P.Show)

-- ** Href
newtype Href = Href { unHref :: Text } deriving (P.Eq, P.Show)

-- ** Item
newtype Item = Item { unItem :: Text } deriving (P.Eq, P.Show)

-- ** Label
newtype Label = Label { unLabel :: Text } deriving (P.Eq, P.Show)

-- ** Measure
newtype Measure = Measure { unMeasure :: Text } deriving (P.Eq, P.Show)

-- ** MeasureType
newtype MeasureType = MeasureType { unMeasureType :: Text } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** Package
newtype Package = Package { unPackage :: Text } deriving (P.Eq, P.Show)

-- ** PageSize
newtype PageSize = PageSize { unPageSize :: Double } deriving (P.Eq, P.Show)

-- ** ParamClass
newtype ParamClass = ParamClass { unParamClass :: Text } deriving (P.Eq, P.Show)

-- ** ParamType
newtype ParamType = ParamType { unParamType :: Text } deriving (P.Eq, P.Show)

-- ** PreferredTerm
newtype PreferredTerm = PreferredTerm { unPreferredTerm :: Text } deriving (P.Eq, P.Show)

-- ** Product
newtype Product = Product { unProduct :: Text } deriving (P.Eq, P.Show)

-- ** ProductGroup
newtype ProductGroup = ProductGroup { unProductGroup :: Text } deriving (P.Eq, P.Show)

-- ** Q
newtype Q = Q { unQ :: Text } deriving (P.Eq, P.Show)

-- ** RegistrationStatus
newtype RegistrationStatus = RegistrationStatus { unRegistrationStatus :: Text } deriving (P.Eq, P.Show)

-- ** Responsegroup
newtype Responsegroup = Responsegroup { unResponsegroup :: Text } deriving (P.Eq, P.Show)

-- ** RoleDescription
newtype RoleDescription = RoleDescription { unRoleDescription :: Text } deriving (P.Eq, P.Show)

-- ** Scenario
newtype Scenario = Scenario { unScenario :: Text } deriving (P.Eq, P.Show)

-- ** Scope
newtype Scope = Scope { unScope :: DefaultSearchScopes } deriving (P.Eq, P.Show)

-- ** SdtmTarget
newtype SdtmTarget = SdtmTarget { unSdtmTarget :: Text } deriving (P.Eq, P.Show)

-- ** SimpleDatatype
newtype SimpleDatatype = SimpleDatatype { unSimpleDatatype :: Text } deriving (P.Eq, P.Show)

-- ** Start
newtype Start = Start { unStart :: Double } deriving (P.Eq, P.Show)

-- ** Structure
newtype Structure = Structure { unStructure :: Text } deriving (P.Eq, P.Show)

-- ** SubmissionValue
newtype SubmissionValue = SubmissionValue { unSubmissionValue :: Text } deriving (P.Eq, P.Show)

-- ** Synonyms
newtype Synonyms = Synonyms { unSynonyms :: Text } deriving (P.Eq, P.Show)

-- ** Term
newtype Term = Term { unTerm :: Text } deriving (P.Eq, P.Show)

-- ** UiHref
newtype UiHref = UiHref { unUiHref :: Text } deriving (P.Eq, P.Show)

-- ** ValueDomain
newtype ValueDomain = ValueDomain { unValueDomain :: Text } deriving (P.Eq, P.Show)

-- ** Var
newtype Var = Var { unVar :: Text } deriving (P.Eq, P.Show)

-- ** VariableSet
newtype VariableSet = VariableSet { unVariableSet :: Text } deriving (P.Eq, P.Show)

-- ** Varset
newtype Varset = Varset { unVarset :: Text } deriving (P.Eq, P.Show)

-- ** Version
newtype Version = Version { unVersion :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** About
-- | About
data About = About
  { aboutLinks :: !(Maybe AboutLinks) -- ^ "_links"
  , aboutReleaseNotes :: !(Maybe Text) -- ^ "release-notes"
  , aboutApiDocumentation :: !(Maybe Text) -- ^ "api-documentation"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON About
instance A.FromJSON About where
  parseJSON = A.withObject "About" $ \o ->
    About
      <$> (o .:? "_links")
      <*> (o .:? "release-notes")
      <*> (o .:? "api-documentation")

-- | ToJSON About
instance A.ToJSON About where
  toJSON About {..} =
   _omitNulls
      [ "_links" .= aboutLinks
      , "release-notes" .= aboutReleaseNotes
      , "api-documentation" .= aboutApiDocumentation
      ]


-- | Construct a value of type 'About' (by applying it's required fields, if any)
mkAbout
  :: About
mkAbout =
  About
  { aboutLinks = Nothing
  , aboutReleaseNotes = Nothing
  , aboutApiDocumentation = Nothing
  }

-- ** AboutLinks
-- | AboutLinks
data AboutLinks = AboutLinks
  { aboutLinksSelf :: !(Maybe AboutRef) -- ^ "self"
  , aboutLinksLastupdated :: !(Maybe LastupdatedRef) -- ^ "lastupdated"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AboutLinks
instance A.FromJSON AboutLinks where
  parseJSON = A.withObject "AboutLinks" $ \o ->
    AboutLinks
      <$> (o .:? "self")
      <*> (o .:? "lastupdated")

-- | ToJSON AboutLinks
instance A.ToJSON AboutLinks where
  toJSON AboutLinks {..} =
   _omitNulls
      [ "self" .= aboutLinksSelf
      , "lastupdated" .= aboutLinksLastupdated
      ]


-- | Construct a value of type 'AboutLinks' (by applying it's required fields, if any)
mkAboutLinks
  :: AboutLinks
mkAboutLinks =
  AboutLinks
  { aboutLinksSelf = Nothing
  , aboutLinksLastupdated = Nothing
  }

-- ** AboutRef
-- | AboutRef
data AboutRef = AboutRef
  { aboutRefHref :: !(Maybe Text) -- ^ "href"
  , aboutRefTitle :: !(Maybe Text) -- ^ "title"
  , aboutRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AboutRef
instance A.FromJSON AboutRef where
  parseJSON = A.withObject "AboutRef" $ \o ->
    AboutRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON AboutRef
instance A.ToJSON AboutRef where
  toJSON AboutRef {..} =
   _omitNulls
      [ "href" .= aboutRefHref
      , "title" .= aboutRefTitle
      , "type" .= aboutRefType
      ]


-- | Construct a value of type 'AboutRef' (by applying it's required fields, if any)
mkAboutRef
  :: AboutRef
mkAboutRef =
  AboutRef
  { aboutRefHref = Nothing
  , aboutRefTitle = Nothing
  , aboutRefType = Nothing
  }

-- ** AdamDatastructure
-- | AdamDatastructure
data AdamDatastructure = AdamDatastructure
  { adamDatastructureOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , adamDatastructureName :: !(Maybe Text) -- ^ "name"
  , adamDatastructureLabel :: !(Maybe Text) -- ^ "label"
  , adamDatastructureDescription :: !(Maybe Text) -- ^ "description"
  , adamDatastructureClass :: !(Maybe Text) -- ^ "class"
  , adamDatastructureLinks :: !(Maybe AdamDatastructureLinks) -- ^ "_links"
  , adamDatastructureAnalysisVariableSets :: !(Maybe [AdamVarset]) -- ^ "analysisVariableSets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamDatastructure
instance A.FromJSON AdamDatastructure where
  parseJSON = A.withObject "AdamDatastructure" $ \o ->
    AdamDatastructure
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "class")
      <*> (o .:? "_links")
      <*> (o .:? "analysisVariableSets")

-- | ToJSON AdamDatastructure
instance A.ToJSON AdamDatastructure where
  toJSON AdamDatastructure {..} =
   _omitNulls
      [ "ordinal" .= adamDatastructureOrdinal
      , "name" .= adamDatastructureName
      , "label" .= adamDatastructureLabel
      , "description" .= adamDatastructureDescription
      , "class" .= adamDatastructureClass
      , "_links" .= adamDatastructureLinks
      , "analysisVariableSets" .= adamDatastructureAnalysisVariableSets
      ]


-- | Construct a value of type 'AdamDatastructure' (by applying it's required fields, if any)
mkAdamDatastructure
  :: AdamDatastructure
mkAdamDatastructure =
  AdamDatastructure
  { adamDatastructureOrdinal = Nothing
  , adamDatastructureName = Nothing
  , adamDatastructureLabel = Nothing
  , adamDatastructureDescription = Nothing
  , adamDatastructureClass = Nothing
  , adamDatastructureLinks = Nothing
  , adamDatastructureAnalysisVariableSets = Nothing
  }

-- ** AdamDatastructureLinks
-- | AdamDatastructureLinks
data AdamDatastructureLinks = AdamDatastructureLinks
  { adamDatastructureLinksSelf :: !(Maybe AdamDatastructureRef) -- ^ "self"
  , adamDatastructureLinksParentProduct :: !(Maybe AdamProductRef) -- ^ "parentProduct"
  , adamDatastructureLinksPriorVersion :: !(Maybe AdamDatastructureRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamDatastructureLinks
instance A.FromJSON AdamDatastructureLinks where
  parseJSON = A.withObject "AdamDatastructureLinks" $ \o ->
    AdamDatastructureLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "priorVersion")

-- | ToJSON AdamDatastructureLinks
instance A.ToJSON AdamDatastructureLinks where
  toJSON AdamDatastructureLinks {..} =
   _omitNulls
      [ "self" .= adamDatastructureLinksSelf
      , "parentProduct" .= adamDatastructureLinksParentProduct
      , "priorVersion" .= adamDatastructureLinksPriorVersion
      ]


-- | Construct a value of type 'AdamDatastructureLinks' (by applying it's required fields, if any)
mkAdamDatastructureLinks
  :: AdamDatastructureLinks
mkAdamDatastructureLinks =
  AdamDatastructureLinks
  { adamDatastructureLinksSelf = Nothing
  , adamDatastructureLinksParentProduct = Nothing
  , adamDatastructureLinksPriorVersion = Nothing
  }

-- ** AdamDatastructureRef
-- | AdamDatastructureRef
data AdamDatastructureRef = AdamDatastructureRef
  { adamDatastructureRefHref :: !(Maybe Text) -- ^ "href"
  , adamDatastructureRefTitle :: !(Maybe Text) -- ^ "title"
  , adamDatastructureRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamDatastructureRef
instance A.FromJSON AdamDatastructureRef where
  parseJSON = A.withObject "AdamDatastructureRef" $ \o ->
    AdamDatastructureRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON AdamDatastructureRef
instance A.ToJSON AdamDatastructureRef where
  toJSON AdamDatastructureRef {..} =
   _omitNulls
      [ "href" .= adamDatastructureRefHref
      , "title" .= adamDatastructureRefTitle
      , "type" .= adamDatastructureRefType
      ]


-- | Construct a value of type 'AdamDatastructureRef' (by applying it's required fields, if any)
mkAdamDatastructureRef
  :: AdamDatastructureRef
mkAdamDatastructureRef =
  AdamDatastructureRef
  { adamDatastructureRefHref = Nothing
  , adamDatastructureRefTitle = Nothing
  , adamDatastructureRefType = Nothing
  }

-- ** AdamDatastructureRefElement
-- | AdamDatastructureRefElement
data AdamDatastructureRefElement = AdamDatastructureRefElement
  { adamDatastructureRefElementHref :: !(Maybe Text) -- ^ "href"
  , adamDatastructureRefElementTitle :: !(Maybe Text) -- ^ "title"
  , adamDatastructureRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamDatastructureRefElement
instance A.FromJSON AdamDatastructureRefElement where
  parseJSON = A.withObject "AdamDatastructureRefElement" $ \o ->
    AdamDatastructureRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON AdamDatastructureRefElement
instance A.ToJSON AdamDatastructureRefElement where
  toJSON AdamDatastructureRefElement {..} =
   _omitNulls
      [ "href" .= adamDatastructureRefElementHref
      , "title" .= adamDatastructureRefElementTitle
      , "type" .= adamDatastructureRefElementType
      ]


-- | Construct a value of type 'AdamDatastructureRefElement' (by applying it's required fields, if any)
mkAdamDatastructureRefElement
  :: AdamDatastructureRefElement
mkAdamDatastructureRefElement =
  AdamDatastructureRefElement
  { adamDatastructureRefElementHref = Nothing
  , adamDatastructureRefElementTitle = Nothing
  , adamDatastructureRefElementType = Nothing
  }

-- ** AdamDatastructureVariables
-- | AdamDatastructureVariables
data AdamDatastructureVariables = AdamDatastructureVariables
  { adamDatastructureVariablesOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , adamDatastructureVariablesName :: !(Maybe Text) -- ^ "name"
  , adamDatastructureVariablesLabel :: !(Maybe Text) -- ^ "label"
  , adamDatastructureVariablesDescription :: !(Maybe Text) -- ^ "description"
  , adamDatastructureVariablesClass :: !(Maybe Text) -- ^ "class"
  , adamDatastructureVariablesLinks :: !(Maybe AdamDatastructureVariablesLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamDatastructureVariables
instance A.FromJSON AdamDatastructureVariables where
  parseJSON = A.withObject "AdamDatastructureVariables" $ \o ->
    AdamDatastructureVariables
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "class")
      <*> (o .:? "_links")

-- | ToJSON AdamDatastructureVariables
instance A.ToJSON AdamDatastructureVariables where
  toJSON AdamDatastructureVariables {..} =
   _omitNulls
      [ "ordinal" .= adamDatastructureVariablesOrdinal
      , "name" .= adamDatastructureVariablesName
      , "label" .= adamDatastructureVariablesLabel
      , "description" .= adamDatastructureVariablesDescription
      , "class" .= adamDatastructureVariablesClass
      , "_links" .= adamDatastructureVariablesLinks
      ]


-- | Construct a value of type 'AdamDatastructureVariables' (by applying it's required fields, if any)
mkAdamDatastructureVariables
  :: AdamDatastructureVariables
mkAdamDatastructureVariables =
  AdamDatastructureVariables
  { adamDatastructureVariablesOrdinal = Nothing
  , adamDatastructureVariablesName = Nothing
  , adamDatastructureVariablesLabel = Nothing
  , adamDatastructureVariablesDescription = Nothing
  , adamDatastructureVariablesClass = Nothing
  , adamDatastructureVariablesLinks = Nothing
  }

-- ** AdamDatastructureVariablesLinks
-- | AdamDatastructureVariablesLinks
data AdamDatastructureVariablesLinks = AdamDatastructureVariablesLinks
  { adamDatastructureVariablesLinksSelf :: !(Maybe AdamDatastructureVariablesRef) -- ^ "self"
  , adamDatastructureVariablesLinksParentProduct :: !(Maybe AdamProductRef) -- ^ "parentProduct"
  , adamDatastructureVariablesLinksPriorVersion :: !(Maybe AdamDatastructureVariablesRef) -- ^ "priorVersion"
  , adamDatastructureVariablesLinksAnalysisVariables :: !(Maybe [AdamVariableRefElement]) -- ^ "analysisVariables"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamDatastructureVariablesLinks
instance A.FromJSON AdamDatastructureVariablesLinks where
  parseJSON = A.withObject "AdamDatastructureVariablesLinks" $ \o ->
    AdamDatastructureVariablesLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "priorVersion")
      <*> (o .:? "analysisVariables")

-- | ToJSON AdamDatastructureVariablesLinks
instance A.ToJSON AdamDatastructureVariablesLinks where
  toJSON AdamDatastructureVariablesLinks {..} =
   _omitNulls
      [ "self" .= adamDatastructureVariablesLinksSelf
      , "parentProduct" .= adamDatastructureVariablesLinksParentProduct
      , "priorVersion" .= adamDatastructureVariablesLinksPriorVersion
      , "analysisVariables" .= adamDatastructureVariablesLinksAnalysisVariables
      ]


-- | Construct a value of type 'AdamDatastructureVariablesLinks' (by applying it's required fields, if any)
mkAdamDatastructureVariablesLinks
  :: AdamDatastructureVariablesLinks
mkAdamDatastructureVariablesLinks =
  AdamDatastructureVariablesLinks
  { adamDatastructureVariablesLinksSelf = Nothing
  , adamDatastructureVariablesLinksParentProduct = Nothing
  , adamDatastructureVariablesLinksPriorVersion = Nothing
  , adamDatastructureVariablesLinksAnalysisVariables = Nothing
  }

-- ** AdamDatastructureVariablesRef
-- | AdamDatastructureVariablesRef
data AdamDatastructureVariablesRef = AdamDatastructureVariablesRef
  { adamDatastructureVariablesRefHref :: !(Maybe Text) -- ^ "href"
  , adamDatastructureVariablesRefTitle :: !(Maybe Text) -- ^ "title"
  , adamDatastructureVariablesRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamDatastructureVariablesRef
instance A.FromJSON AdamDatastructureVariablesRef where
  parseJSON = A.withObject "AdamDatastructureVariablesRef" $ \o ->
    AdamDatastructureVariablesRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON AdamDatastructureVariablesRef
instance A.ToJSON AdamDatastructureVariablesRef where
  toJSON AdamDatastructureVariablesRef {..} =
   _omitNulls
      [ "href" .= adamDatastructureVariablesRefHref
      , "title" .= adamDatastructureVariablesRefTitle
      , "type" .= adamDatastructureVariablesRefType
      ]


-- | Construct a value of type 'AdamDatastructureVariablesRef' (by applying it's required fields, if any)
mkAdamDatastructureVariablesRef
  :: AdamDatastructureVariablesRef
mkAdamDatastructureVariablesRef =
  AdamDatastructureVariablesRef
  { adamDatastructureVariablesRefHref = Nothing
  , adamDatastructureVariablesRefTitle = Nothing
  , adamDatastructureVariablesRefType = Nothing
  }

-- ** AdamDatastructureVarsets
-- | AdamDatastructureVarsets
data AdamDatastructureVarsets = AdamDatastructureVarsets
  { adamDatastructureVarsetsOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , adamDatastructureVarsetsName :: !(Maybe Text) -- ^ "name"
  , adamDatastructureVarsetsLabel :: !(Maybe Text) -- ^ "label"
  , adamDatastructureVarsetsDescription :: !(Maybe Text) -- ^ "description"
  , adamDatastructureVarsetsClass :: !(Maybe Text) -- ^ "class"
  , adamDatastructureVarsetsLinks :: !(Maybe AdamDatastructureVarsetsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamDatastructureVarsets
instance A.FromJSON AdamDatastructureVarsets where
  parseJSON = A.withObject "AdamDatastructureVarsets" $ \o ->
    AdamDatastructureVarsets
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "class")
      <*> (o .:? "_links")

-- | ToJSON AdamDatastructureVarsets
instance A.ToJSON AdamDatastructureVarsets where
  toJSON AdamDatastructureVarsets {..} =
   _omitNulls
      [ "ordinal" .= adamDatastructureVarsetsOrdinal
      , "name" .= adamDatastructureVarsetsName
      , "label" .= adamDatastructureVarsetsLabel
      , "description" .= adamDatastructureVarsetsDescription
      , "class" .= adamDatastructureVarsetsClass
      , "_links" .= adamDatastructureVarsetsLinks
      ]


-- | Construct a value of type 'AdamDatastructureVarsets' (by applying it's required fields, if any)
mkAdamDatastructureVarsets
  :: AdamDatastructureVarsets
mkAdamDatastructureVarsets =
  AdamDatastructureVarsets
  { adamDatastructureVarsetsOrdinal = Nothing
  , adamDatastructureVarsetsName = Nothing
  , adamDatastructureVarsetsLabel = Nothing
  , adamDatastructureVarsetsDescription = Nothing
  , adamDatastructureVarsetsClass = Nothing
  , adamDatastructureVarsetsLinks = Nothing
  }

-- ** AdamDatastructureVarsetsLinks
-- | AdamDatastructureVarsetsLinks
data AdamDatastructureVarsetsLinks = AdamDatastructureVarsetsLinks
  { adamDatastructureVarsetsLinksSelf :: !(Maybe AdamDatastructureVarsetsRef) -- ^ "self"
  , adamDatastructureVarsetsLinksParentProduct :: !(Maybe AdamProductRef) -- ^ "parentProduct"
  , adamDatastructureVarsetsLinksPriorVersion :: !(Maybe AdamDatastructureVarsetsRef) -- ^ "priorVersion"
  , adamDatastructureVarsetsLinksAnalysisVariableSets :: !(Maybe [AdamVarsetRefElement]) -- ^ "analysisVariableSets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamDatastructureVarsetsLinks
instance A.FromJSON AdamDatastructureVarsetsLinks where
  parseJSON = A.withObject "AdamDatastructureVarsetsLinks" $ \o ->
    AdamDatastructureVarsetsLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "priorVersion")
      <*> (o .:? "analysisVariableSets")

-- | ToJSON AdamDatastructureVarsetsLinks
instance A.ToJSON AdamDatastructureVarsetsLinks where
  toJSON AdamDatastructureVarsetsLinks {..} =
   _omitNulls
      [ "self" .= adamDatastructureVarsetsLinksSelf
      , "parentProduct" .= adamDatastructureVarsetsLinksParentProduct
      , "priorVersion" .= adamDatastructureVarsetsLinksPriorVersion
      , "analysisVariableSets" .= adamDatastructureVarsetsLinksAnalysisVariableSets
      ]


-- | Construct a value of type 'AdamDatastructureVarsetsLinks' (by applying it's required fields, if any)
mkAdamDatastructureVarsetsLinks
  :: AdamDatastructureVarsetsLinks
mkAdamDatastructureVarsetsLinks =
  AdamDatastructureVarsetsLinks
  { adamDatastructureVarsetsLinksSelf = Nothing
  , adamDatastructureVarsetsLinksParentProduct = Nothing
  , adamDatastructureVarsetsLinksPriorVersion = Nothing
  , adamDatastructureVarsetsLinksAnalysisVariableSets = Nothing
  }

-- ** AdamDatastructureVarsetsRef
-- | AdamDatastructureVarsetsRef
data AdamDatastructureVarsetsRef = AdamDatastructureVarsetsRef
  { adamDatastructureVarsetsRefHref :: !(Maybe Text) -- ^ "href"
  , adamDatastructureVarsetsRefTitle :: !(Maybe Text) -- ^ "title"
  , adamDatastructureVarsetsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamDatastructureVarsetsRef
instance A.FromJSON AdamDatastructureVarsetsRef where
  parseJSON = A.withObject "AdamDatastructureVarsetsRef" $ \o ->
    AdamDatastructureVarsetsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON AdamDatastructureVarsetsRef
instance A.ToJSON AdamDatastructureVarsetsRef where
  toJSON AdamDatastructureVarsetsRef {..} =
   _omitNulls
      [ "href" .= adamDatastructureVarsetsRefHref
      , "title" .= adamDatastructureVarsetsRefTitle
      , "type" .= adamDatastructureVarsetsRefType
      ]


-- | Construct a value of type 'AdamDatastructureVarsetsRef' (by applying it's required fields, if any)
mkAdamDatastructureVarsetsRef
  :: AdamDatastructureVarsetsRef
mkAdamDatastructureVarsetsRef =
  AdamDatastructureVarsetsRef
  { adamDatastructureVarsetsRefHref = Nothing
  , adamDatastructureVarsetsRefTitle = Nothing
  , adamDatastructureVarsetsRefType = Nothing
  }

-- ** AdamProduct
-- | AdamProduct
data AdamProduct = AdamProduct
  { adamProductName :: !(Maybe Text) -- ^ "name"
  , adamProductLabel :: !(Maybe Text) -- ^ "label"
  , adamProductDescription :: !(Maybe Text) -- ^ "description"
  , adamProductSource :: !(Maybe Text) -- ^ "source"
  , adamProductEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , adamProductRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , adamProductVersion :: !(Maybe Text) -- ^ "version"
  , adamProductLinks :: !(Maybe AdamProductLinks) -- ^ "_links"
  , adamProductDataStructures :: !(Maybe [AdamDatastructure]) -- ^ "dataStructures"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamProduct
instance A.FromJSON AdamProduct where
  parseJSON = A.withObject "AdamProduct" $ \o ->
    AdamProduct
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")
      <*> (o .:? "dataStructures")

-- | ToJSON AdamProduct
instance A.ToJSON AdamProduct where
  toJSON AdamProduct {..} =
   _omitNulls
      [ "name" .= adamProductName
      , "label" .= adamProductLabel
      , "description" .= adamProductDescription
      , "source" .= adamProductSource
      , "effectiveDate" .= adamProductEffectiveDate
      , "registrationStatus" .= adamProductRegistrationStatus
      , "version" .= adamProductVersion
      , "_links" .= adamProductLinks
      , "dataStructures" .= adamProductDataStructures
      ]


-- | Construct a value of type 'AdamProduct' (by applying it's required fields, if any)
mkAdamProduct
  :: AdamProduct
mkAdamProduct =
  AdamProduct
  { adamProductName = Nothing
  , adamProductLabel = Nothing
  , adamProductDescription = Nothing
  , adamProductSource = Nothing
  , adamProductEffectiveDate = Nothing
  , adamProductRegistrationStatus = Nothing
  , adamProductVersion = Nothing
  , adamProductLinks = Nothing
  , adamProductDataStructures = Nothing
  }

-- ** AdamProductDatastructures
-- | AdamProductDatastructures
data AdamProductDatastructures = AdamProductDatastructures
  { adamProductDatastructuresName :: !(Maybe Text) -- ^ "name"
  , adamProductDatastructuresLabel :: !(Maybe Text) -- ^ "label"
  , adamProductDatastructuresDescription :: !(Maybe Text) -- ^ "description"
  , adamProductDatastructuresSource :: !(Maybe Text) -- ^ "source"
  , adamProductDatastructuresEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , adamProductDatastructuresRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , adamProductDatastructuresVersion :: !(Maybe Text) -- ^ "version"
  , adamProductDatastructuresLinks :: !(Maybe AdamProductDatastructuresLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamProductDatastructures
instance A.FromJSON AdamProductDatastructures where
  parseJSON = A.withObject "AdamProductDatastructures" $ \o ->
    AdamProductDatastructures
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")

-- | ToJSON AdamProductDatastructures
instance A.ToJSON AdamProductDatastructures where
  toJSON AdamProductDatastructures {..} =
   _omitNulls
      [ "name" .= adamProductDatastructuresName
      , "label" .= adamProductDatastructuresLabel
      , "description" .= adamProductDatastructuresDescription
      , "source" .= adamProductDatastructuresSource
      , "effectiveDate" .= adamProductDatastructuresEffectiveDate
      , "registrationStatus" .= adamProductDatastructuresRegistrationStatus
      , "version" .= adamProductDatastructuresVersion
      , "_links" .= adamProductDatastructuresLinks
      ]


-- | Construct a value of type 'AdamProductDatastructures' (by applying it's required fields, if any)
mkAdamProductDatastructures
  :: AdamProductDatastructures
mkAdamProductDatastructures =
  AdamProductDatastructures
  { adamProductDatastructuresName = Nothing
  , adamProductDatastructuresLabel = Nothing
  , adamProductDatastructuresDescription = Nothing
  , adamProductDatastructuresSource = Nothing
  , adamProductDatastructuresEffectiveDate = Nothing
  , adamProductDatastructuresRegistrationStatus = Nothing
  , adamProductDatastructuresVersion = Nothing
  , adamProductDatastructuresLinks = Nothing
  }

-- ** AdamProductDatastructuresLinks
-- | AdamProductDatastructuresLinks
data AdamProductDatastructuresLinks = AdamProductDatastructuresLinks
  { adamProductDatastructuresLinksSelf :: !(Maybe AdamProductDatastructuresRef) -- ^ "self"
  , adamProductDatastructuresLinksPriorVersion :: !(Maybe AdamProductDatastructuresRef) -- ^ "priorVersion"
  , adamProductDatastructuresLinksDataStructures :: !(Maybe [AdamDatastructureRefElement]) -- ^ "dataStructures"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamProductDatastructuresLinks
instance A.FromJSON AdamProductDatastructuresLinks where
  parseJSON = A.withObject "AdamProductDatastructuresLinks" $ \o ->
    AdamProductDatastructuresLinks
      <$> (o .:? "self")
      <*> (o .:? "priorVersion")
      <*> (o .:? "dataStructures")

-- | ToJSON AdamProductDatastructuresLinks
instance A.ToJSON AdamProductDatastructuresLinks where
  toJSON AdamProductDatastructuresLinks {..} =
   _omitNulls
      [ "self" .= adamProductDatastructuresLinksSelf
      , "priorVersion" .= adamProductDatastructuresLinksPriorVersion
      , "dataStructures" .= adamProductDatastructuresLinksDataStructures
      ]


-- | Construct a value of type 'AdamProductDatastructuresLinks' (by applying it's required fields, if any)
mkAdamProductDatastructuresLinks
  :: AdamProductDatastructuresLinks
mkAdamProductDatastructuresLinks =
  AdamProductDatastructuresLinks
  { adamProductDatastructuresLinksSelf = Nothing
  , adamProductDatastructuresLinksPriorVersion = Nothing
  , adamProductDatastructuresLinksDataStructures = Nothing
  }

-- ** AdamProductDatastructuresRef
-- | AdamProductDatastructuresRef
data AdamProductDatastructuresRef = AdamProductDatastructuresRef
  { adamProductDatastructuresRefHref :: !(Maybe Text) -- ^ "href"
  , adamProductDatastructuresRefTitle :: !(Maybe Text) -- ^ "title"
  , adamProductDatastructuresRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamProductDatastructuresRef
instance A.FromJSON AdamProductDatastructuresRef where
  parseJSON = A.withObject "AdamProductDatastructuresRef" $ \o ->
    AdamProductDatastructuresRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON AdamProductDatastructuresRef
instance A.ToJSON AdamProductDatastructuresRef where
  toJSON AdamProductDatastructuresRef {..} =
   _omitNulls
      [ "href" .= adamProductDatastructuresRefHref
      , "title" .= adamProductDatastructuresRefTitle
      , "type" .= adamProductDatastructuresRefType
      ]


-- | Construct a value of type 'AdamProductDatastructuresRef' (by applying it's required fields, if any)
mkAdamProductDatastructuresRef
  :: AdamProductDatastructuresRef
mkAdamProductDatastructuresRef =
  AdamProductDatastructuresRef
  { adamProductDatastructuresRefHref = Nothing
  , adamProductDatastructuresRefTitle = Nothing
  , adamProductDatastructuresRefType = Nothing
  }

-- ** AdamProductLinks
-- | AdamProductLinks
data AdamProductLinks = AdamProductLinks
  { adamProductLinksSelf :: !(Maybe AdamProductRef) -- ^ "self"
  , adamProductLinksModel :: !(Maybe AdamProductRef) -- ^ "model"
  , adamProductLinksPriorVersion :: !(Maybe AdamProductRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamProductLinks
instance A.FromJSON AdamProductLinks where
  parseJSON = A.withObject "AdamProductLinks" $ \o ->
    AdamProductLinks
      <$> (o .:? "self")
      <*> (o .:? "model")
      <*> (o .:? "priorVersion")

-- | ToJSON AdamProductLinks
instance A.ToJSON AdamProductLinks where
  toJSON AdamProductLinks {..} =
   _omitNulls
      [ "self" .= adamProductLinksSelf
      , "model" .= adamProductLinksModel
      , "priorVersion" .= adamProductLinksPriorVersion
      ]


-- | Construct a value of type 'AdamProductLinks' (by applying it's required fields, if any)
mkAdamProductLinks
  :: AdamProductLinks
mkAdamProductLinks =
  AdamProductLinks
  { adamProductLinksSelf = Nothing
  , adamProductLinksModel = Nothing
  , adamProductLinksPriorVersion = Nothing
  }

-- ** AdamProductRef
-- | AdamProductRef
data AdamProductRef = AdamProductRef
  { adamProductRefHref :: !(Maybe Text) -- ^ "href"
  , adamProductRefTitle :: !(Maybe Text) -- ^ "title"
  , adamProductRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamProductRef
instance A.FromJSON AdamProductRef where
  parseJSON = A.withObject "AdamProductRef" $ \o ->
    AdamProductRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON AdamProductRef
instance A.ToJSON AdamProductRef where
  toJSON AdamProductRef {..} =
   _omitNulls
      [ "href" .= adamProductRefHref
      , "title" .= adamProductRefTitle
      , "type" .= adamProductRefType
      ]


-- | Construct a value of type 'AdamProductRef' (by applying it's required fields, if any)
mkAdamProductRef
  :: AdamProductRef
mkAdamProductRef =
  AdamProductRef
  { adamProductRefHref = Nothing
  , adamProductRefTitle = Nothing
  , adamProductRefType = Nothing
  }

-- ** AdamProductRefElement
-- | AdamProductRefElement
data AdamProductRefElement = AdamProductRefElement
  { adamProductRefElementHref :: !(Maybe Text) -- ^ "href"
  , adamProductRefElementTitle :: !(Maybe Text) -- ^ "title"
  , adamProductRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamProductRefElement
instance A.FromJSON AdamProductRefElement where
  parseJSON = A.withObject "AdamProductRefElement" $ \o ->
    AdamProductRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON AdamProductRefElement
instance A.ToJSON AdamProductRefElement where
  toJSON AdamProductRefElement {..} =
   _omitNulls
      [ "href" .= adamProductRefElementHref
      , "title" .= adamProductRefElementTitle
      , "type" .= adamProductRefElementType
      ]


-- | Construct a value of type 'AdamProductRefElement' (by applying it's required fields, if any)
mkAdamProductRefElement
  :: AdamProductRefElement
mkAdamProductRefElement =
  AdamProductRefElement
  { adamProductRefElementHref = Nothing
  , adamProductRefElementTitle = Nothing
  , adamProductRefElementType = Nothing
  }

-- ** AdamVariable
-- | AdamVariable
data AdamVariable = AdamVariable
  { adamVariableOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , adamVariableName :: !(Maybe Text) -- ^ "name"
  , adamVariableLabel :: !(Maybe Text) -- ^ "label"
  , adamVariableDescription :: !(Maybe Text) -- ^ "description"
  , adamVariableCore :: !(Maybe Text) -- ^ "core"
  , adamVariableSimpleDatatype :: !(Maybe Text) -- ^ "simpleDatatype"
  , adamVariableDescribedValueDomain :: !(Maybe Text) -- ^ "describedValueDomain"
  , adamVariableValueList :: !(Maybe [Text]) -- ^ "valueList"
  , adamVariableLinks :: !(Maybe AdamVariableLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamVariable
instance A.FromJSON AdamVariable where
  parseJSON = A.withObject "AdamVariable" $ \o ->
    AdamVariable
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "core")
      <*> (o .:? "simpleDatatype")
      <*> (o .:? "describedValueDomain")
      <*> (o .:? "valueList")
      <*> (o .:? "_links")

-- | ToJSON AdamVariable
instance A.ToJSON AdamVariable where
  toJSON AdamVariable {..} =
   _omitNulls
      [ "ordinal" .= adamVariableOrdinal
      , "name" .= adamVariableName
      , "label" .= adamVariableLabel
      , "description" .= adamVariableDescription
      , "core" .= adamVariableCore
      , "simpleDatatype" .= adamVariableSimpleDatatype
      , "describedValueDomain" .= adamVariableDescribedValueDomain
      , "valueList" .= adamVariableValueList
      , "_links" .= adamVariableLinks
      ]


-- | Construct a value of type 'AdamVariable' (by applying it's required fields, if any)
mkAdamVariable
  :: AdamVariable
mkAdamVariable =
  AdamVariable
  { adamVariableOrdinal = Nothing
  , adamVariableName = Nothing
  , adamVariableLabel = Nothing
  , adamVariableDescription = Nothing
  , adamVariableCore = Nothing
  , adamVariableSimpleDatatype = Nothing
  , adamVariableDescribedValueDomain = Nothing
  , adamVariableValueList = Nothing
  , adamVariableLinks = Nothing
  }

-- ** AdamVariableLinks
-- | AdamVariableLinks
data AdamVariableLinks = AdamVariableLinks
  { adamVariableLinksSelf :: !(Maybe AdamVariableRef) -- ^ "self"
  , adamVariableLinksCodelist :: !(Maybe RootCtCodelistRef) -- ^ "codelist"
  , adamVariableLinksParentProduct :: !(Maybe AdamProductRef) -- ^ "parentProduct"
  , adamVariableLinksParentDatastructure :: !(Maybe AdamDatastructureRef) -- ^ "parentDatastructure"
  , adamVariableLinksParentVariableSet :: !(Maybe AdamVarsetRef) -- ^ "parentVariableSet"
  , adamVariableLinksPriorVersion :: !(Maybe AdamVariableRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamVariableLinks
instance A.FromJSON AdamVariableLinks where
  parseJSON = A.withObject "AdamVariableLinks" $ \o ->
    AdamVariableLinks
      <$> (o .:? "self")
      <*> (o .:? "codelist")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentDatastructure")
      <*> (o .:? "parentVariableSet")
      <*> (o .:? "priorVersion")

-- | ToJSON AdamVariableLinks
instance A.ToJSON AdamVariableLinks where
  toJSON AdamVariableLinks {..} =
   _omitNulls
      [ "self" .= adamVariableLinksSelf
      , "codelist" .= adamVariableLinksCodelist
      , "parentProduct" .= adamVariableLinksParentProduct
      , "parentDatastructure" .= adamVariableLinksParentDatastructure
      , "parentVariableSet" .= adamVariableLinksParentVariableSet
      , "priorVersion" .= adamVariableLinksPriorVersion
      ]


-- | Construct a value of type 'AdamVariableLinks' (by applying it's required fields, if any)
mkAdamVariableLinks
  :: AdamVariableLinks
mkAdamVariableLinks =
  AdamVariableLinks
  { adamVariableLinksSelf = Nothing
  , adamVariableLinksCodelist = Nothing
  , adamVariableLinksParentProduct = Nothing
  , adamVariableLinksParentDatastructure = Nothing
  , adamVariableLinksParentVariableSet = Nothing
  , adamVariableLinksPriorVersion = Nothing
  }

-- ** AdamVariableRef
-- | AdamVariableRef
data AdamVariableRef = AdamVariableRef
  { adamVariableRefHref :: !(Maybe Text) -- ^ "href"
  , adamVariableRefTitle :: !(Maybe Text) -- ^ "title"
  , adamVariableRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamVariableRef
instance A.FromJSON AdamVariableRef where
  parseJSON = A.withObject "AdamVariableRef" $ \o ->
    AdamVariableRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON AdamVariableRef
instance A.ToJSON AdamVariableRef where
  toJSON AdamVariableRef {..} =
   _omitNulls
      [ "href" .= adamVariableRefHref
      , "title" .= adamVariableRefTitle
      , "type" .= adamVariableRefType
      ]


-- | Construct a value of type 'AdamVariableRef' (by applying it's required fields, if any)
mkAdamVariableRef
  :: AdamVariableRef
mkAdamVariableRef =
  AdamVariableRef
  { adamVariableRefHref = Nothing
  , adamVariableRefTitle = Nothing
  , adamVariableRefType = Nothing
  }

-- ** AdamVariableRefElement
-- | AdamVariableRefElement
data AdamVariableRefElement = AdamVariableRefElement
  { adamVariableRefElementHref :: !(Maybe Text) -- ^ "href"
  , adamVariableRefElementTitle :: !(Maybe Text) -- ^ "title"
  , adamVariableRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamVariableRefElement
instance A.FromJSON AdamVariableRefElement where
  parseJSON = A.withObject "AdamVariableRefElement" $ \o ->
    AdamVariableRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON AdamVariableRefElement
instance A.ToJSON AdamVariableRefElement where
  toJSON AdamVariableRefElement {..} =
   _omitNulls
      [ "href" .= adamVariableRefElementHref
      , "title" .= adamVariableRefElementTitle
      , "type" .= adamVariableRefElementType
      ]


-- | Construct a value of type 'AdamVariableRefElement' (by applying it's required fields, if any)
mkAdamVariableRefElement
  :: AdamVariableRefElement
mkAdamVariableRefElement =
  AdamVariableRefElement
  { adamVariableRefElementHref = Nothing
  , adamVariableRefElementTitle = Nothing
  , adamVariableRefElementType = Nothing
  }

-- ** AdamVarset
-- | AdamVarset
data AdamVarset = AdamVarset
  { adamVarsetOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , adamVarsetName :: !(Maybe Text) -- ^ "name"
  , adamVarsetLabel :: !(Maybe Text) -- ^ "label"
  , adamVarsetDescription :: !(Maybe Text) -- ^ "description"
  , adamVarsetLinks :: !(Maybe AdamVarsetLinks) -- ^ "_links"
  , adamVarsetAnalysisVariables :: !(Maybe [AdamVariable]) -- ^ "analysisVariables"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamVarset
instance A.FromJSON AdamVarset where
  parseJSON = A.withObject "AdamVarset" $ \o ->
    AdamVarset
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "_links")
      <*> (o .:? "analysisVariables")

-- | ToJSON AdamVarset
instance A.ToJSON AdamVarset where
  toJSON AdamVarset {..} =
   _omitNulls
      [ "ordinal" .= adamVarsetOrdinal
      , "name" .= adamVarsetName
      , "label" .= adamVarsetLabel
      , "description" .= adamVarsetDescription
      , "_links" .= adamVarsetLinks
      , "analysisVariables" .= adamVarsetAnalysisVariables
      ]


-- | Construct a value of type 'AdamVarset' (by applying it's required fields, if any)
mkAdamVarset
  :: AdamVarset
mkAdamVarset =
  AdamVarset
  { adamVarsetOrdinal = Nothing
  , adamVarsetName = Nothing
  , adamVarsetLabel = Nothing
  , adamVarsetDescription = Nothing
  , adamVarsetLinks = Nothing
  , adamVarsetAnalysisVariables = Nothing
  }

-- ** AdamVarsetLinks
-- | AdamVarsetLinks
data AdamVarsetLinks = AdamVarsetLinks
  { adamVarsetLinksSelf :: !(Maybe AdamVarsetRef) -- ^ "self"
  , adamVarsetLinksParentProduct :: !(Maybe AdamProductRef) -- ^ "parentProduct"
  , adamVarsetLinksParentDatastructure :: !(Maybe AdamDatastructureRef) -- ^ "parentDatastructure"
  , adamVarsetLinksPriorVersion :: !(Maybe AdamVarsetRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamVarsetLinks
instance A.FromJSON AdamVarsetLinks where
  parseJSON = A.withObject "AdamVarsetLinks" $ \o ->
    AdamVarsetLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentDatastructure")
      <*> (o .:? "priorVersion")

-- | ToJSON AdamVarsetLinks
instance A.ToJSON AdamVarsetLinks where
  toJSON AdamVarsetLinks {..} =
   _omitNulls
      [ "self" .= adamVarsetLinksSelf
      , "parentProduct" .= adamVarsetLinksParentProduct
      , "parentDatastructure" .= adamVarsetLinksParentDatastructure
      , "priorVersion" .= adamVarsetLinksPriorVersion
      ]


-- | Construct a value of type 'AdamVarsetLinks' (by applying it's required fields, if any)
mkAdamVarsetLinks
  :: AdamVarsetLinks
mkAdamVarsetLinks =
  AdamVarsetLinks
  { adamVarsetLinksSelf = Nothing
  , adamVarsetLinksParentProduct = Nothing
  , adamVarsetLinksParentDatastructure = Nothing
  , adamVarsetLinksPriorVersion = Nothing
  }

-- ** AdamVarsetRef
-- | AdamVarsetRef
data AdamVarsetRef = AdamVarsetRef
  { adamVarsetRefHref :: !(Maybe Text) -- ^ "href"
  , adamVarsetRefTitle :: !(Maybe Text) -- ^ "title"
  , adamVarsetRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamVarsetRef
instance A.FromJSON AdamVarsetRef where
  parseJSON = A.withObject "AdamVarsetRef" $ \o ->
    AdamVarsetRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON AdamVarsetRef
instance A.ToJSON AdamVarsetRef where
  toJSON AdamVarsetRef {..} =
   _omitNulls
      [ "href" .= adamVarsetRefHref
      , "title" .= adamVarsetRefTitle
      , "type" .= adamVarsetRefType
      ]


-- | Construct a value of type 'AdamVarsetRef' (by applying it's required fields, if any)
mkAdamVarsetRef
  :: AdamVarsetRef
mkAdamVarsetRef =
  AdamVarsetRef
  { adamVarsetRefHref = Nothing
  , adamVarsetRefTitle = Nothing
  , adamVarsetRefType = Nothing
  }

-- ** AdamVarsetRefElement
-- | AdamVarsetRefElement
data AdamVarsetRefElement = AdamVarsetRefElement
  { adamVarsetRefElementHref :: !(Maybe Text) -- ^ "href"
  , adamVarsetRefElementTitle :: !(Maybe Text) -- ^ "title"
  , adamVarsetRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdamVarsetRefElement
instance A.FromJSON AdamVarsetRefElement where
  parseJSON = A.withObject "AdamVarsetRefElement" $ \o ->
    AdamVarsetRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON AdamVarsetRefElement
instance A.ToJSON AdamVarsetRefElement where
  toJSON AdamVarsetRefElement {..} =
   _omitNulls
      [ "href" .= adamVarsetRefElementHref
      , "title" .= adamVarsetRefElementTitle
      , "type" .= adamVarsetRefElementType
      ]


-- | Construct a value of type 'AdamVarsetRefElement' (by applying it's required fields, if any)
mkAdamVarsetRefElement
  :: AdamVarsetRefElement
mkAdamVarsetRefElement =
  AdamVarsetRefElement
  { adamVarsetRefElementHref = Nothing
  , adamVarsetRefElementTitle = Nothing
  , adamVarsetRefElementType = Nothing
  }

-- ** CdashClass
-- | CdashClass
data CdashClass = CdashClass
  { cdashClassOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , cdashClassName :: !(Maybe Text) -- ^ "name"
  , cdashClassLabel :: !(Maybe Text) -- ^ "label"
  , cdashClassDescription :: !(Maybe Text) -- ^ "description"
  , cdashClassLinks :: !(Maybe CdashClassLinks) -- ^ "_links"
  , cdashClassCdashModelFields :: !(Maybe [CdashClassField]) -- ^ "cdashModelFields"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashClass
instance A.FromJSON CdashClass where
  parseJSON = A.withObject "CdashClass" $ \o ->
    CdashClass
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "_links")
      <*> (o .:? "cdashModelFields")

-- | ToJSON CdashClass
instance A.ToJSON CdashClass where
  toJSON CdashClass {..} =
   _omitNulls
      [ "ordinal" .= cdashClassOrdinal
      , "name" .= cdashClassName
      , "label" .= cdashClassLabel
      , "description" .= cdashClassDescription
      , "_links" .= cdashClassLinks
      , "cdashModelFields" .= cdashClassCdashModelFields
      ]


-- | Construct a value of type 'CdashClass' (by applying it's required fields, if any)
mkCdashClass
  :: CdashClass
mkCdashClass =
  CdashClass
  { cdashClassOrdinal = Nothing
  , cdashClassName = Nothing
  , cdashClassLabel = Nothing
  , cdashClassDescription = Nothing
  , cdashClassLinks = Nothing
  , cdashClassCdashModelFields = Nothing
  }

-- ** CdashClassDomains
-- | CdashClassDomains
data CdashClassDomains = CdashClassDomains
  { cdashClassDomainsOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , cdashClassDomainsName :: !(Maybe Text) -- ^ "name"
  , cdashClassDomainsLabel :: !(Maybe Text) -- ^ "label"
  , cdashClassDomainsDescription :: !(Maybe Text) -- ^ "description"
  , cdashClassDomainsLinks :: !(Maybe CdashClassDomainsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashClassDomains
instance A.FromJSON CdashClassDomains where
  parseJSON = A.withObject "CdashClassDomains" $ \o ->
    CdashClassDomains
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "_links")

-- | ToJSON CdashClassDomains
instance A.ToJSON CdashClassDomains where
  toJSON CdashClassDomains {..} =
   _omitNulls
      [ "ordinal" .= cdashClassDomainsOrdinal
      , "name" .= cdashClassDomainsName
      , "label" .= cdashClassDomainsLabel
      , "description" .= cdashClassDomainsDescription
      , "_links" .= cdashClassDomainsLinks
      ]


-- | Construct a value of type 'CdashClassDomains' (by applying it's required fields, if any)
mkCdashClassDomains
  :: CdashClassDomains
mkCdashClassDomains =
  CdashClassDomains
  { cdashClassDomainsOrdinal = Nothing
  , cdashClassDomainsName = Nothing
  , cdashClassDomainsLabel = Nothing
  , cdashClassDomainsDescription = Nothing
  , cdashClassDomainsLinks = Nothing
  }

-- ** CdashClassDomainsLinks
-- | CdashClassDomainsLinks
data CdashClassDomainsLinks = CdashClassDomainsLinks
  { cdashClassDomainsLinksSelf :: !(Maybe CdashClassDomainsRef) -- ^ "self"
  , cdashClassDomainsLinksDomains :: !(Maybe [CdashDomainRefElement]) -- ^ "domains"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashClassDomainsLinks
instance A.FromJSON CdashClassDomainsLinks where
  parseJSON = A.withObject "CdashClassDomainsLinks" $ \o ->
    CdashClassDomainsLinks
      <$> (o .:? "self")
      <*> (o .:? "domains")

-- | ToJSON CdashClassDomainsLinks
instance A.ToJSON CdashClassDomainsLinks where
  toJSON CdashClassDomainsLinks {..} =
   _omitNulls
      [ "self" .= cdashClassDomainsLinksSelf
      , "domains" .= cdashClassDomainsLinksDomains
      ]


-- | Construct a value of type 'CdashClassDomainsLinks' (by applying it's required fields, if any)
mkCdashClassDomainsLinks
  :: CdashClassDomainsLinks
mkCdashClassDomainsLinks =
  CdashClassDomainsLinks
  { cdashClassDomainsLinksSelf = Nothing
  , cdashClassDomainsLinksDomains = Nothing
  }

-- ** CdashClassDomainsRef
-- | CdashClassDomainsRef
data CdashClassDomainsRef = CdashClassDomainsRef
  { cdashClassDomainsRefHref :: !(Maybe Text) -- ^ "href"
  , cdashClassDomainsRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashClassDomainsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashClassDomainsRef
instance A.FromJSON CdashClassDomainsRef where
  parseJSON = A.withObject "CdashClassDomainsRef" $ \o ->
    CdashClassDomainsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashClassDomainsRef
instance A.ToJSON CdashClassDomainsRef where
  toJSON CdashClassDomainsRef {..} =
   _omitNulls
      [ "href" .= cdashClassDomainsRefHref
      , "title" .= cdashClassDomainsRefTitle
      , "type" .= cdashClassDomainsRefType
      ]


-- | Construct a value of type 'CdashClassDomainsRef' (by applying it's required fields, if any)
mkCdashClassDomainsRef
  :: CdashClassDomainsRef
mkCdashClassDomainsRef =
  CdashClassDomainsRef
  { cdashClassDomainsRefHref = Nothing
  , cdashClassDomainsRefTitle = Nothing
  , cdashClassDomainsRefType = Nothing
  }

-- ** CdashClassField
-- | CdashClassField
data CdashClassField = CdashClassField
  { cdashClassFieldOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , cdashClassFieldName :: !(Maybe Text) -- ^ "name"
  , cdashClassFieldLabel :: !(Maybe Text) -- ^ "label"
  , cdashClassFieldDefinition :: !(Maybe Text) -- ^ "definition"
  , cdashClassFieldQuestionText :: !(Maybe Text) -- ^ "questionText"
  , cdashClassFieldPrompt :: !(Maybe Text) -- ^ "prompt"
  , cdashClassFieldSimpleDatatype :: !(Maybe Text) -- ^ "simpleDatatype"
  , cdashClassFieldImplementationNotes :: !(Maybe Text) -- ^ "implementationNotes"
  , cdashClassFieldMappingInstructions :: !(Maybe Text) -- ^ "mappingInstructions"
  , cdashClassFieldLinks :: !(Maybe CdashClassFieldLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashClassField
instance A.FromJSON CdashClassField where
  parseJSON = A.withObject "CdashClassField" $ \o ->
    CdashClassField
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "definition")
      <*> (o .:? "questionText")
      <*> (o .:? "prompt")
      <*> (o .:? "simpleDatatype")
      <*> (o .:? "implementationNotes")
      <*> (o .:? "mappingInstructions")
      <*> (o .:? "_links")

-- | ToJSON CdashClassField
instance A.ToJSON CdashClassField where
  toJSON CdashClassField {..} =
   _omitNulls
      [ "ordinal" .= cdashClassFieldOrdinal
      , "name" .= cdashClassFieldName
      , "label" .= cdashClassFieldLabel
      , "definition" .= cdashClassFieldDefinition
      , "questionText" .= cdashClassFieldQuestionText
      , "prompt" .= cdashClassFieldPrompt
      , "simpleDatatype" .= cdashClassFieldSimpleDatatype
      , "implementationNotes" .= cdashClassFieldImplementationNotes
      , "mappingInstructions" .= cdashClassFieldMappingInstructions
      , "_links" .= cdashClassFieldLinks
      ]


-- | Construct a value of type 'CdashClassField' (by applying it's required fields, if any)
mkCdashClassField
  :: CdashClassField
mkCdashClassField =
  CdashClassField
  { cdashClassFieldOrdinal = Nothing
  , cdashClassFieldName = Nothing
  , cdashClassFieldLabel = Nothing
  , cdashClassFieldDefinition = Nothing
  , cdashClassFieldQuestionText = Nothing
  , cdashClassFieldPrompt = Nothing
  , cdashClassFieldSimpleDatatype = Nothing
  , cdashClassFieldImplementationNotes = Nothing
  , cdashClassFieldMappingInstructions = Nothing
  , cdashClassFieldLinks = Nothing
  }

-- ** CdashClassFieldLinks
-- | CdashClassFieldLinks
data CdashClassFieldLinks = CdashClassFieldLinks
  { cdashClassFieldLinksSelf :: !(Maybe CdashClassFieldRef) -- ^ "self"
  , cdashClassFieldLinksCodelist :: !(Maybe [RootCtCodelistRefElement]) -- ^ "codelist"
  , cdashClassFieldLinksParentProduct :: !(Maybe CdashProductRef) -- ^ "parentProduct"
  , cdashClassFieldLinksParentClass :: !(Maybe CdashClassRef) -- ^ "parentClass"
  , cdashClassFieldLinksRootItem :: !(Maybe RootCdashClassFieldRef) -- ^ "rootItem"
  , cdashClassFieldLinksPriorVersion :: !(Maybe CdashClassFieldRef) -- ^ "priorVersion"
  , cdashClassFieldLinksSdtmClassMappingTargets :: !(Maybe [SdtmClassVariableRefTarget]) -- ^ "sdtmClassMappingTargets"
  , cdashClassFieldLinksSdtmDatasetMappingTargets :: !(Maybe [SdtmDatasetVariableRefTarget]) -- ^ "sdtmDatasetMappingTargets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashClassFieldLinks
instance A.FromJSON CdashClassFieldLinks where
  parseJSON = A.withObject "CdashClassFieldLinks" $ \o ->
    CdashClassFieldLinks
      <$> (o .:? "self")
      <*> (o .:? "codelist")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "rootItem")
      <*> (o .:? "priorVersion")
      <*> (o .:? "sdtmClassMappingTargets")
      <*> (o .:? "sdtmDatasetMappingTargets")

-- | ToJSON CdashClassFieldLinks
instance A.ToJSON CdashClassFieldLinks where
  toJSON CdashClassFieldLinks {..} =
   _omitNulls
      [ "self" .= cdashClassFieldLinksSelf
      , "codelist" .= cdashClassFieldLinksCodelist
      , "parentProduct" .= cdashClassFieldLinksParentProduct
      , "parentClass" .= cdashClassFieldLinksParentClass
      , "rootItem" .= cdashClassFieldLinksRootItem
      , "priorVersion" .= cdashClassFieldLinksPriorVersion
      , "sdtmClassMappingTargets" .= cdashClassFieldLinksSdtmClassMappingTargets
      , "sdtmDatasetMappingTargets" .= cdashClassFieldLinksSdtmDatasetMappingTargets
      ]


-- | Construct a value of type 'CdashClassFieldLinks' (by applying it's required fields, if any)
mkCdashClassFieldLinks
  :: CdashClassFieldLinks
mkCdashClassFieldLinks =
  CdashClassFieldLinks
  { cdashClassFieldLinksSelf = Nothing
  , cdashClassFieldLinksCodelist = Nothing
  , cdashClassFieldLinksParentProduct = Nothing
  , cdashClassFieldLinksParentClass = Nothing
  , cdashClassFieldLinksRootItem = Nothing
  , cdashClassFieldLinksPriorVersion = Nothing
  , cdashClassFieldLinksSdtmClassMappingTargets = Nothing
  , cdashClassFieldLinksSdtmDatasetMappingTargets = Nothing
  }

-- ** CdashClassFieldRef
-- | CdashClassFieldRef
data CdashClassFieldRef = CdashClassFieldRef
  { cdashClassFieldRefHref :: !(Maybe Text) -- ^ "href"
  , cdashClassFieldRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashClassFieldRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashClassFieldRef
instance A.FromJSON CdashClassFieldRef where
  parseJSON = A.withObject "CdashClassFieldRef" $ \o ->
    CdashClassFieldRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashClassFieldRef
instance A.ToJSON CdashClassFieldRef where
  toJSON CdashClassFieldRef {..} =
   _omitNulls
      [ "href" .= cdashClassFieldRefHref
      , "title" .= cdashClassFieldRefTitle
      , "type" .= cdashClassFieldRefType
      ]


-- | Construct a value of type 'CdashClassFieldRef' (by applying it's required fields, if any)
mkCdashClassFieldRef
  :: CdashClassFieldRef
mkCdashClassFieldRef =
  CdashClassFieldRef
  { cdashClassFieldRefHref = Nothing
  , cdashClassFieldRefTitle = Nothing
  , cdashClassFieldRefType = Nothing
  }

-- ** CdashClassFieldRefVersion
-- | CdashClassFieldRefVersion
data CdashClassFieldRefVersion = CdashClassFieldRefVersion
  { cdashClassFieldRefVersionHref :: !(Maybe Text) -- ^ "href"
  , cdashClassFieldRefVersionTitle :: !(Maybe Text) -- ^ "title"
  , cdashClassFieldRefVersionType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashClassFieldRefVersion
instance A.FromJSON CdashClassFieldRefVersion where
  parseJSON = A.withObject "CdashClassFieldRefVersion" $ \o ->
    CdashClassFieldRefVersion
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashClassFieldRefVersion
instance A.ToJSON CdashClassFieldRefVersion where
  toJSON CdashClassFieldRefVersion {..} =
   _omitNulls
      [ "href" .= cdashClassFieldRefVersionHref
      , "title" .= cdashClassFieldRefVersionTitle
      , "type" .= cdashClassFieldRefVersionType
      ]


-- | Construct a value of type 'CdashClassFieldRefVersion' (by applying it's required fields, if any)
mkCdashClassFieldRefVersion
  :: CdashClassFieldRefVersion
mkCdashClassFieldRefVersion =
  CdashClassFieldRefVersion
  { cdashClassFieldRefVersionHref = Nothing
  , cdashClassFieldRefVersionTitle = Nothing
  , cdashClassFieldRefVersionType = Nothing
  }

-- ** CdashClassLinks
-- | CdashClassLinks
data CdashClassLinks = CdashClassLinks
  { cdashClassLinksSelf :: !(Maybe CdashClassRef) -- ^ "self"
  , cdashClassLinksParentProduct :: !(Maybe CdashProductRef) -- ^ "parentProduct"
  , cdashClassLinksPriorVersion :: !(Maybe CdashClassRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashClassLinks
instance A.FromJSON CdashClassLinks where
  parseJSON = A.withObject "CdashClassLinks" $ \o ->
    CdashClassLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "priorVersion")

-- | ToJSON CdashClassLinks
instance A.ToJSON CdashClassLinks where
  toJSON CdashClassLinks {..} =
   _omitNulls
      [ "self" .= cdashClassLinksSelf
      , "parentProduct" .= cdashClassLinksParentProduct
      , "priorVersion" .= cdashClassLinksPriorVersion
      ]


-- | Construct a value of type 'CdashClassLinks' (by applying it's required fields, if any)
mkCdashClassLinks
  :: CdashClassLinks
mkCdashClassLinks =
  CdashClassLinks
  { cdashClassLinksSelf = Nothing
  , cdashClassLinksParentProduct = Nothing
  , cdashClassLinksPriorVersion = Nothing
  }

-- ** CdashClassRef
-- | CdashClassRef
data CdashClassRef = CdashClassRef
  { cdashClassRefHref :: !(Maybe Text) -- ^ "href"
  , cdashClassRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashClassRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashClassRef
instance A.FromJSON CdashClassRef where
  parseJSON = A.withObject "CdashClassRef" $ \o ->
    CdashClassRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashClassRef
instance A.ToJSON CdashClassRef where
  toJSON CdashClassRef {..} =
   _omitNulls
      [ "href" .= cdashClassRefHref
      , "title" .= cdashClassRefTitle
      , "type" .= cdashClassRefType
      ]


-- | Construct a value of type 'CdashClassRef' (by applying it's required fields, if any)
mkCdashClassRef
  :: CdashClassRef
mkCdashClassRef =
  CdashClassRef
  { cdashClassRefHref = Nothing
  , cdashClassRefTitle = Nothing
  , cdashClassRefType = Nothing
  }

-- ** CdashClassRefElement
-- | CdashClassRefElement
data CdashClassRefElement = CdashClassRefElement
  { cdashClassRefElementHref :: !(Maybe Text) -- ^ "href"
  , cdashClassRefElementTitle :: !(Maybe Text) -- ^ "title"
  , cdashClassRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashClassRefElement
instance A.FromJSON CdashClassRefElement where
  parseJSON = A.withObject "CdashClassRefElement" $ \o ->
    CdashClassRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashClassRefElement
instance A.ToJSON CdashClassRefElement where
  toJSON CdashClassRefElement {..} =
   _omitNulls
      [ "href" .= cdashClassRefElementHref
      , "title" .= cdashClassRefElementTitle
      , "type" .= cdashClassRefElementType
      ]


-- | Construct a value of type 'CdashClassRefElement' (by applying it's required fields, if any)
mkCdashClassRefElement
  :: CdashClassRefElement
mkCdashClassRefElement =
  CdashClassRefElement
  { cdashClassRefElementHref = Nothing
  , cdashClassRefElementTitle = Nothing
  , cdashClassRefElementType = Nothing
  }

-- ** CdashDomain
-- | CdashDomain
data CdashDomain = CdashDomain
  { cdashDomainOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , cdashDomainName :: !(Maybe Text) -- ^ "name"
  , cdashDomainLabel :: !(Maybe Text) -- ^ "label"
  , cdashDomainLinks :: !(Maybe CdashDomainLinks) -- ^ "_links"
  , cdashDomainFields :: !(Maybe [CdashDomainField]) -- ^ "fields"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashDomain
instance A.FromJSON CdashDomain where
  parseJSON = A.withObject "CdashDomain" $ \o ->
    CdashDomain
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "_links")
      <*> (o .:? "fields")

-- | ToJSON CdashDomain
instance A.ToJSON CdashDomain where
  toJSON CdashDomain {..} =
   _omitNulls
      [ "ordinal" .= cdashDomainOrdinal
      , "name" .= cdashDomainName
      , "label" .= cdashDomainLabel
      , "_links" .= cdashDomainLinks
      , "fields" .= cdashDomainFields
      ]


-- | Construct a value of type 'CdashDomain' (by applying it's required fields, if any)
mkCdashDomain
  :: CdashDomain
mkCdashDomain =
  CdashDomain
  { cdashDomainOrdinal = Nothing
  , cdashDomainName = Nothing
  , cdashDomainLabel = Nothing
  , cdashDomainLinks = Nothing
  , cdashDomainFields = Nothing
  }

-- ** CdashDomainField
-- | CdashDomainField
data CdashDomainField = CdashDomainField
  { cdashDomainFieldOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , cdashDomainFieldName :: !(Maybe Text) -- ^ "name"
  , cdashDomainFieldLabel :: !(Maybe Text) -- ^ "label"
  , cdashDomainFieldDefinition :: !(Maybe Text) -- ^ "definition"
  , cdashDomainFieldDomainSpecific :: !(Maybe Text) -- ^ "domainSpecific"
  , cdashDomainFieldQuestionText :: !(Maybe Text) -- ^ "questionText"
  , cdashDomainFieldPrompt :: !(Maybe Text) -- ^ "prompt"
  , cdashDomainFieldSimpleDatatype :: !(Maybe Text) -- ^ "simpleDatatype"
  , cdashDomainFieldImplementationNotes :: !(Maybe Text) -- ^ "implementationNotes"
  , cdashDomainFieldMappingInstructions :: !(Maybe Text) -- ^ "mappingInstructions"
  , cdashDomainFieldLinks :: !(Maybe CdashDomainFieldLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashDomainField
instance A.FromJSON CdashDomainField where
  parseJSON = A.withObject "CdashDomainField" $ \o ->
    CdashDomainField
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "definition")
      <*> (o .:? "domainSpecific")
      <*> (o .:? "questionText")
      <*> (o .:? "prompt")
      <*> (o .:? "simpleDatatype")
      <*> (o .:? "implementationNotes")
      <*> (o .:? "mappingInstructions")
      <*> (o .:? "_links")

-- | ToJSON CdashDomainField
instance A.ToJSON CdashDomainField where
  toJSON CdashDomainField {..} =
   _omitNulls
      [ "ordinal" .= cdashDomainFieldOrdinal
      , "name" .= cdashDomainFieldName
      , "label" .= cdashDomainFieldLabel
      , "definition" .= cdashDomainFieldDefinition
      , "domainSpecific" .= cdashDomainFieldDomainSpecific
      , "questionText" .= cdashDomainFieldQuestionText
      , "prompt" .= cdashDomainFieldPrompt
      , "simpleDatatype" .= cdashDomainFieldSimpleDatatype
      , "implementationNotes" .= cdashDomainFieldImplementationNotes
      , "mappingInstructions" .= cdashDomainFieldMappingInstructions
      , "_links" .= cdashDomainFieldLinks
      ]


-- | Construct a value of type 'CdashDomainField' (by applying it's required fields, if any)
mkCdashDomainField
  :: CdashDomainField
mkCdashDomainField =
  CdashDomainField
  { cdashDomainFieldOrdinal = Nothing
  , cdashDomainFieldName = Nothing
  , cdashDomainFieldLabel = Nothing
  , cdashDomainFieldDefinition = Nothing
  , cdashDomainFieldDomainSpecific = Nothing
  , cdashDomainFieldQuestionText = Nothing
  , cdashDomainFieldPrompt = Nothing
  , cdashDomainFieldSimpleDatatype = Nothing
  , cdashDomainFieldImplementationNotes = Nothing
  , cdashDomainFieldMappingInstructions = Nothing
  , cdashDomainFieldLinks = Nothing
  }

-- ** CdashDomainFieldLinks
-- | CdashDomainFieldLinks
data CdashDomainFieldLinks = CdashDomainFieldLinks
  { cdashDomainFieldLinksSelf :: !(Maybe CdashDomainFieldRef) -- ^ "self"
  , cdashDomainFieldLinksCodelist :: !(Maybe [RootCtCodelistRefElement]) -- ^ "codelist"
  , cdashDomainFieldLinksParentProduct :: !(Maybe CdashProductRef) -- ^ "parentProduct"
  , cdashDomainFieldLinksParentClass :: !(Maybe CdashClassRef) -- ^ "parentClass"
  , cdashDomainFieldLinksParentDomain :: !(Maybe CdashDomainRef) -- ^ "parentDomain"
  , cdashDomainFieldLinksRootItem :: !(Maybe RootCdashDomainFieldRef) -- ^ "rootItem"
  , cdashDomainFieldLinksPriorVersion :: !(Maybe CdashDomainFieldRef) -- ^ "priorVersion"
  , cdashDomainFieldLinksSdtmDatasetMappingTargets :: !(Maybe [SdtmDatasetVariableRefTarget]) -- ^ "sdtmDatasetMappingTargets"
  , cdashDomainFieldLinksSdtmigDatasetMappingTargets :: !(Maybe [SdtmigDatasetVariableRefTarget]) -- ^ "sdtmigDatasetMappingTargets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashDomainFieldLinks
instance A.FromJSON CdashDomainFieldLinks where
  parseJSON = A.withObject "CdashDomainFieldLinks" $ \o ->
    CdashDomainFieldLinks
      <$> (o .:? "self")
      <*> (o .:? "codelist")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "parentDomain")
      <*> (o .:? "rootItem")
      <*> (o .:? "priorVersion")
      <*> (o .:? "sdtmDatasetMappingTargets")
      <*> (o .:? "sdtmigDatasetMappingTargets")

-- | ToJSON CdashDomainFieldLinks
instance A.ToJSON CdashDomainFieldLinks where
  toJSON CdashDomainFieldLinks {..} =
   _omitNulls
      [ "self" .= cdashDomainFieldLinksSelf
      , "codelist" .= cdashDomainFieldLinksCodelist
      , "parentProduct" .= cdashDomainFieldLinksParentProduct
      , "parentClass" .= cdashDomainFieldLinksParentClass
      , "parentDomain" .= cdashDomainFieldLinksParentDomain
      , "rootItem" .= cdashDomainFieldLinksRootItem
      , "priorVersion" .= cdashDomainFieldLinksPriorVersion
      , "sdtmDatasetMappingTargets" .= cdashDomainFieldLinksSdtmDatasetMappingTargets
      , "sdtmigDatasetMappingTargets" .= cdashDomainFieldLinksSdtmigDatasetMappingTargets
      ]


-- | Construct a value of type 'CdashDomainFieldLinks' (by applying it's required fields, if any)
mkCdashDomainFieldLinks
  :: CdashDomainFieldLinks
mkCdashDomainFieldLinks =
  CdashDomainFieldLinks
  { cdashDomainFieldLinksSelf = Nothing
  , cdashDomainFieldLinksCodelist = Nothing
  , cdashDomainFieldLinksParentProduct = Nothing
  , cdashDomainFieldLinksParentClass = Nothing
  , cdashDomainFieldLinksParentDomain = Nothing
  , cdashDomainFieldLinksRootItem = Nothing
  , cdashDomainFieldLinksPriorVersion = Nothing
  , cdashDomainFieldLinksSdtmDatasetMappingTargets = Nothing
  , cdashDomainFieldLinksSdtmigDatasetMappingTargets = Nothing
  }

-- ** CdashDomainFieldRef
-- | CdashDomainFieldRef
data CdashDomainFieldRef = CdashDomainFieldRef
  { cdashDomainFieldRefHref :: !(Maybe Text) -- ^ "href"
  , cdashDomainFieldRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashDomainFieldRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashDomainFieldRef
instance A.FromJSON CdashDomainFieldRef where
  parseJSON = A.withObject "CdashDomainFieldRef" $ \o ->
    CdashDomainFieldRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashDomainFieldRef
instance A.ToJSON CdashDomainFieldRef where
  toJSON CdashDomainFieldRef {..} =
   _omitNulls
      [ "href" .= cdashDomainFieldRefHref
      , "title" .= cdashDomainFieldRefTitle
      , "type" .= cdashDomainFieldRefType
      ]


-- | Construct a value of type 'CdashDomainFieldRef' (by applying it's required fields, if any)
mkCdashDomainFieldRef
  :: CdashDomainFieldRef
mkCdashDomainFieldRef =
  CdashDomainFieldRef
  { cdashDomainFieldRefHref = Nothing
  , cdashDomainFieldRefTitle = Nothing
  , cdashDomainFieldRefType = Nothing
  }

-- ** CdashDomainFieldRefElement
-- | CdashDomainFieldRefElement
data CdashDomainFieldRefElement = CdashDomainFieldRefElement
  { cdashDomainFieldRefElementHref :: !(Maybe Text) -- ^ "href"
  , cdashDomainFieldRefElementTitle :: !(Maybe Text) -- ^ "title"
  , cdashDomainFieldRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashDomainFieldRefElement
instance A.FromJSON CdashDomainFieldRefElement where
  parseJSON = A.withObject "CdashDomainFieldRefElement" $ \o ->
    CdashDomainFieldRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashDomainFieldRefElement
instance A.ToJSON CdashDomainFieldRefElement where
  toJSON CdashDomainFieldRefElement {..} =
   _omitNulls
      [ "href" .= cdashDomainFieldRefElementHref
      , "title" .= cdashDomainFieldRefElementTitle
      , "type" .= cdashDomainFieldRefElementType
      ]


-- | Construct a value of type 'CdashDomainFieldRefElement' (by applying it's required fields, if any)
mkCdashDomainFieldRefElement
  :: CdashDomainFieldRefElement
mkCdashDomainFieldRefElement =
  CdashDomainFieldRefElement
  { cdashDomainFieldRefElementHref = Nothing
  , cdashDomainFieldRefElementTitle = Nothing
  , cdashDomainFieldRefElementType = Nothing
  }

-- ** CdashDomainFieldRefVersion
-- | CdashDomainFieldRefVersion
data CdashDomainFieldRefVersion = CdashDomainFieldRefVersion
  { cdashDomainFieldRefVersionHref :: !(Maybe Text) -- ^ "href"
  , cdashDomainFieldRefVersionTitle :: !(Maybe Text) -- ^ "title"
  , cdashDomainFieldRefVersionType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashDomainFieldRefVersion
instance A.FromJSON CdashDomainFieldRefVersion where
  parseJSON = A.withObject "CdashDomainFieldRefVersion" $ \o ->
    CdashDomainFieldRefVersion
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashDomainFieldRefVersion
instance A.ToJSON CdashDomainFieldRefVersion where
  toJSON CdashDomainFieldRefVersion {..} =
   _omitNulls
      [ "href" .= cdashDomainFieldRefVersionHref
      , "title" .= cdashDomainFieldRefVersionTitle
      , "type" .= cdashDomainFieldRefVersionType
      ]


-- | Construct a value of type 'CdashDomainFieldRefVersion' (by applying it's required fields, if any)
mkCdashDomainFieldRefVersion
  :: CdashDomainFieldRefVersion
mkCdashDomainFieldRefVersion =
  CdashDomainFieldRefVersion
  { cdashDomainFieldRefVersionHref = Nothing
  , cdashDomainFieldRefVersionTitle = Nothing
  , cdashDomainFieldRefVersionType = Nothing
  }

-- ** CdashDomainFields
-- | CdashDomainFields
data CdashDomainFields = CdashDomainFields
  { cdashDomainFieldsOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , cdashDomainFieldsName :: !(Maybe Text) -- ^ "name"
  , cdashDomainFieldsLabel :: !(Maybe Text) -- ^ "label"
  , cdashDomainFieldsLinks :: !(Maybe CdashDomainFieldsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashDomainFields
instance A.FromJSON CdashDomainFields where
  parseJSON = A.withObject "CdashDomainFields" $ \o ->
    CdashDomainFields
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "_links")

-- | ToJSON CdashDomainFields
instance A.ToJSON CdashDomainFields where
  toJSON CdashDomainFields {..} =
   _omitNulls
      [ "ordinal" .= cdashDomainFieldsOrdinal
      , "name" .= cdashDomainFieldsName
      , "label" .= cdashDomainFieldsLabel
      , "_links" .= cdashDomainFieldsLinks
      ]


-- | Construct a value of type 'CdashDomainFields' (by applying it's required fields, if any)
mkCdashDomainFields
  :: CdashDomainFields
mkCdashDomainFields =
  CdashDomainFields
  { cdashDomainFieldsOrdinal = Nothing
  , cdashDomainFieldsName = Nothing
  , cdashDomainFieldsLabel = Nothing
  , cdashDomainFieldsLinks = Nothing
  }

-- ** CdashDomainFieldsLinks
-- | CdashDomainFieldsLinks
data CdashDomainFieldsLinks = CdashDomainFieldsLinks
  { cdashDomainFieldsLinksSelf :: !(Maybe CdashDomainFieldsRef) -- ^ "self"
  , cdashDomainFieldsLinksParentProduct :: !(Maybe CdashProductRef) -- ^ "parentProduct"
  , cdashDomainFieldsLinksParentClass :: !(Maybe CdashClassRef) -- ^ "parentClass"
  , cdashDomainFieldsLinksFields :: !(Maybe [CdashDomainFieldRefElement]) -- ^ "fields"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashDomainFieldsLinks
instance A.FromJSON CdashDomainFieldsLinks where
  parseJSON = A.withObject "CdashDomainFieldsLinks" $ \o ->
    CdashDomainFieldsLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "fields")

-- | ToJSON CdashDomainFieldsLinks
instance A.ToJSON CdashDomainFieldsLinks where
  toJSON CdashDomainFieldsLinks {..} =
   _omitNulls
      [ "self" .= cdashDomainFieldsLinksSelf
      , "parentProduct" .= cdashDomainFieldsLinksParentProduct
      , "parentClass" .= cdashDomainFieldsLinksParentClass
      , "fields" .= cdashDomainFieldsLinksFields
      ]


-- | Construct a value of type 'CdashDomainFieldsLinks' (by applying it's required fields, if any)
mkCdashDomainFieldsLinks
  :: CdashDomainFieldsLinks
mkCdashDomainFieldsLinks =
  CdashDomainFieldsLinks
  { cdashDomainFieldsLinksSelf = Nothing
  , cdashDomainFieldsLinksParentProduct = Nothing
  , cdashDomainFieldsLinksParentClass = Nothing
  , cdashDomainFieldsLinksFields = Nothing
  }

-- ** CdashDomainFieldsRef
-- | CdashDomainFieldsRef
data CdashDomainFieldsRef = CdashDomainFieldsRef
  { cdashDomainFieldsRefHref :: !(Maybe Text) -- ^ "href"
  , cdashDomainFieldsRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashDomainFieldsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashDomainFieldsRef
instance A.FromJSON CdashDomainFieldsRef where
  parseJSON = A.withObject "CdashDomainFieldsRef" $ \o ->
    CdashDomainFieldsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashDomainFieldsRef
instance A.ToJSON CdashDomainFieldsRef where
  toJSON CdashDomainFieldsRef {..} =
   _omitNulls
      [ "href" .= cdashDomainFieldsRefHref
      , "title" .= cdashDomainFieldsRefTitle
      , "type" .= cdashDomainFieldsRefType
      ]


-- | Construct a value of type 'CdashDomainFieldsRef' (by applying it's required fields, if any)
mkCdashDomainFieldsRef
  :: CdashDomainFieldsRef
mkCdashDomainFieldsRef =
  CdashDomainFieldsRef
  { cdashDomainFieldsRefHref = Nothing
  , cdashDomainFieldsRefTitle = Nothing
  , cdashDomainFieldsRefType = Nothing
  }

-- ** CdashDomainLinks
-- | CdashDomainLinks
data CdashDomainLinks = CdashDomainLinks
  { cdashDomainLinksSelf :: !(Maybe CdashDomainRef) -- ^ "self"
  , cdashDomainLinksParentProduct :: !(Maybe CdashProductRef) -- ^ "parentProduct"
  , cdashDomainLinksParentClass :: !(Maybe CdashClassRef) -- ^ "parentClass"
  , cdashDomainLinksPriorVersion :: !(Maybe CdashDomainRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashDomainLinks
instance A.FromJSON CdashDomainLinks where
  parseJSON = A.withObject "CdashDomainLinks" $ \o ->
    CdashDomainLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "priorVersion")

-- | ToJSON CdashDomainLinks
instance A.ToJSON CdashDomainLinks where
  toJSON CdashDomainLinks {..} =
   _omitNulls
      [ "self" .= cdashDomainLinksSelf
      , "parentProduct" .= cdashDomainLinksParentProduct
      , "parentClass" .= cdashDomainLinksParentClass
      , "priorVersion" .= cdashDomainLinksPriorVersion
      ]


-- | Construct a value of type 'CdashDomainLinks' (by applying it's required fields, if any)
mkCdashDomainLinks
  :: CdashDomainLinks
mkCdashDomainLinks =
  CdashDomainLinks
  { cdashDomainLinksSelf = Nothing
  , cdashDomainLinksParentProduct = Nothing
  , cdashDomainLinksParentClass = Nothing
  , cdashDomainLinksPriorVersion = Nothing
  }

-- ** CdashDomainRef
-- | CdashDomainRef
data CdashDomainRef = CdashDomainRef
  { cdashDomainRefHref :: !(Maybe Text) -- ^ "href"
  , cdashDomainRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashDomainRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashDomainRef
instance A.FromJSON CdashDomainRef where
  parseJSON = A.withObject "CdashDomainRef" $ \o ->
    CdashDomainRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashDomainRef
instance A.ToJSON CdashDomainRef where
  toJSON CdashDomainRef {..} =
   _omitNulls
      [ "href" .= cdashDomainRefHref
      , "title" .= cdashDomainRefTitle
      , "type" .= cdashDomainRefType
      ]


-- | Construct a value of type 'CdashDomainRef' (by applying it's required fields, if any)
mkCdashDomainRef
  :: CdashDomainRef
mkCdashDomainRef =
  CdashDomainRef
  { cdashDomainRefHref = Nothing
  , cdashDomainRefTitle = Nothing
  , cdashDomainRefType = Nothing
  }

-- ** CdashDomainRefElement
-- | CdashDomainRefElement
data CdashDomainRefElement = CdashDomainRefElement
  { cdashDomainRefElementHref :: !(Maybe Text) -- ^ "href"
  , cdashDomainRefElementTitle :: !(Maybe Text) -- ^ "title"
  , cdashDomainRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashDomainRefElement
instance A.FromJSON CdashDomainRefElement where
  parseJSON = A.withObject "CdashDomainRefElement" $ \o ->
    CdashDomainRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashDomainRefElement
instance A.ToJSON CdashDomainRefElement where
  toJSON CdashDomainRefElement {..} =
   _omitNulls
      [ "href" .= cdashDomainRefElementHref
      , "title" .= cdashDomainRefElementTitle
      , "type" .= cdashDomainRefElementType
      ]


-- | Construct a value of type 'CdashDomainRefElement' (by applying it's required fields, if any)
mkCdashDomainRefElement
  :: CdashDomainRefElement
mkCdashDomainRefElement =
  CdashDomainRefElement
  { cdashDomainRefElementHref = Nothing
  , cdashDomainRefElementTitle = Nothing
  , cdashDomainRefElementType = Nothing
  }

-- ** CdashProduct
-- | CdashProduct
data CdashProduct = CdashProduct
  { cdashProductName :: !(Maybe Text) -- ^ "name"
  , cdashProductLabel :: !(Maybe Text) -- ^ "label"
  , cdashProductDescription :: !(Maybe Text) -- ^ "description"
  , cdashProductSource :: !(Maybe Text) -- ^ "source"
  , cdashProductEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , cdashProductRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , cdashProductVersion :: !(Maybe Text) -- ^ "version"
  , cdashProductLinks :: !(Maybe CdashProductLinks) -- ^ "_links"
  , cdashProductClasses :: !(Maybe [CdashClass]) -- ^ "classes"
  , cdashProductDomains :: !(Maybe [CdashDomain]) -- ^ "domains"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashProduct
instance A.FromJSON CdashProduct where
  parseJSON = A.withObject "CdashProduct" $ \o ->
    CdashProduct
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")
      <*> (o .:? "classes")
      <*> (o .:? "domains")

-- | ToJSON CdashProduct
instance A.ToJSON CdashProduct where
  toJSON CdashProduct {..} =
   _omitNulls
      [ "name" .= cdashProductName
      , "label" .= cdashProductLabel
      , "description" .= cdashProductDescription
      , "source" .= cdashProductSource
      , "effectiveDate" .= cdashProductEffectiveDate
      , "registrationStatus" .= cdashProductRegistrationStatus
      , "version" .= cdashProductVersion
      , "_links" .= cdashProductLinks
      , "classes" .= cdashProductClasses
      , "domains" .= cdashProductDomains
      ]


-- | Construct a value of type 'CdashProduct' (by applying it's required fields, if any)
mkCdashProduct
  :: CdashProduct
mkCdashProduct =
  CdashProduct
  { cdashProductName = Nothing
  , cdashProductLabel = Nothing
  , cdashProductDescription = Nothing
  , cdashProductSource = Nothing
  , cdashProductEffectiveDate = Nothing
  , cdashProductRegistrationStatus = Nothing
  , cdashProductVersion = Nothing
  , cdashProductLinks = Nothing
  , cdashProductClasses = Nothing
  , cdashProductDomains = Nothing
  }

-- ** CdashProductClasses
-- | CdashProductClasses
data CdashProductClasses = CdashProductClasses
  { cdashProductClassesName :: !(Maybe Text) -- ^ "name"
  , cdashProductClassesLabel :: !(Maybe Text) -- ^ "label"
  , cdashProductClassesDescription :: !(Maybe Text) -- ^ "description"
  , cdashProductClassesSource :: !(Maybe Text) -- ^ "source"
  , cdashProductClassesEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , cdashProductClassesRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , cdashProductClassesVersion :: !(Maybe Text) -- ^ "version"
  , cdashProductClassesLinks :: !(Maybe CdashProductClassesLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashProductClasses
instance A.FromJSON CdashProductClasses where
  parseJSON = A.withObject "CdashProductClasses" $ \o ->
    CdashProductClasses
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")

-- | ToJSON CdashProductClasses
instance A.ToJSON CdashProductClasses where
  toJSON CdashProductClasses {..} =
   _omitNulls
      [ "name" .= cdashProductClassesName
      , "label" .= cdashProductClassesLabel
      , "description" .= cdashProductClassesDescription
      , "source" .= cdashProductClassesSource
      , "effectiveDate" .= cdashProductClassesEffectiveDate
      , "registrationStatus" .= cdashProductClassesRegistrationStatus
      , "version" .= cdashProductClassesVersion
      , "_links" .= cdashProductClassesLinks
      ]


-- | Construct a value of type 'CdashProductClasses' (by applying it's required fields, if any)
mkCdashProductClasses
  :: CdashProductClasses
mkCdashProductClasses =
  CdashProductClasses
  { cdashProductClassesName = Nothing
  , cdashProductClassesLabel = Nothing
  , cdashProductClassesDescription = Nothing
  , cdashProductClassesSource = Nothing
  , cdashProductClassesEffectiveDate = Nothing
  , cdashProductClassesRegistrationStatus = Nothing
  , cdashProductClassesVersion = Nothing
  , cdashProductClassesLinks = Nothing
  }

-- ** CdashProductClassesLinks
-- | CdashProductClassesLinks
data CdashProductClassesLinks = CdashProductClassesLinks
  { cdashProductClassesLinksSelf :: !(Maybe CdashProductClassesRef) -- ^ "self"
  , cdashProductClassesLinksParentProduct :: !(Maybe CdashProductRef) -- ^ "parentProduct"
  , cdashProductClassesLinksClasses :: !(Maybe [CdashClassRefElement]) -- ^ "classes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashProductClassesLinks
instance A.FromJSON CdashProductClassesLinks where
  parseJSON = A.withObject "CdashProductClassesLinks" $ \o ->
    CdashProductClassesLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "classes")

-- | ToJSON CdashProductClassesLinks
instance A.ToJSON CdashProductClassesLinks where
  toJSON CdashProductClassesLinks {..} =
   _omitNulls
      [ "self" .= cdashProductClassesLinksSelf
      , "parentProduct" .= cdashProductClassesLinksParentProduct
      , "classes" .= cdashProductClassesLinksClasses
      ]


-- | Construct a value of type 'CdashProductClassesLinks' (by applying it's required fields, if any)
mkCdashProductClassesLinks
  :: CdashProductClassesLinks
mkCdashProductClassesLinks =
  CdashProductClassesLinks
  { cdashProductClassesLinksSelf = Nothing
  , cdashProductClassesLinksParentProduct = Nothing
  , cdashProductClassesLinksClasses = Nothing
  }

-- ** CdashProductClassesRef
-- | CdashProductClassesRef
data CdashProductClassesRef = CdashProductClassesRef
  { cdashProductClassesRefHref :: !(Maybe Text) -- ^ "href"
  , cdashProductClassesRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashProductClassesRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashProductClassesRef
instance A.FromJSON CdashProductClassesRef where
  parseJSON = A.withObject "CdashProductClassesRef" $ \o ->
    CdashProductClassesRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashProductClassesRef
instance A.ToJSON CdashProductClassesRef where
  toJSON CdashProductClassesRef {..} =
   _omitNulls
      [ "href" .= cdashProductClassesRefHref
      , "title" .= cdashProductClassesRefTitle
      , "type" .= cdashProductClassesRefType
      ]


-- | Construct a value of type 'CdashProductClassesRef' (by applying it's required fields, if any)
mkCdashProductClassesRef
  :: CdashProductClassesRef
mkCdashProductClassesRef =
  CdashProductClassesRef
  { cdashProductClassesRefHref = Nothing
  , cdashProductClassesRefTitle = Nothing
  , cdashProductClassesRefType = Nothing
  }

-- ** CdashProductDomains
-- | CdashProductDomains
data CdashProductDomains = CdashProductDomains
  { cdashProductDomainsName :: !(Maybe Text) -- ^ "name"
  , cdashProductDomainsLabel :: !(Maybe Text) -- ^ "label"
  , cdashProductDomainsDescription :: !(Maybe Text) -- ^ "description"
  , cdashProductDomainsSource :: !(Maybe Text) -- ^ "source"
  , cdashProductDomainsEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , cdashProductDomainsRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , cdashProductDomainsVersion :: !(Maybe Text) -- ^ "version"
  , cdashProductDomainsLinks :: !(Maybe CdashProductDomainsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashProductDomains
instance A.FromJSON CdashProductDomains where
  parseJSON = A.withObject "CdashProductDomains" $ \o ->
    CdashProductDomains
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")

-- | ToJSON CdashProductDomains
instance A.ToJSON CdashProductDomains where
  toJSON CdashProductDomains {..} =
   _omitNulls
      [ "name" .= cdashProductDomainsName
      , "label" .= cdashProductDomainsLabel
      , "description" .= cdashProductDomainsDescription
      , "source" .= cdashProductDomainsSource
      , "effectiveDate" .= cdashProductDomainsEffectiveDate
      , "registrationStatus" .= cdashProductDomainsRegistrationStatus
      , "version" .= cdashProductDomainsVersion
      , "_links" .= cdashProductDomainsLinks
      ]


-- | Construct a value of type 'CdashProductDomains' (by applying it's required fields, if any)
mkCdashProductDomains
  :: CdashProductDomains
mkCdashProductDomains =
  CdashProductDomains
  { cdashProductDomainsName = Nothing
  , cdashProductDomainsLabel = Nothing
  , cdashProductDomainsDescription = Nothing
  , cdashProductDomainsSource = Nothing
  , cdashProductDomainsEffectiveDate = Nothing
  , cdashProductDomainsRegistrationStatus = Nothing
  , cdashProductDomainsVersion = Nothing
  , cdashProductDomainsLinks = Nothing
  }

-- ** CdashProductDomainsLinks
-- | CdashProductDomainsLinks
data CdashProductDomainsLinks = CdashProductDomainsLinks
  { cdashProductDomainsLinksSelf :: !(Maybe CdashProductDomainsRef) -- ^ "self"
  , cdashProductDomainsLinksParentProduct :: !(Maybe CdashProductRef) -- ^ "parentProduct"
  , cdashProductDomainsLinksDomains :: !(Maybe [CdashDomainRefElement]) -- ^ "domains"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashProductDomainsLinks
instance A.FromJSON CdashProductDomainsLinks where
  parseJSON = A.withObject "CdashProductDomainsLinks" $ \o ->
    CdashProductDomainsLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "domains")

-- | ToJSON CdashProductDomainsLinks
instance A.ToJSON CdashProductDomainsLinks where
  toJSON CdashProductDomainsLinks {..} =
   _omitNulls
      [ "self" .= cdashProductDomainsLinksSelf
      , "parentProduct" .= cdashProductDomainsLinksParentProduct
      , "domains" .= cdashProductDomainsLinksDomains
      ]


-- | Construct a value of type 'CdashProductDomainsLinks' (by applying it's required fields, if any)
mkCdashProductDomainsLinks
  :: CdashProductDomainsLinks
mkCdashProductDomainsLinks =
  CdashProductDomainsLinks
  { cdashProductDomainsLinksSelf = Nothing
  , cdashProductDomainsLinksParentProduct = Nothing
  , cdashProductDomainsLinksDomains = Nothing
  }

-- ** CdashProductDomainsRef
-- | CdashProductDomainsRef
data CdashProductDomainsRef = CdashProductDomainsRef
  { cdashProductDomainsRefHref :: !(Maybe Text) -- ^ "href"
  , cdashProductDomainsRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashProductDomainsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashProductDomainsRef
instance A.FromJSON CdashProductDomainsRef where
  parseJSON = A.withObject "CdashProductDomainsRef" $ \o ->
    CdashProductDomainsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashProductDomainsRef
instance A.ToJSON CdashProductDomainsRef where
  toJSON CdashProductDomainsRef {..} =
   _omitNulls
      [ "href" .= cdashProductDomainsRefHref
      , "title" .= cdashProductDomainsRefTitle
      , "type" .= cdashProductDomainsRefType
      ]


-- | Construct a value of type 'CdashProductDomainsRef' (by applying it's required fields, if any)
mkCdashProductDomainsRef
  :: CdashProductDomainsRef
mkCdashProductDomainsRef =
  CdashProductDomainsRef
  { cdashProductDomainsRefHref = Nothing
  , cdashProductDomainsRefTitle = Nothing
  , cdashProductDomainsRefType = Nothing
  }

-- ** CdashProductLinks
-- | CdashProductLinks
data CdashProductLinks = CdashProductLinks
  { cdashProductLinksSelf :: !(Maybe CdashProductRef) -- ^ "self"
  , cdashProductLinksPriorVersion :: !(Maybe CdashProductRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashProductLinks
instance A.FromJSON CdashProductLinks where
  parseJSON = A.withObject "CdashProductLinks" $ \o ->
    CdashProductLinks
      <$> (o .:? "self")
      <*> (o .:? "priorVersion")

-- | ToJSON CdashProductLinks
instance A.ToJSON CdashProductLinks where
  toJSON CdashProductLinks {..} =
   _omitNulls
      [ "self" .= cdashProductLinksSelf
      , "priorVersion" .= cdashProductLinksPriorVersion
      ]


-- | Construct a value of type 'CdashProductLinks' (by applying it's required fields, if any)
mkCdashProductLinks
  :: CdashProductLinks
mkCdashProductLinks =
  CdashProductLinks
  { cdashProductLinksSelf = Nothing
  , cdashProductLinksPriorVersion = Nothing
  }

-- ** CdashProductRef
-- | CdashProductRef
data CdashProductRef = CdashProductRef
  { cdashProductRefHref :: !(Maybe Text) -- ^ "href"
  , cdashProductRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashProductRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashProductRef
instance A.FromJSON CdashProductRef where
  parseJSON = A.withObject "CdashProductRef" $ \o ->
    CdashProductRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashProductRef
instance A.ToJSON CdashProductRef where
  toJSON CdashProductRef {..} =
   _omitNulls
      [ "href" .= cdashProductRefHref
      , "title" .= cdashProductRefTitle
      , "type" .= cdashProductRefType
      ]


-- | Construct a value of type 'CdashProductRef' (by applying it's required fields, if any)
mkCdashProductRef
  :: CdashProductRef
mkCdashProductRef =
  CdashProductRef
  { cdashProductRefHref = Nothing
  , cdashProductRefTitle = Nothing
  , cdashProductRefType = Nothing
  }

-- ** CdashProductRefElement
-- | CdashProductRefElement
data CdashProductRefElement = CdashProductRefElement
  { cdashProductRefElementHref :: !(Maybe Text) -- ^ "href"
  , cdashProductRefElementTitle :: !(Maybe Text) -- ^ "title"
  , cdashProductRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashProductRefElement
instance A.FromJSON CdashProductRefElement where
  parseJSON = A.withObject "CdashProductRefElement" $ \o ->
    CdashProductRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashProductRefElement
instance A.ToJSON CdashProductRefElement where
  toJSON CdashProductRefElement {..} =
   _omitNulls
      [ "href" .= cdashProductRefElementHref
      , "title" .= cdashProductRefElementTitle
      , "type" .= cdashProductRefElementType
      ]


-- | Construct a value of type 'CdashProductRefElement' (by applying it's required fields, if any)
mkCdashProductRefElement
  :: CdashProductRefElement
mkCdashProductRefElement =
  CdashProductRefElement
  { cdashProductRefElementHref = Nothing
  , cdashProductRefElementTitle = Nothing
  , cdashProductRefElementType = Nothing
  }

-- ** CdashigClass
-- | CdashigClass
data CdashigClass = CdashigClass
  { cdashigClassOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , cdashigClassName :: !(Maybe Text) -- ^ "name"
  , cdashigClassLabel :: !(Maybe Text) -- ^ "label"
  , cdashigClassDescription :: !(Maybe Text) -- ^ "description"
  , cdashigClassLinks :: !(Maybe CdashigClassLinks) -- ^ "_links"
  , cdashigClassDomains :: !(Maybe [CdashigDomain]) -- ^ "domains"
  , cdashigClassScenarios :: !(Maybe [CdashigScenario]) -- ^ "scenarios"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigClass
instance A.FromJSON CdashigClass where
  parseJSON = A.withObject "CdashigClass" $ \o ->
    CdashigClass
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "_links")
      <*> (o .:? "domains")
      <*> (o .:? "scenarios")

-- | ToJSON CdashigClass
instance A.ToJSON CdashigClass where
  toJSON CdashigClass {..} =
   _omitNulls
      [ "ordinal" .= cdashigClassOrdinal
      , "name" .= cdashigClassName
      , "label" .= cdashigClassLabel
      , "description" .= cdashigClassDescription
      , "_links" .= cdashigClassLinks
      , "domains" .= cdashigClassDomains
      , "scenarios" .= cdashigClassScenarios
      ]


-- | Construct a value of type 'CdashigClass' (by applying it's required fields, if any)
mkCdashigClass
  :: CdashigClass
mkCdashigClass =
  CdashigClass
  { cdashigClassOrdinal = Nothing
  , cdashigClassName = Nothing
  , cdashigClassLabel = Nothing
  , cdashigClassDescription = Nothing
  , cdashigClassLinks = Nothing
  , cdashigClassDomains = Nothing
  , cdashigClassScenarios = Nothing
  }

-- ** CdashigClassDomains
-- | CdashigClassDomains
data CdashigClassDomains = CdashigClassDomains
  { cdashigClassDomainsOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , cdashigClassDomainsName :: !(Maybe Text) -- ^ "name"
  , cdashigClassDomainsLabel :: !(Maybe Text) -- ^ "label"
  , cdashigClassDomainsDescription :: !(Maybe Text) -- ^ "description"
  , cdashigClassDomainsLinks :: !(Maybe CdashigClassDomainsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigClassDomains
instance A.FromJSON CdashigClassDomains where
  parseJSON = A.withObject "CdashigClassDomains" $ \o ->
    CdashigClassDomains
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "_links")

-- | ToJSON CdashigClassDomains
instance A.ToJSON CdashigClassDomains where
  toJSON CdashigClassDomains {..} =
   _omitNulls
      [ "ordinal" .= cdashigClassDomainsOrdinal
      , "name" .= cdashigClassDomainsName
      , "label" .= cdashigClassDomainsLabel
      , "description" .= cdashigClassDomainsDescription
      , "_links" .= cdashigClassDomainsLinks
      ]


-- | Construct a value of type 'CdashigClassDomains' (by applying it's required fields, if any)
mkCdashigClassDomains
  :: CdashigClassDomains
mkCdashigClassDomains =
  CdashigClassDomains
  { cdashigClassDomainsOrdinal = Nothing
  , cdashigClassDomainsName = Nothing
  , cdashigClassDomainsLabel = Nothing
  , cdashigClassDomainsDescription = Nothing
  , cdashigClassDomainsLinks = Nothing
  }

-- ** CdashigClassDomainsLinks
-- | CdashigClassDomainsLinks
data CdashigClassDomainsLinks = CdashigClassDomainsLinks
  { cdashigClassDomainsLinksSelf :: !(Maybe CdashigClassDomainsRef) -- ^ "self"
  , cdashigClassDomainsLinksDomains :: !(Maybe [CdashigDomainRefElement]) -- ^ "domains"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigClassDomainsLinks
instance A.FromJSON CdashigClassDomainsLinks where
  parseJSON = A.withObject "CdashigClassDomainsLinks" $ \o ->
    CdashigClassDomainsLinks
      <$> (o .:? "self")
      <*> (o .:? "domains")

-- | ToJSON CdashigClassDomainsLinks
instance A.ToJSON CdashigClassDomainsLinks where
  toJSON CdashigClassDomainsLinks {..} =
   _omitNulls
      [ "self" .= cdashigClassDomainsLinksSelf
      , "domains" .= cdashigClassDomainsLinksDomains
      ]


-- | Construct a value of type 'CdashigClassDomainsLinks' (by applying it's required fields, if any)
mkCdashigClassDomainsLinks
  :: CdashigClassDomainsLinks
mkCdashigClassDomainsLinks =
  CdashigClassDomainsLinks
  { cdashigClassDomainsLinksSelf = Nothing
  , cdashigClassDomainsLinksDomains = Nothing
  }

-- ** CdashigClassDomainsRef
-- | CdashigClassDomainsRef
data CdashigClassDomainsRef = CdashigClassDomainsRef
  { cdashigClassDomainsRefHref :: !(Maybe Text) -- ^ "href"
  , cdashigClassDomainsRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashigClassDomainsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigClassDomainsRef
instance A.FromJSON CdashigClassDomainsRef where
  parseJSON = A.withObject "CdashigClassDomainsRef" $ \o ->
    CdashigClassDomainsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigClassDomainsRef
instance A.ToJSON CdashigClassDomainsRef where
  toJSON CdashigClassDomainsRef {..} =
   _omitNulls
      [ "href" .= cdashigClassDomainsRefHref
      , "title" .= cdashigClassDomainsRefTitle
      , "type" .= cdashigClassDomainsRefType
      ]


-- | Construct a value of type 'CdashigClassDomainsRef' (by applying it's required fields, if any)
mkCdashigClassDomainsRef
  :: CdashigClassDomainsRef
mkCdashigClassDomainsRef =
  CdashigClassDomainsRef
  { cdashigClassDomainsRefHref = Nothing
  , cdashigClassDomainsRefTitle = Nothing
  , cdashigClassDomainsRefType = Nothing
  }

-- ** CdashigClassLinks
-- | CdashigClassLinks
data CdashigClassLinks = CdashigClassLinks
  { cdashigClassLinksSelf :: !(Maybe CdashigClassRef) -- ^ "self"
  , cdashigClassLinksModelClass :: !(Maybe CdashClassRef) -- ^ "modelClass"
  , cdashigClassLinksParentProduct :: !(Maybe CdashigProductRef) -- ^ "parentProduct"
  , cdashigClassLinksParentClass :: !(Maybe CdashigClassRef) -- ^ "parentClass"
  , cdashigClassLinksSubclasses :: !(Maybe [CdashigClassRefSubclass]) -- ^ "subclasses"
  , cdashigClassLinksPriorVersion :: !(Maybe CdashigClassRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigClassLinks
instance A.FromJSON CdashigClassLinks where
  parseJSON = A.withObject "CdashigClassLinks" $ \o ->
    CdashigClassLinks
      <$> (o .:? "self")
      <*> (o .:? "modelClass")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "subclasses")
      <*> (o .:? "priorVersion")

-- | ToJSON CdashigClassLinks
instance A.ToJSON CdashigClassLinks where
  toJSON CdashigClassLinks {..} =
   _omitNulls
      [ "self" .= cdashigClassLinksSelf
      , "modelClass" .= cdashigClassLinksModelClass
      , "parentProduct" .= cdashigClassLinksParentProduct
      , "parentClass" .= cdashigClassLinksParentClass
      , "subclasses" .= cdashigClassLinksSubclasses
      , "priorVersion" .= cdashigClassLinksPriorVersion
      ]


-- | Construct a value of type 'CdashigClassLinks' (by applying it's required fields, if any)
mkCdashigClassLinks
  :: CdashigClassLinks
mkCdashigClassLinks =
  CdashigClassLinks
  { cdashigClassLinksSelf = Nothing
  , cdashigClassLinksModelClass = Nothing
  , cdashigClassLinksParentProduct = Nothing
  , cdashigClassLinksParentClass = Nothing
  , cdashigClassLinksSubclasses = Nothing
  , cdashigClassLinksPriorVersion = Nothing
  }

-- ** CdashigClassRef
-- | CdashigClassRef
data CdashigClassRef = CdashigClassRef
  { cdashigClassRefHref :: !(Maybe Text) -- ^ "href"
  , cdashigClassRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashigClassRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigClassRef
instance A.FromJSON CdashigClassRef where
  parseJSON = A.withObject "CdashigClassRef" $ \o ->
    CdashigClassRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigClassRef
instance A.ToJSON CdashigClassRef where
  toJSON CdashigClassRef {..} =
   _omitNulls
      [ "href" .= cdashigClassRefHref
      , "title" .= cdashigClassRefTitle
      , "type" .= cdashigClassRefType
      ]


-- | Construct a value of type 'CdashigClassRef' (by applying it's required fields, if any)
mkCdashigClassRef
  :: CdashigClassRef
mkCdashigClassRef =
  CdashigClassRef
  { cdashigClassRefHref = Nothing
  , cdashigClassRefTitle = Nothing
  , cdashigClassRefType = Nothing
  }

-- ** CdashigClassRefElement
-- | CdashigClassRefElement
data CdashigClassRefElement = CdashigClassRefElement
  { cdashigClassRefElementHref :: !(Maybe Text) -- ^ "href"
  , cdashigClassRefElementTitle :: !(Maybe Text) -- ^ "title"
  , cdashigClassRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigClassRefElement
instance A.FromJSON CdashigClassRefElement where
  parseJSON = A.withObject "CdashigClassRefElement" $ \o ->
    CdashigClassRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigClassRefElement
instance A.ToJSON CdashigClassRefElement where
  toJSON CdashigClassRefElement {..} =
   _omitNulls
      [ "href" .= cdashigClassRefElementHref
      , "title" .= cdashigClassRefElementTitle
      , "type" .= cdashigClassRefElementType
      ]


-- | Construct a value of type 'CdashigClassRefElement' (by applying it's required fields, if any)
mkCdashigClassRefElement
  :: CdashigClassRefElement
mkCdashigClassRefElement =
  CdashigClassRefElement
  { cdashigClassRefElementHref = Nothing
  , cdashigClassRefElementTitle = Nothing
  , cdashigClassRefElementType = Nothing
  }

-- ** CdashigClassRefSubclass
-- | CdashigClassRefSubclass
data CdashigClassRefSubclass = CdashigClassRefSubclass
  { cdashigClassRefSubclassHref :: !(Maybe Text) -- ^ "href"
  , cdashigClassRefSubclassTitle :: !(Maybe Text) -- ^ "title"
  , cdashigClassRefSubclassType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigClassRefSubclass
instance A.FromJSON CdashigClassRefSubclass where
  parseJSON = A.withObject "CdashigClassRefSubclass" $ \o ->
    CdashigClassRefSubclass
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigClassRefSubclass
instance A.ToJSON CdashigClassRefSubclass where
  toJSON CdashigClassRefSubclass {..} =
   _omitNulls
      [ "href" .= cdashigClassRefSubclassHref
      , "title" .= cdashigClassRefSubclassTitle
      , "type" .= cdashigClassRefSubclassType
      ]


-- | Construct a value of type 'CdashigClassRefSubclass' (by applying it's required fields, if any)
mkCdashigClassRefSubclass
  :: CdashigClassRefSubclass
mkCdashigClassRefSubclass =
  CdashigClassRefSubclass
  { cdashigClassRefSubclassHref = Nothing
  , cdashigClassRefSubclassTitle = Nothing
  , cdashigClassRefSubclassType = Nothing
  }

-- ** CdashigClassScenarios
-- | CdashigClassScenarios
data CdashigClassScenarios = CdashigClassScenarios
  { cdashigClassScenariosOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , cdashigClassScenariosName :: !(Maybe Text) -- ^ "name"
  , cdashigClassScenariosLabel :: !(Maybe Text) -- ^ "label"
  , cdashigClassScenariosDescription :: !(Maybe Text) -- ^ "description"
  , cdashigClassScenariosLinks :: !(Maybe CdashigClassScenariosLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigClassScenarios
instance A.FromJSON CdashigClassScenarios where
  parseJSON = A.withObject "CdashigClassScenarios" $ \o ->
    CdashigClassScenarios
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "_links")

-- | ToJSON CdashigClassScenarios
instance A.ToJSON CdashigClassScenarios where
  toJSON CdashigClassScenarios {..} =
   _omitNulls
      [ "ordinal" .= cdashigClassScenariosOrdinal
      , "name" .= cdashigClassScenariosName
      , "label" .= cdashigClassScenariosLabel
      , "description" .= cdashigClassScenariosDescription
      , "_links" .= cdashigClassScenariosLinks
      ]


-- | Construct a value of type 'CdashigClassScenarios' (by applying it's required fields, if any)
mkCdashigClassScenarios
  :: CdashigClassScenarios
mkCdashigClassScenarios =
  CdashigClassScenarios
  { cdashigClassScenariosOrdinal = Nothing
  , cdashigClassScenariosName = Nothing
  , cdashigClassScenariosLabel = Nothing
  , cdashigClassScenariosDescription = Nothing
  , cdashigClassScenariosLinks = Nothing
  }

-- ** CdashigClassScenariosLinks
-- | CdashigClassScenariosLinks
data CdashigClassScenariosLinks = CdashigClassScenariosLinks
  { cdashigClassScenariosLinksSelf :: !(Maybe CdashigClassScenariosRef) -- ^ "self"
  , cdashigClassScenariosLinksScenarios :: !(Maybe [CdashigScenarioRefElement]) -- ^ "scenarios"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigClassScenariosLinks
instance A.FromJSON CdashigClassScenariosLinks where
  parseJSON = A.withObject "CdashigClassScenariosLinks" $ \o ->
    CdashigClassScenariosLinks
      <$> (o .:? "self")
      <*> (o .:? "scenarios")

-- | ToJSON CdashigClassScenariosLinks
instance A.ToJSON CdashigClassScenariosLinks where
  toJSON CdashigClassScenariosLinks {..} =
   _omitNulls
      [ "self" .= cdashigClassScenariosLinksSelf
      , "scenarios" .= cdashigClassScenariosLinksScenarios
      ]


-- | Construct a value of type 'CdashigClassScenariosLinks' (by applying it's required fields, if any)
mkCdashigClassScenariosLinks
  :: CdashigClassScenariosLinks
mkCdashigClassScenariosLinks =
  CdashigClassScenariosLinks
  { cdashigClassScenariosLinksSelf = Nothing
  , cdashigClassScenariosLinksScenarios = Nothing
  }

-- ** CdashigClassScenariosRef
-- | CdashigClassScenariosRef
data CdashigClassScenariosRef = CdashigClassScenariosRef
  { cdashigClassScenariosRefHref :: !(Maybe Text) -- ^ "href"
  , cdashigClassScenariosRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashigClassScenariosRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigClassScenariosRef
instance A.FromJSON CdashigClassScenariosRef where
  parseJSON = A.withObject "CdashigClassScenariosRef" $ \o ->
    CdashigClassScenariosRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigClassScenariosRef
instance A.ToJSON CdashigClassScenariosRef where
  toJSON CdashigClassScenariosRef {..} =
   _omitNulls
      [ "href" .= cdashigClassScenariosRefHref
      , "title" .= cdashigClassScenariosRefTitle
      , "type" .= cdashigClassScenariosRefType
      ]


-- | Construct a value of type 'CdashigClassScenariosRef' (by applying it's required fields, if any)
mkCdashigClassScenariosRef
  :: CdashigClassScenariosRef
mkCdashigClassScenariosRef =
  CdashigClassScenariosRef
  { cdashigClassScenariosRefHref = Nothing
  , cdashigClassScenariosRefTitle = Nothing
  , cdashigClassScenariosRefType = Nothing
  }

-- ** CdashigDomain
-- | CdashigDomain
data CdashigDomain = CdashigDomain
  { cdashigDomainOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , cdashigDomainName :: !(Maybe Text) -- ^ "name"
  , cdashigDomainLabel :: !(Maybe Text) -- ^ "label"
  , cdashigDomainLinks :: !(Maybe CdashigDomainLinks) -- ^ "_links"
  , cdashigDomainFields :: !(Maybe [CdashigDomainField]) -- ^ "fields"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigDomain
instance A.FromJSON CdashigDomain where
  parseJSON = A.withObject "CdashigDomain" $ \o ->
    CdashigDomain
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "_links")
      <*> (o .:? "fields")

-- | ToJSON CdashigDomain
instance A.ToJSON CdashigDomain where
  toJSON CdashigDomain {..} =
   _omitNulls
      [ "ordinal" .= cdashigDomainOrdinal
      , "name" .= cdashigDomainName
      , "label" .= cdashigDomainLabel
      , "_links" .= cdashigDomainLinks
      , "fields" .= cdashigDomainFields
      ]


-- | Construct a value of type 'CdashigDomain' (by applying it's required fields, if any)
mkCdashigDomain
  :: CdashigDomain
mkCdashigDomain =
  CdashigDomain
  { cdashigDomainOrdinal = Nothing
  , cdashigDomainName = Nothing
  , cdashigDomainLabel = Nothing
  , cdashigDomainLinks = Nothing
  , cdashigDomainFields = Nothing
  }

-- ** CdashigDomainField
-- | CdashigDomainField
data CdashigDomainField = CdashigDomainField
  { cdashigDomainFieldOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , cdashigDomainFieldName :: !(Maybe Text) -- ^ "name"
  , cdashigDomainFieldLabel :: !(Maybe Text) -- ^ "label"
  , cdashigDomainFieldDefinition :: !(Maybe Text) -- ^ "definition"
  , cdashigDomainFieldQuestionText :: !(Maybe Text) -- ^ "questionText"
  , cdashigDomainFieldPrompt :: !(Maybe Text) -- ^ "prompt"
  , cdashigDomainFieldCompletionInstructions :: !(Maybe Text) -- ^ "completionInstructions"
  , cdashigDomainFieldImplementationNotes :: !(Maybe Text) -- ^ "implementationNotes"
  , cdashigDomainFieldSimpleDatatype :: !(Maybe Text) -- ^ "simpleDatatype"
  , cdashigDomainFieldMappingInstructions :: !(Maybe Text) -- ^ "mappingInstructions"
  , cdashigDomainFieldCore :: !(Maybe Text) -- ^ "core"
  , cdashigDomainFieldLinks :: !(Maybe CdashigDomainFieldLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigDomainField
instance A.FromJSON CdashigDomainField where
  parseJSON = A.withObject "CdashigDomainField" $ \o ->
    CdashigDomainField
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "definition")
      <*> (o .:? "questionText")
      <*> (o .:? "prompt")
      <*> (o .:? "completionInstructions")
      <*> (o .:? "implementationNotes")
      <*> (o .:? "simpleDatatype")
      <*> (o .:? "mappingInstructions")
      <*> (o .:? "core")
      <*> (o .:? "_links")

-- | ToJSON CdashigDomainField
instance A.ToJSON CdashigDomainField where
  toJSON CdashigDomainField {..} =
   _omitNulls
      [ "ordinal" .= cdashigDomainFieldOrdinal
      , "name" .= cdashigDomainFieldName
      , "label" .= cdashigDomainFieldLabel
      , "definition" .= cdashigDomainFieldDefinition
      , "questionText" .= cdashigDomainFieldQuestionText
      , "prompt" .= cdashigDomainFieldPrompt
      , "completionInstructions" .= cdashigDomainFieldCompletionInstructions
      , "implementationNotes" .= cdashigDomainFieldImplementationNotes
      , "simpleDatatype" .= cdashigDomainFieldSimpleDatatype
      , "mappingInstructions" .= cdashigDomainFieldMappingInstructions
      , "core" .= cdashigDomainFieldCore
      , "_links" .= cdashigDomainFieldLinks
      ]


-- | Construct a value of type 'CdashigDomainField' (by applying it's required fields, if any)
mkCdashigDomainField
  :: CdashigDomainField
mkCdashigDomainField =
  CdashigDomainField
  { cdashigDomainFieldOrdinal = Nothing
  , cdashigDomainFieldName = Nothing
  , cdashigDomainFieldLabel = Nothing
  , cdashigDomainFieldDefinition = Nothing
  , cdashigDomainFieldQuestionText = Nothing
  , cdashigDomainFieldPrompt = Nothing
  , cdashigDomainFieldCompletionInstructions = Nothing
  , cdashigDomainFieldImplementationNotes = Nothing
  , cdashigDomainFieldSimpleDatatype = Nothing
  , cdashigDomainFieldMappingInstructions = Nothing
  , cdashigDomainFieldCore = Nothing
  , cdashigDomainFieldLinks = Nothing
  }

-- ** CdashigDomainFieldLinks
-- | CdashigDomainFieldLinks
data CdashigDomainFieldLinks = CdashigDomainFieldLinks
  { cdashigDomainFieldLinksSelf :: !(Maybe CdashigDomainFieldRef) -- ^ "self"
  , cdashigDomainFieldLinksCodelist :: !(Maybe [RootCtCodelistRefElement]) -- ^ "codelist"
  , cdashigDomainFieldLinksParentProduct :: !(Maybe CdashigProductRef) -- ^ "parentProduct"
  , cdashigDomainFieldLinksParentDomain :: !(Maybe CdashigDomainRef) -- ^ "parentDomain"
  , cdashigDomainFieldLinksRootItem :: !(Maybe RootCdashigDomainFieldRef) -- ^ "rootItem"
  , cdashigDomainFieldLinksPriorVersion :: !(Maybe CdashigDomainFieldRef) -- ^ "priorVersion"
  , cdashigDomainFieldLinksSdtmClassMappingTargets :: !(Maybe [SdtmClassVariableRefTarget]) -- ^ "sdtmClassMappingTargets"
  , cdashigDomainFieldLinksSdtmigDatasetMappingTargets :: !(Maybe [SdtmigDatasetVariableRefTarget]) -- ^ "sdtmigDatasetMappingTargets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigDomainFieldLinks
instance A.FromJSON CdashigDomainFieldLinks where
  parseJSON = A.withObject "CdashigDomainFieldLinks" $ \o ->
    CdashigDomainFieldLinks
      <$> (o .:? "self")
      <*> (o .:? "codelist")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentDomain")
      <*> (o .:? "rootItem")
      <*> (o .:? "priorVersion")
      <*> (o .:? "sdtmClassMappingTargets")
      <*> (o .:? "sdtmigDatasetMappingTargets")

-- | ToJSON CdashigDomainFieldLinks
instance A.ToJSON CdashigDomainFieldLinks where
  toJSON CdashigDomainFieldLinks {..} =
   _omitNulls
      [ "self" .= cdashigDomainFieldLinksSelf
      , "codelist" .= cdashigDomainFieldLinksCodelist
      , "parentProduct" .= cdashigDomainFieldLinksParentProduct
      , "parentDomain" .= cdashigDomainFieldLinksParentDomain
      , "rootItem" .= cdashigDomainFieldLinksRootItem
      , "priorVersion" .= cdashigDomainFieldLinksPriorVersion
      , "sdtmClassMappingTargets" .= cdashigDomainFieldLinksSdtmClassMappingTargets
      , "sdtmigDatasetMappingTargets" .= cdashigDomainFieldLinksSdtmigDatasetMappingTargets
      ]


-- | Construct a value of type 'CdashigDomainFieldLinks' (by applying it's required fields, if any)
mkCdashigDomainFieldLinks
  :: CdashigDomainFieldLinks
mkCdashigDomainFieldLinks =
  CdashigDomainFieldLinks
  { cdashigDomainFieldLinksSelf = Nothing
  , cdashigDomainFieldLinksCodelist = Nothing
  , cdashigDomainFieldLinksParentProduct = Nothing
  , cdashigDomainFieldLinksParentDomain = Nothing
  , cdashigDomainFieldLinksRootItem = Nothing
  , cdashigDomainFieldLinksPriorVersion = Nothing
  , cdashigDomainFieldLinksSdtmClassMappingTargets = Nothing
  , cdashigDomainFieldLinksSdtmigDatasetMappingTargets = Nothing
  }

-- ** CdashigDomainFieldRef
-- | CdashigDomainFieldRef
data CdashigDomainFieldRef = CdashigDomainFieldRef
  { cdashigDomainFieldRefHref :: !(Maybe Text) -- ^ "href"
  , cdashigDomainFieldRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashigDomainFieldRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigDomainFieldRef
instance A.FromJSON CdashigDomainFieldRef where
  parseJSON = A.withObject "CdashigDomainFieldRef" $ \o ->
    CdashigDomainFieldRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigDomainFieldRef
instance A.ToJSON CdashigDomainFieldRef where
  toJSON CdashigDomainFieldRef {..} =
   _omitNulls
      [ "href" .= cdashigDomainFieldRefHref
      , "title" .= cdashigDomainFieldRefTitle
      , "type" .= cdashigDomainFieldRefType
      ]


-- | Construct a value of type 'CdashigDomainFieldRef' (by applying it's required fields, if any)
mkCdashigDomainFieldRef
  :: CdashigDomainFieldRef
mkCdashigDomainFieldRef =
  CdashigDomainFieldRef
  { cdashigDomainFieldRefHref = Nothing
  , cdashigDomainFieldRefTitle = Nothing
  , cdashigDomainFieldRefType = Nothing
  }

-- ** CdashigDomainFieldRefElement
-- | CdashigDomainFieldRefElement
data CdashigDomainFieldRefElement = CdashigDomainFieldRefElement
  { cdashigDomainFieldRefElementHref :: !(Maybe Text) -- ^ "href"
  , cdashigDomainFieldRefElementTitle :: !(Maybe Text) -- ^ "title"
  , cdashigDomainFieldRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigDomainFieldRefElement
instance A.FromJSON CdashigDomainFieldRefElement where
  parseJSON = A.withObject "CdashigDomainFieldRefElement" $ \o ->
    CdashigDomainFieldRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigDomainFieldRefElement
instance A.ToJSON CdashigDomainFieldRefElement where
  toJSON CdashigDomainFieldRefElement {..} =
   _omitNulls
      [ "href" .= cdashigDomainFieldRefElementHref
      , "title" .= cdashigDomainFieldRefElementTitle
      , "type" .= cdashigDomainFieldRefElementType
      ]


-- | Construct a value of type 'CdashigDomainFieldRefElement' (by applying it's required fields, if any)
mkCdashigDomainFieldRefElement
  :: CdashigDomainFieldRefElement
mkCdashigDomainFieldRefElement =
  CdashigDomainFieldRefElement
  { cdashigDomainFieldRefElementHref = Nothing
  , cdashigDomainFieldRefElementTitle = Nothing
  , cdashigDomainFieldRefElementType = Nothing
  }

-- ** CdashigDomainFieldRefVersion
-- | CdashigDomainFieldRefVersion
data CdashigDomainFieldRefVersion = CdashigDomainFieldRefVersion
  { cdashigDomainFieldRefVersionHref :: !(Maybe Text) -- ^ "href"
  , cdashigDomainFieldRefVersionTitle :: !(Maybe Text) -- ^ "title"
  , cdashigDomainFieldRefVersionType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigDomainFieldRefVersion
instance A.FromJSON CdashigDomainFieldRefVersion where
  parseJSON = A.withObject "CdashigDomainFieldRefVersion" $ \o ->
    CdashigDomainFieldRefVersion
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigDomainFieldRefVersion
instance A.ToJSON CdashigDomainFieldRefVersion where
  toJSON CdashigDomainFieldRefVersion {..} =
   _omitNulls
      [ "href" .= cdashigDomainFieldRefVersionHref
      , "title" .= cdashigDomainFieldRefVersionTitle
      , "type" .= cdashigDomainFieldRefVersionType
      ]


-- | Construct a value of type 'CdashigDomainFieldRefVersion' (by applying it's required fields, if any)
mkCdashigDomainFieldRefVersion
  :: CdashigDomainFieldRefVersion
mkCdashigDomainFieldRefVersion =
  CdashigDomainFieldRefVersion
  { cdashigDomainFieldRefVersionHref = Nothing
  , cdashigDomainFieldRefVersionTitle = Nothing
  , cdashigDomainFieldRefVersionType = Nothing
  }

-- ** CdashigDomainFields
-- | CdashigDomainFields
data CdashigDomainFields = CdashigDomainFields
  { cdashigDomainFieldsOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , cdashigDomainFieldsName :: !(Maybe Text) -- ^ "name"
  , cdashigDomainFieldsLabel :: !(Maybe Text) -- ^ "label"
  , cdashigDomainFieldsLinks :: !(Maybe CdashigDomainFieldsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigDomainFields
instance A.FromJSON CdashigDomainFields where
  parseJSON = A.withObject "CdashigDomainFields" $ \o ->
    CdashigDomainFields
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "_links")

-- | ToJSON CdashigDomainFields
instance A.ToJSON CdashigDomainFields where
  toJSON CdashigDomainFields {..} =
   _omitNulls
      [ "ordinal" .= cdashigDomainFieldsOrdinal
      , "name" .= cdashigDomainFieldsName
      , "label" .= cdashigDomainFieldsLabel
      , "_links" .= cdashigDomainFieldsLinks
      ]


-- | Construct a value of type 'CdashigDomainFields' (by applying it's required fields, if any)
mkCdashigDomainFields
  :: CdashigDomainFields
mkCdashigDomainFields =
  CdashigDomainFields
  { cdashigDomainFieldsOrdinal = Nothing
  , cdashigDomainFieldsName = Nothing
  , cdashigDomainFieldsLabel = Nothing
  , cdashigDomainFieldsLinks = Nothing
  }

-- ** CdashigDomainFieldsLinks
-- | CdashigDomainFieldsLinks
data CdashigDomainFieldsLinks = CdashigDomainFieldsLinks
  { cdashigDomainFieldsLinksSelf :: !(Maybe CdashigDomainFieldsRef) -- ^ "self"
  , cdashigDomainFieldsLinksParentProduct :: !(Maybe CdashigProductRef) -- ^ "parentProduct"
  , cdashigDomainFieldsLinksParentClass :: !(Maybe CdashigClassRef) -- ^ "parentClass"
  , cdashigDomainFieldsLinksFields :: !(Maybe [CdashigDomainFieldRefElement]) -- ^ "fields"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigDomainFieldsLinks
instance A.FromJSON CdashigDomainFieldsLinks where
  parseJSON = A.withObject "CdashigDomainFieldsLinks" $ \o ->
    CdashigDomainFieldsLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "fields")

-- | ToJSON CdashigDomainFieldsLinks
instance A.ToJSON CdashigDomainFieldsLinks where
  toJSON CdashigDomainFieldsLinks {..} =
   _omitNulls
      [ "self" .= cdashigDomainFieldsLinksSelf
      , "parentProduct" .= cdashigDomainFieldsLinksParentProduct
      , "parentClass" .= cdashigDomainFieldsLinksParentClass
      , "fields" .= cdashigDomainFieldsLinksFields
      ]


-- | Construct a value of type 'CdashigDomainFieldsLinks' (by applying it's required fields, if any)
mkCdashigDomainFieldsLinks
  :: CdashigDomainFieldsLinks
mkCdashigDomainFieldsLinks =
  CdashigDomainFieldsLinks
  { cdashigDomainFieldsLinksSelf = Nothing
  , cdashigDomainFieldsLinksParentProduct = Nothing
  , cdashigDomainFieldsLinksParentClass = Nothing
  , cdashigDomainFieldsLinksFields = Nothing
  }

-- ** CdashigDomainFieldsRef
-- | CdashigDomainFieldsRef
data CdashigDomainFieldsRef = CdashigDomainFieldsRef
  { cdashigDomainFieldsRefHref :: !(Maybe Text) -- ^ "href"
  , cdashigDomainFieldsRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashigDomainFieldsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigDomainFieldsRef
instance A.FromJSON CdashigDomainFieldsRef where
  parseJSON = A.withObject "CdashigDomainFieldsRef" $ \o ->
    CdashigDomainFieldsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigDomainFieldsRef
instance A.ToJSON CdashigDomainFieldsRef where
  toJSON CdashigDomainFieldsRef {..} =
   _omitNulls
      [ "href" .= cdashigDomainFieldsRefHref
      , "title" .= cdashigDomainFieldsRefTitle
      , "type" .= cdashigDomainFieldsRefType
      ]


-- | Construct a value of type 'CdashigDomainFieldsRef' (by applying it's required fields, if any)
mkCdashigDomainFieldsRef
  :: CdashigDomainFieldsRef
mkCdashigDomainFieldsRef =
  CdashigDomainFieldsRef
  { cdashigDomainFieldsRefHref = Nothing
  , cdashigDomainFieldsRefTitle = Nothing
  , cdashigDomainFieldsRefType = Nothing
  }

-- ** CdashigDomainLinks
-- | CdashigDomainLinks
data CdashigDomainLinks = CdashigDomainLinks
  { cdashigDomainLinksSelf :: !(Maybe CdashigDomainRef) -- ^ "self"
  , cdashigDomainLinksParentProduct :: !(Maybe CdashigProductRef) -- ^ "parentProduct"
  , cdashigDomainLinksParentClass :: !(Maybe CdashigClassRef) -- ^ "parentClass"
  , cdashigDomainLinksPriorVersion :: !(Maybe CdashigDomainRef) -- ^ "priorVersion"
  , cdashigDomainLinksScenarios :: !(Maybe [CdashigScenarioRefElement]) -- ^ "scenarios"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigDomainLinks
instance A.FromJSON CdashigDomainLinks where
  parseJSON = A.withObject "CdashigDomainLinks" $ \o ->
    CdashigDomainLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "priorVersion")
      <*> (o .:? "scenarios")

-- | ToJSON CdashigDomainLinks
instance A.ToJSON CdashigDomainLinks where
  toJSON CdashigDomainLinks {..} =
   _omitNulls
      [ "self" .= cdashigDomainLinksSelf
      , "parentProduct" .= cdashigDomainLinksParentProduct
      , "parentClass" .= cdashigDomainLinksParentClass
      , "priorVersion" .= cdashigDomainLinksPriorVersion
      , "scenarios" .= cdashigDomainLinksScenarios
      ]


-- | Construct a value of type 'CdashigDomainLinks' (by applying it's required fields, if any)
mkCdashigDomainLinks
  :: CdashigDomainLinks
mkCdashigDomainLinks =
  CdashigDomainLinks
  { cdashigDomainLinksSelf = Nothing
  , cdashigDomainLinksParentProduct = Nothing
  , cdashigDomainLinksParentClass = Nothing
  , cdashigDomainLinksPriorVersion = Nothing
  , cdashigDomainLinksScenarios = Nothing
  }

-- ** CdashigDomainRef
-- | CdashigDomainRef
data CdashigDomainRef = CdashigDomainRef
  { cdashigDomainRefHref :: !(Maybe Text) -- ^ "href"
  , cdashigDomainRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashigDomainRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigDomainRef
instance A.FromJSON CdashigDomainRef where
  parseJSON = A.withObject "CdashigDomainRef" $ \o ->
    CdashigDomainRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigDomainRef
instance A.ToJSON CdashigDomainRef where
  toJSON CdashigDomainRef {..} =
   _omitNulls
      [ "href" .= cdashigDomainRefHref
      , "title" .= cdashigDomainRefTitle
      , "type" .= cdashigDomainRefType
      ]


-- | Construct a value of type 'CdashigDomainRef' (by applying it's required fields, if any)
mkCdashigDomainRef
  :: CdashigDomainRef
mkCdashigDomainRef =
  CdashigDomainRef
  { cdashigDomainRefHref = Nothing
  , cdashigDomainRefTitle = Nothing
  , cdashigDomainRefType = Nothing
  }

-- ** CdashigDomainRefElement
-- | CdashigDomainRefElement
data CdashigDomainRefElement = CdashigDomainRefElement
  { cdashigDomainRefElementHref :: !(Maybe Text) -- ^ "href"
  , cdashigDomainRefElementTitle :: !(Maybe Text) -- ^ "title"
  , cdashigDomainRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigDomainRefElement
instance A.FromJSON CdashigDomainRefElement where
  parseJSON = A.withObject "CdashigDomainRefElement" $ \o ->
    CdashigDomainRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigDomainRefElement
instance A.ToJSON CdashigDomainRefElement where
  toJSON CdashigDomainRefElement {..} =
   _omitNulls
      [ "href" .= cdashigDomainRefElementHref
      , "title" .= cdashigDomainRefElementTitle
      , "type" .= cdashigDomainRefElementType
      ]


-- | Construct a value of type 'CdashigDomainRefElement' (by applying it's required fields, if any)
mkCdashigDomainRefElement
  :: CdashigDomainRefElement
mkCdashigDomainRefElement =
  CdashigDomainRefElement
  { cdashigDomainRefElementHref = Nothing
  , cdashigDomainRefElementTitle = Nothing
  , cdashigDomainRefElementType = Nothing
  }

-- ** CdashigProduct
-- | CdashigProduct
data CdashigProduct = CdashigProduct
  { cdashigProductName :: !(Maybe Text) -- ^ "name"
  , cdashigProductLabel :: !(Maybe Text) -- ^ "label"
  , cdashigProductDescription :: !(Maybe Text) -- ^ "description"
  , cdashigProductSource :: !(Maybe Text) -- ^ "source"
  , cdashigProductEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , cdashigProductRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , cdashigProductVersion :: !(Maybe Text) -- ^ "version"
  , cdashigProductLinks :: !(Maybe CdashigProductLinks) -- ^ "_links"
  , cdashigProductClasses :: !(Maybe [CdashigClass]) -- ^ "classes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigProduct
instance A.FromJSON CdashigProduct where
  parseJSON = A.withObject "CdashigProduct" $ \o ->
    CdashigProduct
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")
      <*> (o .:? "classes")

-- | ToJSON CdashigProduct
instance A.ToJSON CdashigProduct where
  toJSON CdashigProduct {..} =
   _omitNulls
      [ "name" .= cdashigProductName
      , "label" .= cdashigProductLabel
      , "description" .= cdashigProductDescription
      , "source" .= cdashigProductSource
      , "effectiveDate" .= cdashigProductEffectiveDate
      , "registrationStatus" .= cdashigProductRegistrationStatus
      , "version" .= cdashigProductVersion
      , "_links" .= cdashigProductLinks
      , "classes" .= cdashigProductClasses
      ]


-- | Construct a value of type 'CdashigProduct' (by applying it's required fields, if any)
mkCdashigProduct
  :: CdashigProduct
mkCdashigProduct =
  CdashigProduct
  { cdashigProductName = Nothing
  , cdashigProductLabel = Nothing
  , cdashigProductDescription = Nothing
  , cdashigProductSource = Nothing
  , cdashigProductEffectiveDate = Nothing
  , cdashigProductRegistrationStatus = Nothing
  , cdashigProductVersion = Nothing
  , cdashigProductLinks = Nothing
  , cdashigProductClasses = Nothing
  }

-- ** CdashigProductClasses
-- | CdashigProductClasses
data CdashigProductClasses = CdashigProductClasses
  { cdashigProductClassesName :: !(Maybe Text) -- ^ "name"
  , cdashigProductClassesLabel :: !(Maybe Text) -- ^ "label"
  , cdashigProductClassesDescription :: !(Maybe Text) -- ^ "description"
  , cdashigProductClassesSource :: !(Maybe Text) -- ^ "source"
  , cdashigProductClassesEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , cdashigProductClassesRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , cdashigProductClassesVersion :: !(Maybe Text) -- ^ "version"
  , cdashigProductClassesLinks :: !(Maybe CdashigProductClassesLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigProductClasses
instance A.FromJSON CdashigProductClasses where
  parseJSON = A.withObject "CdashigProductClasses" $ \o ->
    CdashigProductClasses
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")

-- | ToJSON CdashigProductClasses
instance A.ToJSON CdashigProductClasses where
  toJSON CdashigProductClasses {..} =
   _omitNulls
      [ "name" .= cdashigProductClassesName
      , "label" .= cdashigProductClassesLabel
      , "description" .= cdashigProductClassesDescription
      , "source" .= cdashigProductClassesSource
      , "effectiveDate" .= cdashigProductClassesEffectiveDate
      , "registrationStatus" .= cdashigProductClassesRegistrationStatus
      , "version" .= cdashigProductClassesVersion
      , "_links" .= cdashigProductClassesLinks
      ]


-- | Construct a value of type 'CdashigProductClasses' (by applying it's required fields, if any)
mkCdashigProductClasses
  :: CdashigProductClasses
mkCdashigProductClasses =
  CdashigProductClasses
  { cdashigProductClassesName = Nothing
  , cdashigProductClassesLabel = Nothing
  , cdashigProductClassesDescription = Nothing
  , cdashigProductClassesSource = Nothing
  , cdashigProductClassesEffectiveDate = Nothing
  , cdashigProductClassesRegistrationStatus = Nothing
  , cdashigProductClassesVersion = Nothing
  , cdashigProductClassesLinks = Nothing
  }

-- ** CdashigProductClassesLinks
-- | CdashigProductClassesLinks
data CdashigProductClassesLinks = CdashigProductClassesLinks
  { cdashigProductClassesLinksSelf :: !(Maybe CdashigProductClassesRef) -- ^ "self"
  , cdashigProductClassesLinksParentProduct :: !(Maybe CdashigProductRef) -- ^ "parentProduct"
  , cdashigProductClassesLinksClasses :: !(Maybe [CdashigClassRefElement]) -- ^ "classes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigProductClassesLinks
instance A.FromJSON CdashigProductClassesLinks where
  parseJSON = A.withObject "CdashigProductClassesLinks" $ \o ->
    CdashigProductClassesLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "classes")

-- | ToJSON CdashigProductClassesLinks
instance A.ToJSON CdashigProductClassesLinks where
  toJSON CdashigProductClassesLinks {..} =
   _omitNulls
      [ "self" .= cdashigProductClassesLinksSelf
      , "parentProduct" .= cdashigProductClassesLinksParentProduct
      , "classes" .= cdashigProductClassesLinksClasses
      ]


-- | Construct a value of type 'CdashigProductClassesLinks' (by applying it's required fields, if any)
mkCdashigProductClassesLinks
  :: CdashigProductClassesLinks
mkCdashigProductClassesLinks =
  CdashigProductClassesLinks
  { cdashigProductClassesLinksSelf = Nothing
  , cdashigProductClassesLinksParentProduct = Nothing
  , cdashigProductClassesLinksClasses = Nothing
  }

-- ** CdashigProductClassesRef
-- | CdashigProductClassesRef
data CdashigProductClassesRef = CdashigProductClassesRef
  { cdashigProductClassesRefHref :: !(Maybe Text) -- ^ "href"
  , cdashigProductClassesRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashigProductClassesRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigProductClassesRef
instance A.FromJSON CdashigProductClassesRef where
  parseJSON = A.withObject "CdashigProductClassesRef" $ \o ->
    CdashigProductClassesRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigProductClassesRef
instance A.ToJSON CdashigProductClassesRef where
  toJSON CdashigProductClassesRef {..} =
   _omitNulls
      [ "href" .= cdashigProductClassesRefHref
      , "title" .= cdashigProductClassesRefTitle
      , "type" .= cdashigProductClassesRefType
      ]


-- | Construct a value of type 'CdashigProductClassesRef' (by applying it's required fields, if any)
mkCdashigProductClassesRef
  :: CdashigProductClassesRef
mkCdashigProductClassesRef =
  CdashigProductClassesRef
  { cdashigProductClassesRefHref = Nothing
  , cdashigProductClassesRefTitle = Nothing
  , cdashigProductClassesRefType = Nothing
  }

-- ** CdashigProductDomains
-- | CdashigProductDomains
data CdashigProductDomains = CdashigProductDomains
  { cdashigProductDomainsName :: !(Maybe Text) -- ^ "name"
  , cdashigProductDomainsLabel :: !(Maybe Text) -- ^ "label"
  , cdashigProductDomainsDescription :: !(Maybe Text) -- ^ "description"
  , cdashigProductDomainsSource :: !(Maybe Text) -- ^ "source"
  , cdashigProductDomainsEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , cdashigProductDomainsRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , cdashigProductDomainsVersion :: !(Maybe Text) -- ^ "version"
  , cdashigProductDomainsLinks :: !(Maybe CdashigProductDomainsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigProductDomains
instance A.FromJSON CdashigProductDomains where
  parseJSON = A.withObject "CdashigProductDomains" $ \o ->
    CdashigProductDomains
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")

-- | ToJSON CdashigProductDomains
instance A.ToJSON CdashigProductDomains where
  toJSON CdashigProductDomains {..} =
   _omitNulls
      [ "name" .= cdashigProductDomainsName
      , "label" .= cdashigProductDomainsLabel
      , "description" .= cdashigProductDomainsDescription
      , "source" .= cdashigProductDomainsSource
      , "effectiveDate" .= cdashigProductDomainsEffectiveDate
      , "registrationStatus" .= cdashigProductDomainsRegistrationStatus
      , "version" .= cdashigProductDomainsVersion
      , "_links" .= cdashigProductDomainsLinks
      ]


-- | Construct a value of type 'CdashigProductDomains' (by applying it's required fields, if any)
mkCdashigProductDomains
  :: CdashigProductDomains
mkCdashigProductDomains =
  CdashigProductDomains
  { cdashigProductDomainsName = Nothing
  , cdashigProductDomainsLabel = Nothing
  , cdashigProductDomainsDescription = Nothing
  , cdashigProductDomainsSource = Nothing
  , cdashigProductDomainsEffectiveDate = Nothing
  , cdashigProductDomainsRegistrationStatus = Nothing
  , cdashigProductDomainsVersion = Nothing
  , cdashigProductDomainsLinks = Nothing
  }

-- ** CdashigProductDomainsLinks
-- | CdashigProductDomainsLinks
data CdashigProductDomainsLinks = CdashigProductDomainsLinks
  { cdashigProductDomainsLinksSelf :: !(Maybe CdashigProductDomainsRef) -- ^ "self"
  , cdashigProductDomainsLinksParentProduct :: !(Maybe CdashigProductRef) -- ^ "parentProduct"
  , cdashigProductDomainsLinksDomains :: !(Maybe [CdashigDomainRefElement]) -- ^ "domains"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigProductDomainsLinks
instance A.FromJSON CdashigProductDomainsLinks where
  parseJSON = A.withObject "CdashigProductDomainsLinks" $ \o ->
    CdashigProductDomainsLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "domains")

-- | ToJSON CdashigProductDomainsLinks
instance A.ToJSON CdashigProductDomainsLinks where
  toJSON CdashigProductDomainsLinks {..} =
   _omitNulls
      [ "self" .= cdashigProductDomainsLinksSelf
      , "parentProduct" .= cdashigProductDomainsLinksParentProduct
      , "domains" .= cdashigProductDomainsLinksDomains
      ]


-- | Construct a value of type 'CdashigProductDomainsLinks' (by applying it's required fields, if any)
mkCdashigProductDomainsLinks
  :: CdashigProductDomainsLinks
mkCdashigProductDomainsLinks =
  CdashigProductDomainsLinks
  { cdashigProductDomainsLinksSelf = Nothing
  , cdashigProductDomainsLinksParentProduct = Nothing
  , cdashigProductDomainsLinksDomains = Nothing
  }

-- ** CdashigProductDomainsRef
-- | CdashigProductDomainsRef
data CdashigProductDomainsRef = CdashigProductDomainsRef
  { cdashigProductDomainsRefHref :: !(Maybe Text) -- ^ "href"
  , cdashigProductDomainsRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashigProductDomainsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigProductDomainsRef
instance A.FromJSON CdashigProductDomainsRef where
  parseJSON = A.withObject "CdashigProductDomainsRef" $ \o ->
    CdashigProductDomainsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigProductDomainsRef
instance A.ToJSON CdashigProductDomainsRef where
  toJSON CdashigProductDomainsRef {..} =
   _omitNulls
      [ "href" .= cdashigProductDomainsRefHref
      , "title" .= cdashigProductDomainsRefTitle
      , "type" .= cdashigProductDomainsRefType
      ]


-- | Construct a value of type 'CdashigProductDomainsRef' (by applying it's required fields, if any)
mkCdashigProductDomainsRef
  :: CdashigProductDomainsRef
mkCdashigProductDomainsRef =
  CdashigProductDomainsRef
  { cdashigProductDomainsRefHref = Nothing
  , cdashigProductDomainsRefTitle = Nothing
  , cdashigProductDomainsRefType = Nothing
  }

-- ** CdashigProductLinks
-- | CdashigProductLinks
data CdashigProductLinks = CdashigProductLinks
  { cdashigProductLinksSelf :: !(Maybe CdashigProductRef) -- ^ "self"
  , cdashigProductLinksModel :: !(Maybe CdashProductRef) -- ^ "model"
  , cdashigProductLinksPriorVersion :: !(Maybe CdashigProductRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigProductLinks
instance A.FromJSON CdashigProductLinks where
  parseJSON = A.withObject "CdashigProductLinks" $ \o ->
    CdashigProductLinks
      <$> (o .:? "self")
      <*> (o .:? "model")
      <*> (o .:? "priorVersion")

-- | ToJSON CdashigProductLinks
instance A.ToJSON CdashigProductLinks where
  toJSON CdashigProductLinks {..} =
   _omitNulls
      [ "self" .= cdashigProductLinksSelf
      , "model" .= cdashigProductLinksModel
      , "priorVersion" .= cdashigProductLinksPriorVersion
      ]


-- | Construct a value of type 'CdashigProductLinks' (by applying it's required fields, if any)
mkCdashigProductLinks
  :: CdashigProductLinks
mkCdashigProductLinks =
  CdashigProductLinks
  { cdashigProductLinksSelf = Nothing
  , cdashigProductLinksModel = Nothing
  , cdashigProductLinksPriorVersion = Nothing
  }

-- ** CdashigProductRef
-- | CdashigProductRef
data CdashigProductRef = CdashigProductRef
  { cdashigProductRefHref :: !(Maybe Text) -- ^ "href"
  , cdashigProductRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashigProductRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigProductRef
instance A.FromJSON CdashigProductRef where
  parseJSON = A.withObject "CdashigProductRef" $ \o ->
    CdashigProductRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigProductRef
instance A.ToJSON CdashigProductRef where
  toJSON CdashigProductRef {..} =
   _omitNulls
      [ "href" .= cdashigProductRefHref
      , "title" .= cdashigProductRefTitle
      , "type" .= cdashigProductRefType
      ]


-- | Construct a value of type 'CdashigProductRef' (by applying it's required fields, if any)
mkCdashigProductRef
  :: CdashigProductRef
mkCdashigProductRef =
  CdashigProductRef
  { cdashigProductRefHref = Nothing
  , cdashigProductRefTitle = Nothing
  , cdashigProductRefType = Nothing
  }

-- ** CdashigProductRefElement
-- | CdashigProductRefElement
data CdashigProductRefElement = CdashigProductRefElement
  { cdashigProductRefElementHref :: !(Maybe Text) -- ^ "href"
  , cdashigProductRefElementTitle :: !(Maybe Text) -- ^ "title"
  , cdashigProductRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigProductRefElement
instance A.FromJSON CdashigProductRefElement where
  parseJSON = A.withObject "CdashigProductRefElement" $ \o ->
    CdashigProductRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigProductRefElement
instance A.ToJSON CdashigProductRefElement where
  toJSON CdashigProductRefElement {..} =
   _omitNulls
      [ "href" .= cdashigProductRefElementHref
      , "title" .= cdashigProductRefElementTitle
      , "type" .= cdashigProductRefElementType
      ]


-- | Construct a value of type 'CdashigProductRefElement' (by applying it's required fields, if any)
mkCdashigProductRefElement
  :: CdashigProductRefElement
mkCdashigProductRefElement =
  CdashigProductRefElement
  { cdashigProductRefElementHref = Nothing
  , cdashigProductRefElementTitle = Nothing
  , cdashigProductRefElementType = Nothing
  }

-- ** CdashigProductScenarios
-- | CdashigProductScenarios
data CdashigProductScenarios = CdashigProductScenarios
  { cdashigProductScenariosName :: !(Maybe Text) -- ^ "name"
  , cdashigProductScenariosLabel :: !(Maybe Text) -- ^ "label"
  , cdashigProductScenariosDescription :: !(Maybe Text) -- ^ "description"
  , cdashigProductScenariosSource :: !(Maybe Text) -- ^ "source"
  , cdashigProductScenariosEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , cdashigProductScenariosRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , cdashigProductScenariosVersion :: !(Maybe Text) -- ^ "version"
  , cdashigProductScenariosLinks :: !(Maybe CdashigProductScenariosLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigProductScenarios
instance A.FromJSON CdashigProductScenarios where
  parseJSON = A.withObject "CdashigProductScenarios" $ \o ->
    CdashigProductScenarios
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")

-- | ToJSON CdashigProductScenarios
instance A.ToJSON CdashigProductScenarios where
  toJSON CdashigProductScenarios {..} =
   _omitNulls
      [ "name" .= cdashigProductScenariosName
      , "label" .= cdashigProductScenariosLabel
      , "description" .= cdashigProductScenariosDescription
      , "source" .= cdashigProductScenariosSource
      , "effectiveDate" .= cdashigProductScenariosEffectiveDate
      , "registrationStatus" .= cdashigProductScenariosRegistrationStatus
      , "version" .= cdashigProductScenariosVersion
      , "_links" .= cdashigProductScenariosLinks
      ]


-- | Construct a value of type 'CdashigProductScenarios' (by applying it's required fields, if any)
mkCdashigProductScenarios
  :: CdashigProductScenarios
mkCdashigProductScenarios =
  CdashigProductScenarios
  { cdashigProductScenariosName = Nothing
  , cdashigProductScenariosLabel = Nothing
  , cdashigProductScenariosDescription = Nothing
  , cdashigProductScenariosSource = Nothing
  , cdashigProductScenariosEffectiveDate = Nothing
  , cdashigProductScenariosRegistrationStatus = Nothing
  , cdashigProductScenariosVersion = Nothing
  , cdashigProductScenariosLinks = Nothing
  }

-- ** CdashigProductScenariosLinks
-- | CdashigProductScenariosLinks
data CdashigProductScenariosLinks = CdashigProductScenariosLinks
  { cdashigProductScenariosLinksSelf :: !(Maybe CdashigProductScenariosRef) -- ^ "self"
  , cdashigProductScenariosLinksParentProduct :: !(Maybe CdashigProductRef) -- ^ "parentProduct"
  , cdashigProductScenariosLinksScenarios :: !(Maybe [CdashigScenarioRefElement]) -- ^ "scenarios"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigProductScenariosLinks
instance A.FromJSON CdashigProductScenariosLinks where
  parseJSON = A.withObject "CdashigProductScenariosLinks" $ \o ->
    CdashigProductScenariosLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "scenarios")

-- | ToJSON CdashigProductScenariosLinks
instance A.ToJSON CdashigProductScenariosLinks where
  toJSON CdashigProductScenariosLinks {..} =
   _omitNulls
      [ "self" .= cdashigProductScenariosLinksSelf
      , "parentProduct" .= cdashigProductScenariosLinksParentProduct
      , "scenarios" .= cdashigProductScenariosLinksScenarios
      ]


-- | Construct a value of type 'CdashigProductScenariosLinks' (by applying it's required fields, if any)
mkCdashigProductScenariosLinks
  :: CdashigProductScenariosLinks
mkCdashigProductScenariosLinks =
  CdashigProductScenariosLinks
  { cdashigProductScenariosLinksSelf = Nothing
  , cdashigProductScenariosLinksParentProduct = Nothing
  , cdashigProductScenariosLinksScenarios = Nothing
  }

-- ** CdashigProductScenariosRef
-- | CdashigProductScenariosRef
data CdashigProductScenariosRef = CdashigProductScenariosRef
  { cdashigProductScenariosRefHref :: !(Maybe Text) -- ^ "href"
  , cdashigProductScenariosRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashigProductScenariosRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigProductScenariosRef
instance A.FromJSON CdashigProductScenariosRef where
  parseJSON = A.withObject "CdashigProductScenariosRef" $ \o ->
    CdashigProductScenariosRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigProductScenariosRef
instance A.ToJSON CdashigProductScenariosRef where
  toJSON CdashigProductScenariosRef {..} =
   _omitNulls
      [ "href" .= cdashigProductScenariosRefHref
      , "title" .= cdashigProductScenariosRefTitle
      , "type" .= cdashigProductScenariosRefType
      ]


-- | Construct a value of type 'CdashigProductScenariosRef' (by applying it's required fields, if any)
mkCdashigProductScenariosRef
  :: CdashigProductScenariosRef
mkCdashigProductScenariosRef =
  CdashigProductScenariosRef
  { cdashigProductScenariosRefHref = Nothing
  , cdashigProductScenariosRefTitle = Nothing
  , cdashigProductScenariosRefType = Nothing
  }

-- ** CdashigScenario
-- | CdashigScenario
data CdashigScenario = CdashigScenario
  { cdashigScenarioOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , cdashigScenarioDomain :: !(Maybe Text) -- ^ "domain"
  , cdashigScenarioScenario :: !(Maybe Text) -- ^ "scenario"
  , cdashigScenarioLinks :: !(Maybe CdashigScenarioLinks) -- ^ "_links"
  , cdashigScenarioFields :: !(Maybe [CdashigScenarioField]) -- ^ "fields"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigScenario
instance A.FromJSON CdashigScenario where
  parseJSON = A.withObject "CdashigScenario" $ \o ->
    CdashigScenario
      <$> (o .:? "ordinal")
      <*> (o .:? "domain")
      <*> (o .:? "scenario")
      <*> (o .:? "_links")
      <*> (o .:? "fields")

-- | ToJSON CdashigScenario
instance A.ToJSON CdashigScenario where
  toJSON CdashigScenario {..} =
   _omitNulls
      [ "ordinal" .= cdashigScenarioOrdinal
      , "domain" .= cdashigScenarioDomain
      , "scenario" .= cdashigScenarioScenario
      , "_links" .= cdashigScenarioLinks
      , "fields" .= cdashigScenarioFields
      ]


-- | Construct a value of type 'CdashigScenario' (by applying it's required fields, if any)
mkCdashigScenario
  :: CdashigScenario
mkCdashigScenario =
  CdashigScenario
  { cdashigScenarioOrdinal = Nothing
  , cdashigScenarioDomain = Nothing
  , cdashigScenarioScenario = Nothing
  , cdashigScenarioLinks = Nothing
  , cdashigScenarioFields = Nothing
  }

-- ** CdashigScenarioField
-- | CdashigScenarioField
data CdashigScenarioField = CdashigScenarioField
  { cdashigScenarioFieldOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , cdashigScenarioFieldName :: !(Maybe Text) -- ^ "name"
  , cdashigScenarioFieldLabel :: !(Maybe Text) -- ^ "label"
  , cdashigScenarioFieldDefinition :: !(Maybe Text) -- ^ "definition"
  , cdashigScenarioFieldQuestionText :: !(Maybe Text) -- ^ "questionText"
  , cdashigScenarioFieldPrompt :: !(Maybe Text) -- ^ "prompt"
  , cdashigScenarioFieldCompletionInstructions :: !(Maybe Text) -- ^ "completionInstructions"
  , cdashigScenarioFieldImplementationNotes :: !(Maybe Text) -- ^ "implementationNotes"
  , cdashigScenarioFieldSimpleDatatype :: !(Maybe Text) -- ^ "simpleDatatype"
  , cdashigScenarioFieldMappingInstructions :: !(Maybe Text) -- ^ "mappingInstructions"
  , cdashigScenarioFieldCore :: !(Maybe Text) -- ^ "core"
  , cdashigScenarioFieldLinks :: !(Maybe CdashigScenarioFieldLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigScenarioField
instance A.FromJSON CdashigScenarioField where
  parseJSON = A.withObject "CdashigScenarioField" $ \o ->
    CdashigScenarioField
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "definition")
      <*> (o .:? "questionText")
      <*> (o .:? "prompt")
      <*> (o .:? "completionInstructions")
      <*> (o .:? "implementationNotes")
      <*> (o .:? "simpleDatatype")
      <*> (o .:? "mappingInstructions")
      <*> (o .:? "core")
      <*> (o .:? "_links")

-- | ToJSON CdashigScenarioField
instance A.ToJSON CdashigScenarioField where
  toJSON CdashigScenarioField {..} =
   _omitNulls
      [ "ordinal" .= cdashigScenarioFieldOrdinal
      , "name" .= cdashigScenarioFieldName
      , "label" .= cdashigScenarioFieldLabel
      , "definition" .= cdashigScenarioFieldDefinition
      , "questionText" .= cdashigScenarioFieldQuestionText
      , "prompt" .= cdashigScenarioFieldPrompt
      , "completionInstructions" .= cdashigScenarioFieldCompletionInstructions
      , "implementationNotes" .= cdashigScenarioFieldImplementationNotes
      , "simpleDatatype" .= cdashigScenarioFieldSimpleDatatype
      , "mappingInstructions" .= cdashigScenarioFieldMappingInstructions
      , "core" .= cdashigScenarioFieldCore
      , "_links" .= cdashigScenarioFieldLinks
      ]


-- | Construct a value of type 'CdashigScenarioField' (by applying it's required fields, if any)
mkCdashigScenarioField
  :: CdashigScenarioField
mkCdashigScenarioField =
  CdashigScenarioField
  { cdashigScenarioFieldOrdinal = Nothing
  , cdashigScenarioFieldName = Nothing
  , cdashigScenarioFieldLabel = Nothing
  , cdashigScenarioFieldDefinition = Nothing
  , cdashigScenarioFieldQuestionText = Nothing
  , cdashigScenarioFieldPrompt = Nothing
  , cdashigScenarioFieldCompletionInstructions = Nothing
  , cdashigScenarioFieldImplementationNotes = Nothing
  , cdashigScenarioFieldSimpleDatatype = Nothing
  , cdashigScenarioFieldMappingInstructions = Nothing
  , cdashigScenarioFieldCore = Nothing
  , cdashigScenarioFieldLinks = Nothing
  }

-- ** CdashigScenarioFieldLinks
-- | CdashigScenarioFieldLinks
data CdashigScenarioFieldLinks = CdashigScenarioFieldLinks
  { cdashigScenarioFieldLinksSelf :: !(Maybe CdashigScenarioFieldRef) -- ^ "self"
  , cdashigScenarioFieldLinksCodelist :: !(Maybe [RootCtCodelistRefElement]) -- ^ "codelist"
  , cdashigScenarioFieldLinksParentProduct :: !(Maybe CdashigProductRef) -- ^ "parentProduct"
  , cdashigScenarioFieldLinksParentDomain :: !(Maybe CdashigDomainRef) -- ^ "parentDomain"
  , cdashigScenarioFieldLinksParentScenario :: !(Maybe CdashigScenarioRef) -- ^ "parentScenario"
  , cdashigScenarioFieldLinksRootItem :: !(Maybe RootCdashigScenarioFieldRef) -- ^ "rootItem"
  , cdashigScenarioFieldLinksPriorVersion :: !(Maybe CdashigScenarioFieldRef) -- ^ "priorVersion"
  , cdashigScenarioFieldLinksSdtmigDatasetMappingTargets :: !(Maybe [SdtmigDatasetVariableRefTarget]) -- ^ "sdtmigDatasetMappingTargets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigScenarioFieldLinks
instance A.FromJSON CdashigScenarioFieldLinks where
  parseJSON = A.withObject "CdashigScenarioFieldLinks" $ \o ->
    CdashigScenarioFieldLinks
      <$> (o .:? "self")
      <*> (o .:? "codelist")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentDomain")
      <*> (o .:? "parentScenario")
      <*> (o .:? "rootItem")
      <*> (o .:? "priorVersion")
      <*> (o .:? "sdtmigDatasetMappingTargets")

-- | ToJSON CdashigScenarioFieldLinks
instance A.ToJSON CdashigScenarioFieldLinks where
  toJSON CdashigScenarioFieldLinks {..} =
   _omitNulls
      [ "self" .= cdashigScenarioFieldLinksSelf
      , "codelist" .= cdashigScenarioFieldLinksCodelist
      , "parentProduct" .= cdashigScenarioFieldLinksParentProduct
      , "parentDomain" .= cdashigScenarioFieldLinksParentDomain
      , "parentScenario" .= cdashigScenarioFieldLinksParentScenario
      , "rootItem" .= cdashigScenarioFieldLinksRootItem
      , "priorVersion" .= cdashigScenarioFieldLinksPriorVersion
      , "sdtmigDatasetMappingTargets" .= cdashigScenarioFieldLinksSdtmigDatasetMappingTargets
      ]


-- | Construct a value of type 'CdashigScenarioFieldLinks' (by applying it's required fields, if any)
mkCdashigScenarioFieldLinks
  :: CdashigScenarioFieldLinks
mkCdashigScenarioFieldLinks =
  CdashigScenarioFieldLinks
  { cdashigScenarioFieldLinksSelf = Nothing
  , cdashigScenarioFieldLinksCodelist = Nothing
  , cdashigScenarioFieldLinksParentProduct = Nothing
  , cdashigScenarioFieldLinksParentDomain = Nothing
  , cdashigScenarioFieldLinksParentScenario = Nothing
  , cdashigScenarioFieldLinksRootItem = Nothing
  , cdashigScenarioFieldLinksPriorVersion = Nothing
  , cdashigScenarioFieldLinksSdtmigDatasetMappingTargets = Nothing
  }

-- ** CdashigScenarioFieldRef
-- | CdashigScenarioFieldRef
data CdashigScenarioFieldRef = CdashigScenarioFieldRef
  { cdashigScenarioFieldRefHref :: !(Maybe Text) -- ^ "href"
  , cdashigScenarioFieldRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashigScenarioFieldRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigScenarioFieldRef
instance A.FromJSON CdashigScenarioFieldRef where
  parseJSON = A.withObject "CdashigScenarioFieldRef" $ \o ->
    CdashigScenarioFieldRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigScenarioFieldRef
instance A.ToJSON CdashigScenarioFieldRef where
  toJSON CdashigScenarioFieldRef {..} =
   _omitNulls
      [ "href" .= cdashigScenarioFieldRefHref
      , "title" .= cdashigScenarioFieldRefTitle
      , "type" .= cdashigScenarioFieldRefType
      ]


-- | Construct a value of type 'CdashigScenarioFieldRef' (by applying it's required fields, if any)
mkCdashigScenarioFieldRef
  :: CdashigScenarioFieldRef
mkCdashigScenarioFieldRef =
  CdashigScenarioFieldRef
  { cdashigScenarioFieldRefHref = Nothing
  , cdashigScenarioFieldRefTitle = Nothing
  , cdashigScenarioFieldRefType = Nothing
  }

-- ** CdashigScenarioFieldRefElement
-- | CdashigScenarioFieldRefElement
data CdashigScenarioFieldRefElement = CdashigScenarioFieldRefElement
  { cdashigScenarioFieldRefElementHref :: !(Maybe Text) -- ^ "href"
  , cdashigScenarioFieldRefElementTitle :: !(Maybe Text) -- ^ "title"
  , cdashigScenarioFieldRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigScenarioFieldRefElement
instance A.FromJSON CdashigScenarioFieldRefElement where
  parseJSON = A.withObject "CdashigScenarioFieldRefElement" $ \o ->
    CdashigScenarioFieldRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigScenarioFieldRefElement
instance A.ToJSON CdashigScenarioFieldRefElement where
  toJSON CdashigScenarioFieldRefElement {..} =
   _omitNulls
      [ "href" .= cdashigScenarioFieldRefElementHref
      , "title" .= cdashigScenarioFieldRefElementTitle
      , "type" .= cdashigScenarioFieldRefElementType
      ]


-- | Construct a value of type 'CdashigScenarioFieldRefElement' (by applying it's required fields, if any)
mkCdashigScenarioFieldRefElement
  :: CdashigScenarioFieldRefElement
mkCdashigScenarioFieldRefElement =
  CdashigScenarioFieldRefElement
  { cdashigScenarioFieldRefElementHref = Nothing
  , cdashigScenarioFieldRefElementTitle = Nothing
  , cdashigScenarioFieldRefElementType = Nothing
  }

-- ** CdashigScenarioFieldRefVersion
-- | CdashigScenarioFieldRefVersion
data CdashigScenarioFieldRefVersion = CdashigScenarioFieldRefVersion
  { cdashigScenarioFieldRefVersionHref :: !(Maybe Text) -- ^ "href"
  , cdashigScenarioFieldRefVersionTitle :: !(Maybe Text) -- ^ "title"
  , cdashigScenarioFieldRefVersionType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigScenarioFieldRefVersion
instance A.FromJSON CdashigScenarioFieldRefVersion where
  parseJSON = A.withObject "CdashigScenarioFieldRefVersion" $ \o ->
    CdashigScenarioFieldRefVersion
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigScenarioFieldRefVersion
instance A.ToJSON CdashigScenarioFieldRefVersion where
  toJSON CdashigScenarioFieldRefVersion {..} =
   _omitNulls
      [ "href" .= cdashigScenarioFieldRefVersionHref
      , "title" .= cdashigScenarioFieldRefVersionTitle
      , "type" .= cdashigScenarioFieldRefVersionType
      ]


-- | Construct a value of type 'CdashigScenarioFieldRefVersion' (by applying it's required fields, if any)
mkCdashigScenarioFieldRefVersion
  :: CdashigScenarioFieldRefVersion
mkCdashigScenarioFieldRefVersion =
  CdashigScenarioFieldRefVersion
  { cdashigScenarioFieldRefVersionHref = Nothing
  , cdashigScenarioFieldRefVersionTitle = Nothing
  , cdashigScenarioFieldRefVersionType = Nothing
  }

-- ** CdashigScenarioFields
-- | CdashigScenarioFields
data CdashigScenarioFields = CdashigScenarioFields
  { cdashigScenarioFieldsOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , cdashigScenarioFieldsDomain :: !(Maybe Text) -- ^ "domain"
  , cdashigScenarioFieldsScenario :: !(Maybe Text) -- ^ "scenario"
  , cdashigScenarioFieldsLinks :: !(Maybe CdashigScenarioFieldsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigScenarioFields
instance A.FromJSON CdashigScenarioFields where
  parseJSON = A.withObject "CdashigScenarioFields" $ \o ->
    CdashigScenarioFields
      <$> (o .:? "ordinal")
      <*> (o .:? "domain")
      <*> (o .:? "scenario")
      <*> (o .:? "_links")

-- | ToJSON CdashigScenarioFields
instance A.ToJSON CdashigScenarioFields where
  toJSON CdashigScenarioFields {..} =
   _omitNulls
      [ "ordinal" .= cdashigScenarioFieldsOrdinal
      , "domain" .= cdashigScenarioFieldsDomain
      , "scenario" .= cdashigScenarioFieldsScenario
      , "_links" .= cdashigScenarioFieldsLinks
      ]


-- | Construct a value of type 'CdashigScenarioFields' (by applying it's required fields, if any)
mkCdashigScenarioFields
  :: CdashigScenarioFields
mkCdashigScenarioFields =
  CdashigScenarioFields
  { cdashigScenarioFieldsOrdinal = Nothing
  , cdashigScenarioFieldsDomain = Nothing
  , cdashigScenarioFieldsScenario = Nothing
  , cdashigScenarioFieldsLinks = Nothing
  }

-- ** CdashigScenarioFieldsLinks
-- | CdashigScenarioFieldsLinks
data CdashigScenarioFieldsLinks = CdashigScenarioFieldsLinks
  { cdashigScenarioFieldsLinksSelf :: !(Maybe CdashigScenarioFieldsRef) -- ^ "self"
  , cdashigScenarioFieldsLinksParentProduct :: !(Maybe CdashigProductRef) -- ^ "parentProduct"
  , cdashigScenarioFieldsLinksParentClass :: !(Maybe CdashigClassRef) -- ^ "parentClass"
  , cdashigScenarioFieldsLinksParentDomain :: !(Maybe CdashigDomainRef) -- ^ "parentDomain"
  , cdashigScenarioFieldsLinksFields :: !(Maybe [CdashigScenarioFieldRefElement]) -- ^ "fields"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigScenarioFieldsLinks
instance A.FromJSON CdashigScenarioFieldsLinks where
  parseJSON = A.withObject "CdashigScenarioFieldsLinks" $ \o ->
    CdashigScenarioFieldsLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "parentDomain")
      <*> (o .:? "fields")

-- | ToJSON CdashigScenarioFieldsLinks
instance A.ToJSON CdashigScenarioFieldsLinks where
  toJSON CdashigScenarioFieldsLinks {..} =
   _omitNulls
      [ "self" .= cdashigScenarioFieldsLinksSelf
      , "parentProduct" .= cdashigScenarioFieldsLinksParentProduct
      , "parentClass" .= cdashigScenarioFieldsLinksParentClass
      , "parentDomain" .= cdashigScenarioFieldsLinksParentDomain
      , "fields" .= cdashigScenarioFieldsLinksFields
      ]


-- | Construct a value of type 'CdashigScenarioFieldsLinks' (by applying it's required fields, if any)
mkCdashigScenarioFieldsLinks
  :: CdashigScenarioFieldsLinks
mkCdashigScenarioFieldsLinks =
  CdashigScenarioFieldsLinks
  { cdashigScenarioFieldsLinksSelf = Nothing
  , cdashigScenarioFieldsLinksParentProduct = Nothing
  , cdashigScenarioFieldsLinksParentClass = Nothing
  , cdashigScenarioFieldsLinksParentDomain = Nothing
  , cdashigScenarioFieldsLinksFields = Nothing
  }

-- ** CdashigScenarioFieldsRef
-- | CdashigScenarioFieldsRef
data CdashigScenarioFieldsRef = CdashigScenarioFieldsRef
  { cdashigScenarioFieldsRefHref :: !(Maybe Text) -- ^ "href"
  , cdashigScenarioFieldsRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashigScenarioFieldsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigScenarioFieldsRef
instance A.FromJSON CdashigScenarioFieldsRef where
  parseJSON = A.withObject "CdashigScenarioFieldsRef" $ \o ->
    CdashigScenarioFieldsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigScenarioFieldsRef
instance A.ToJSON CdashigScenarioFieldsRef where
  toJSON CdashigScenarioFieldsRef {..} =
   _omitNulls
      [ "href" .= cdashigScenarioFieldsRefHref
      , "title" .= cdashigScenarioFieldsRefTitle
      , "type" .= cdashigScenarioFieldsRefType
      ]


-- | Construct a value of type 'CdashigScenarioFieldsRef' (by applying it's required fields, if any)
mkCdashigScenarioFieldsRef
  :: CdashigScenarioFieldsRef
mkCdashigScenarioFieldsRef =
  CdashigScenarioFieldsRef
  { cdashigScenarioFieldsRefHref = Nothing
  , cdashigScenarioFieldsRefTitle = Nothing
  , cdashigScenarioFieldsRefType = Nothing
  }

-- ** CdashigScenarioLinks
-- | CdashigScenarioLinks
data CdashigScenarioLinks = CdashigScenarioLinks
  { cdashigScenarioLinksSelf :: !(Maybe CdashigScenarioRef) -- ^ "self"
  , cdashigScenarioLinksParentProduct :: !(Maybe CdashigProductRef) -- ^ "parentProduct"
  , cdashigScenarioLinksParentClass :: !(Maybe CdashigClassRef) -- ^ "parentClass"
  , cdashigScenarioLinksParentDomain :: !(Maybe CdashigDomainRef) -- ^ "parentDomain"
  , cdashigScenarioLinksPriorVersion :: !(Maybe CdashigScenarioRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigScenarioLinks
instance A.FromJSON CdashigScenarioLinks where
  parseJSON = A.withObject "CdashigScenarioLinks" $ \o ->
    CdashigScenarioLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "parentDomain")
      <*> (o .:? "priorVersion")

-- | ToJSON CdashigScenarioLinks
instance A.ToJSON CdashigScenarioLinks where
  toJSON CdashigScenarioLinks {..} =
   _omitNulls
      [ "self" .= cdashigScenarioLinksSelf
      , "parentProduct" .= cdashigScenarioLinksParentProduct
      , "parentClass" .= cdashigScenarioLinksParentClass
      , "parentDomain" .= cdashigScenarioLinksParentDomain
      , "priorVersion" .= cdashigScenarioLinksPriorVersion
      ]


-- | Construct a value of type 'CdashigScenarioLinks' (by applying it's required fields, if any)
mkCdashigScenarioLinks
  :: CdashigScenarioLinks
mkCdashigScenarioLinks =
  CdashigScenarioLinks
  { cdashigScenarioLinksSelf = Nothing
  , cdashigScenarioLinksParentProduct = Nothing
  , cdashigScenarioLinksParentClass = Nothing
  , cdashigScenarioLinksParentDomain = Nothing
  , cdashigScenarioLinksPriorVersion = Nothing
  }

-- ** CdashigScenarioRef
-- | CdashigScenarioRef
data CdashigScenarioRef = CdashigScenarioRef
  { cdashigScenarioRefHref :: !(Maybe Text) -- ^ "href"
  , cdashigScenarioRefTitle :: !(Maybe Text) -- ^ "title"
  , cdashigScenarioRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigScenarioRef
instance A.FromJSON CdashigScenarioRef where
  parseJSON = A.withObject "CdashigScenarioRef" $ \o ->
    CdashigScenarioRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigScenarioRef
instance A.ToJSON CdashigScenarioRef where
  toJSON CdashigScenarioRef {..} =
   _omitNulls
      [ "href" .= cdashigScenarioRefHref
      , "title" .= cdashigScenarioRefTitle
      , "type" .= cdashigScenarioRefType
      ]


-- | Construct a value of type 'CdashigScenarioRef' (by applying it's required fields, if any)
mkCdashigScenarioRef
  :: CdashigScenarioRef
mkCdashigScenarioRef =
  CdashigScenarioRef
  { cdashigScenarioRefHref = Nothing
  , cdashigScenarioRefTitle = Nothing
  , cdashigScenarioRefType = Nothing
  }

-- ** CdashigScenarioRefElement
-- | CdashigScenarioRefElement
data CdashigScenarioRefElement = CdashigScenarioRefElement
  { cdashigScenarioRefElementHref :: !(Maybe Text) -- ^ "href"
  , cdashigScenarioRefElementTitle :: !(Maybe Text) -- ^ "title"
  , cdashigScenarioRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CdashigScenarioRefElement
instance A.FromJSON CdashigScenarioRefElement where
  parseJSON = A.withObject "CdashigScenarioRefElement" $ \o ->
    CdashigScenarioRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CdashigScenarioRefElement
instance A.ToJSON CdashigScenarioRefElement where
  toJSON CdashigScenarioRefElement {..} =
   _omitNulls
      [ "href" .= cdashigScenarioRefElementHref
      , "title" .= cdashigScenarioRefElementTitle
      , "type" .= cdashigScenarioRefElementType
      ]


-- | Construct a value of type 'CdashigScenarioRefElement' (by applying it's required fields, if any)
mkCdashigScenarioRefElement
  :: CdashigScenarioRefElement
mkCdashigScenarioRefElement =
  CdashigScenarioRefElement
  { cdashigScenarioRefElementHref = Nothing
  , cdashigScenarioRefElementTitle = Nothing
  , cdashigScenarioRefElementType = Nothing
  }

-- ** CtCodelist
-- | CtCodelist
data CtCodelist = CtCodelist
  { ctCodelistConceptId :: !(Maybe Text) -- ^ "conceptId"
  , ctCodelistExtensible :: !(Maybe Text) -- ^ "extensible"
  , ctCodelistName :: !(Maybe Text) -- ^ "name"
  , ctCodelistSubmissionValue :: !(Maybe Text) -- ^ "submissionValue"
  , ctCodelistDefinition :: !(Maybe Text) -- ^ "definition"
  , ctCodelistPreferredTerm :: !(Maybe Text) -- ^ "preferredTerm"
  , ctCodelistSynonyms :: !(Maybe [Text]) -- ^ "synonyms"
  , ctCodelistLinks :: !(Maybe CtCodelistLinks) -- ^ "_links"
  , ctCodelistTerms :: !(Maybe [CtPackageTerm]) -- ^ "terms"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtCodelist
instance A.FromJSON CtCodelist where
  parseJSON = A.withObject "CtCodelist" $ \o ->
    CtCodelist
      <$> (o .:? "conceptId")
      <*> (o .:? "extensible")
      <*> (o .:? "name")
      <*> (o .:? "submissionValue")
      <*> (o .:? "definition")
      <*> (o .:? "preferredTerm")
      <*> (o .:? "synonyms")
      <*> (o .:? "_links")
      <*> (o .:? "terms")

-- | ToJSON CtCodelist
instance A.ToJSON CtCodelist where
  toJSON CtCodelist {..} =
   _omitNulls
      [ "conceptId" .= ctCodelistConceptId
      , "extensible" .= ctCodelistExtensible
      , "name" .= ctCodelistName
      , "submissionValue" .= ctCodelistSubmissionValue
      , "definition" .= ctCodelistDefinition
      , "preferredTerm" .= ctCodelistPreferredTerm
      , "synonyms" .= ctCodelistSynonyms
      , "_links" .= ctCodelistLinks
      , "terms" .= ctCodelistTerms
      ]


-- | Construct a value of type 'CtCodelist' (by applying it's required fields, if any)
mkCtCodelist
  :: CtCodelist
mkCtCodelist =
  CtCodelist
  { ctCodelistConceptId = Nothing
  , ctCodelistExtensible = Nothing
  , ctCodelistName = Nothing
  , ctCodelistSubmissionValue = Nothing
  , ctCodelistDefinition = Nothing
  , ctCodelistPreferredTerm = Nothing
  , ctCodelistSynonyms = Nothing
  , ctCodelistLinks = Nothing
  , ctCodelistTerms = Nothing
  }

-- ** CtCodelistLinks
-- | CtCodelistLinks
data CtCodelistLinks = CtCodelistLinks
  { ctCodelistLinksSelf :: !(Maybe CtCodelistRef) -- ^ "self"
  , ctCodelistLinksParentPackage :: !(Maybe CtPackageRef) -- ^ "parentPackage"
  , ctCodelistLinksRootItem :: !(Maybe RootCtCodelistRef) -- ^ "rootItem"
  , ctCodelistLinksPriorVersion :: !(Maybe CtCodelistRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtCodelistLinks
instance A.FromJSON CtCodelistLinks where
  parseJSON = A.withObject "CtCodelistLinks" $ \o ->
    CtCodelistLinks
      <$> (o .:? "self")
      <*> (o .:? "parentPackage")
      <*> (o .:? "rootItem")
      <*> (o .:? "priorVersion")

-- | ToJSON CtCodelistLinks
instance A.ToJSON CtCodelistLinks where
  toJSON CtCodelistLinks {..} =
   _omitNulls
      [ "self" .= ctCodelistLinksSelf
      , "parentPackage" .= ctCodelistLinksParentPackage
      , "rootItem" .= ctCodelistLinksRootItem
      , "priorVersion" .= ctCodelistLinksPriorVersion
      ]


-- | Construct a value of type 'CtCodelistLinks' (by applying it's required fields, if any)
mkCtCodelistLinks
  :: CtCodelistLinks
mkCtCodelistLinks =
  CtCodelistLinks
  { ctCodelistLinksSelf = Nothing
  , ctCodelistLinksParentPackage = Nothing
  , ctCodelistLinksRootItem = Nothing
  , ctCodelistLinksPriorVersion = Nothing
  }

-- ** CtCodelistRef
-- | CtCodelistRef
data CtCodelistRef = CtCodelistRef
  { ctCodelistRefHref :: !(Maybe Text) -- ^ "href"
  , ctCodelistRefTitle :: !(Maybe Text) -- ^ "title"
  , ctCodelistRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtCodelistRef
instance A.FromJSON CtCodelistRef where
  parseJSON = A.withObject "CtCodelistRef" $ \o ->
    CtCodelistRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CtCodelistRef
instance A.ToJSON CtCodelistRef where
  toJSON CtCodelistRef {..} =
   _omitNulls
      [ "href" .= ctCodelistRefHref
      , "title" .= ctCodelistRefTitle
      , "type" .= ctCodelistRefType
      ]


-- | Construct a value of type 'CtCodelistRef' (by applying it's required fields, if any)
mkCtCodelistRef
  :: CtCodelistRef
mkCtCodelistRef =
  CtCodelistRef
  { ctCodelistRefHref = Nothing
  , ctCodelistRefTitle = Nothing
  , ctCodelistRefType = Nothing
  }

-- ** CtCodelistRefElement
-- | CtCodelistRefElement
data CtCodelistRefElement = CtCodelistRefElement
  { ctCodelistRefElementHref :: !(Maybe Text) -- ^ "href"
  , ctCodelistRefElementTitle :: !(Maybe Text) -- ^ "title"
  , ctCodelistRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtCodelistRefElement
instance A.FromJSON CtCodelistRefElement where
  parseJSON = A.withObject "CtCodelistRefElement" $ \o ->
    CtCodelistRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CtCodelistRefElement
instance A.ToJSON CtCodelistRefElement where
  toJSON CtCodelistRefElement {..} =
   _omitNulls
      [ "href" .= ctCodelistRefElementHref
      , "title" .= ctCodelistRefElementTitle
      , "type" .= ctCodelistRefElementType
      ]


-- | Construct a value of type 'CtCodelistRefElement' (by applying it's required fields, if any)
mkCtCodelistRefElement
  :: CtCodelistRefElement
mkCtCodelistRefElement =
  CtCodelistRefElement
  { ctCodelistRefElementHref = Nothing
  , ctCodelistRefElementTitle = Nothing
  , ctCodelistRefElementType = Nothing
  }

-- ** CtCodelistRefVersion
-- | CtCodelistRefVersion
data CtCodelistRefVersion = CtCodelistRefVersion
  { ctCodelistRefVersionHref :: !(Maybe Text) -- ^ "href"
  , ctCodelistRefVersionTitle :: !(Maybe Text) -- ^ "title"
  , ctCodelistRefVersionType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtCodelistRefVersion
instance A.FromJSON CtCodelistRefVersion where
  parseJSON = A.withObject "CtCodelistRefVersion" $ \o ->
    CtCodelistRefVersion
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CtCodelistRefVersion
instance A.ToJSON CtCodelistRefVersion where
  toJSON CtCodelistRefVersion {..} =
   _omitNulls
      [ "href" .= ctCodelistRefVersionHref
      , "title" .= ctCodelistRefVersionTitle
      , "type" .= ctCodelistRefVersionType
      ]


-- | Construct a value of type 'CtCodelistRefVersion' (by applying it's required fields, if any)
mkCtCodelistRefVersion
  :: CtCodelistRefVersion
mkCtCodelistRefVersion =
  CtCodelistRefVersion
  { ctCodelistRefVersionHref = Nothing
  , ctCodelistRefVersionTitle = Nothing
  , ctCodelistRefVersionType = Nothing
  }

-- ** CtCodelistTerms
-- | CtCodelistTerms
data CtCodelistTerms = CtCodelistTerms
  { ctCodelistTermsConceptId :: !(Maybe Text) -- ^ "conceptId"
  , ctCodelistTermsExtensible :: !(Maybe Text) -- ^ "extensible"
  , ctCodelistTermsName :: !(Maybe Text) -- ^ "name"
  , ctCodelistTermsSubmissionValue :: !(Maybe Text) -- ^ "submissionValue"
  , ctCodelistTermsDefinition :: !(Maybe Text) -- ^ "definition"
  , ctCodelistTermsPreferredTerm :: !(Maybe Text) -- ^ "preferredTerm"
  , ctCodelistTermsSynonyms :: !(Maybe [Text]) -- ^ "synonyms"
  , ctCodelistTermsLinks :: !(Maybe CtCodelistTermsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtCodelistTerms
instance A.FromJSON CtCodelistTerms where
  parseJSON = A.withObject "CtCodelistTerms" $ \o ->
    CtCodelistTerms
      <$> (o .:? "conceptId")
      <*> (o .:? "extensible")
      <*> (o .:? "name")
      <*> (o .:? "submissionValue")
      <*> (o .:? "definition")
      <*> (o .:? "preferredTerm")
      <*> (o .:? "synonyms")
      <*> (o .:? "_links")

-- | ToJSON CtCodelistTerms
instance A.ToJSON CtCodelistTerms where
  toJSON CtCodelistTerms {..} =
   _omitNulls
      [ "conceptId" .= ctCodelistTermsConceptId
      , "extensible" .= ctCodelistTermsExtensible
      , "name" .= ctCodelistTermsName
      , "submissionValue" .= ctCodelistTermsSubmissionValue
      , "definition" .= ctCodelistTermsDefinition
      , "preferredTerm" .= ctCodelistTermsPreferredTerm
      , "synonyms" .= ctCodelistTermsSynonyms
      , "_links" .= ctCodelistTermsLinks
      ]


-- | Construct a value of type 'CtCodelistTerms' (by applying it's required fields, if any)
mkCtCodelistTerms
  :: CtCodelistTerms
mkCtCodelistTerms =
  CtCodelistTerms
  { ctCodelistTermsConceptId = Nothing
  , ctCodelistTermsExtensible = Nothing
  , ctCodelistTermsName = Nothing
  , ctCodelistTermsSubmissionValue = Nothing
  , ctCodelistTermsDefinition = Nothing
  , ctCodelistTermsPreferredTerm = Nothing
  , ctCodelistTermsSynonyms = Nothing
  , ctCodelistTermsLinks = Nothing
  }

-- ** CtCodelistTermsLinks
-- | CtCodelistTermsLinks
data CtCodelistTermsLinks = CtCodelistTermsLinks
  { ctCodelistTermsLinksSelf :: !(Maybe CtCodelistTermsRef) -- ^ "self"
  , ctCodelistTermsLinksParentPackage :: !(Maybe CtPackageRef) -- ^ "parentPackage"
  , ctCodelistTermsLinksRootItem :: !(Maybe RootCtCodelistRef) -- ^ "rootItem"
  , ctCodelistTermsLinksPriorVersion :: !(Maybe CtCodelistTermsRef) -- ^ "priorVersion"
  , ctCodelistTermsLinksTerms :: !(Maybe [CtTermRefElement]) -- ^ "terms"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtCodelistTermsLinks
instance A.FromJSON CtCodelistTermsLinks where
  parseJSON = A.withObject "CtCodelistTermsLinks" $ \o ->
    CtCodelistTermsLinks
      <$> (o .:? "self")
      <*> (o .:? "parentPackage")
      <*> (o .:? "rootItem")
      <*> (o .:? "priorVersion")
      <*> (o .:? "terms")

-- | ToJSON CtCodelistTermsLinks
instance A.ToJSON CtCodelistTermsLinks where
  toJSON CtCodelistTermsLinks {..} =
   _omitNulls
      [ "self" .= ctCodelistTermsLinksSelf
      , "parentPackage" .= ctCodelistTermsLinksParentPackage
      , "rootItem" .= ctCodelistTermsLinksRootItem
      , "priorVersion" .= ctCodelistTermsLinksPriorVersion
      , "terms" .= ctCodelistTermsLinksTerms
      ]


-- | Construct a value of type 'CtCodelistTermsLinks' (by applying it's required fields, if any)
mkCtCodelistTermsLinks
  :: CtCodelistTermsLinks
mkCtCodelistTermsLinks =
  CtCodelistTermsLinks
  { ctCodelistTermsLinksSelf = Nothing
  , ctCodelistTermsLinksParentPackage = Nothing
  , ctCodelistTermsLinksRootItem = Nothing
  , ctCodelistTermsLinksPriorVersion = Nothing
  , ctCodelistTermsLinksTerms = Nothing
  }

-- ** CtCodelistTermsRef
-- | CtCodelistTermsRef
data CtCodelistTermsRef = CtCodelistTermsRef
  { ctCodelistTermsRefHref :: !(Maybe Text) -- ^ "href"
  , ctCodelistTermsRefTitle :: !(Maybe Text) -- ^ "title"
  , ctCodelistTermsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtCodelistTermsRef
instance A.FromJSON CtCodelistTermsRef where
  parseJSON = A.withObject "CtCodelistTermsRef" $ \o ->
    CtCodelistTermsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CtCodelistTermsRef
instance A.ToJSON CtCodelistTermsRef where
  toJSON CtCodelistTermsRef {..} =
   _omitNulls
      [ "href" .= ctCodelistTermsRefHref
      , "title" .= ctCodelistTermsRefTitle
      , "type" .= ctCodelistTermsRefType
      ]


-- | Construct a value of type 'CtCodelistTermsRef' (by applying it's required fields, if any)
mkCtCodelistTermsRef
  :: CtCodelistTermsRef
mkCtCodelistTermsRef =
  CtCodelistTermsRef
  { ctCodelistTermsRefHref = Nothing
  , ctCodelistTermsRefTitle = Nothing
  , ctCodelistTermsRefType = Nothing
  }

-- ** CtPackage
-- | CtPackage
data CtPackage = CtPackage
  { ctPackageName :: !(Maybe Text) -- ^ "name"
  , ctPackageLabel :: !(Maybe Text) -- ^ "label"
  , ctPackageDescription :: !(Maybe Text) -- ^ "description"
  , ctPackageSource :: !(Maybe Text) -- ^ "source"
  , ctPackageEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , ctPackageRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , ctPackageVersion :: !(Maybe Text) -- ^ "version"
  , ctPackageLinks :: !(Maybe CtPackageLinks) -- ^ "_links"
  , ctPackageCodelists :: !(Maybe [CtPackageCodelists]) -- ^ "codelists"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtPackage
instance A.FromJSON CtPackage where
  parseJSON = A.withObject "CtPackage" $ \o ->
    CtPackage
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")
      <*> (o .:? "codelists")

-- | ToJSON CtPackage
instance A.ToJSON CtPackage where
  toJSON CtPackage {..} =
   _omitNulls
      [ "name" .= ctPackageName
      , "label" .= ctPackageLabel
      , "description" .= ctPackageDescription
      , "source" .= ctPackageSource
      , "effectiveDate" .= ctPackageEffectiveDate
      , "registrationStatus" .= ctPackageRegistrationStatus
      , "version" .= ctPackageVersion
      , "_links" .= ctPackageLinks
      , "codelists" .= ctPackageCodelists
      ]


-- | Construct a value of type 'CtPackage' (by applying it's required fields, if any)
mkCtPackage
  :: CtPackage
mkCtPackage =
  CtPackage
  { ctPackageName = Nothing
  , ctPackageLabel = Nothing
  , ctPackageDescription = Nothing
  , ctPackageSource = Nothing
  , ctPackageEffectiveDate = Nothing
  , ctPackageRegistrationStatus = Nothing
  , ctPackageVersion = Nothing
  , ctPackageLinks = Nothing
  , ctPackageCodelists = Nothing
  }

-- ** CtPackageCodelists
-- | CtPackageCodelists
data CtPackageCodelists = CtPackageCodelists
  { ctPackageCodelistsName :: !(Maybe Text) -- ^ "name"
  , ctPackageCodelistsLabel :: !(Maybe Text) -- ^ "label"
  , ctPackageCodelistsDescription :: !(Maybe Text) -- ^ "description"
  , ctPackageCodelistsSource :: !(Maybe Text) -- ^ "source"
  , ctPackageCodelistsEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , ctPackageCodelistsRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , ctPackageCodelistsVersion :: !(Maybe Text) -- ^ "version"
  , ctPackageCodelistsLinks :: !(Maybe CtPackageCodelistsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtPackageCodelists
instance A.FromJSON CtPackageCodelists where
  parseJSON = A.withObject "CtPackageCodelists" $ \o ->
    CtPackageCodelists
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")

-- | ToJSON CtPackageCodelists
instance A.ToJSON CtPackageCodelists where
  toJSON CtPackageCodelists {..} =
   _omitNulls
      [ "name" .= ctPackageCodelistsName
      , "label" .= ctPackageCodelistsLabel
      , "description" .= ctPackageCodelistsDescription
      , "source" .= ctPackageCodelistsSource
      , "effectiveDate" .= ctPackageCodelistsEffectiveDate
      , "registrationStatus" .= ctPackageCodelistsRegistrationStatus
      , "version" .= ctPackageCodelistsVersion
      , "_links" .= ctPackageCodelistsLinks
      ]


-- | Construct a value of type 'CtPackageCodelists' (by applying it's required fields, if any)
mkCtPackageCodelists
  :: CtPackageCodelists
mkCtPackageCodelists =
  CtPackageCodelists
  { ctPackageCodelistsName = Nothing
  , ctPackageCodelistsLabel = Nothing
  , ctPackageCodelistsDescription = Nothing
  , ctPackageCodelistsSource = Nothing
  , ctPackageCodelistsEffectiveDate = Nothing
  , ctPackageCodelistsRegistrationStatus = Nothing
  , ctPackageCodelistsVersion = Nothing
  , ctPackageCodelistsLinks = Nothing
  }

-- ** CtPackageCodelistsLinks
-- | CtPackageCodelistsLinks
data CtPackageCodelistsLinks = CtPackageCodelistsLinks
  { ctPackageCodelistsLinksSelf :: !(Maybe CtPackageCodelistsRef) -- ^ "self"
  , ctPackageCodelistsLinksPriorVersion :: !(Maybe CtPackageCodelistsRef) -- ^ "priorVersion"
  , ctPackageCodelistsLinksCodelists :: !(Maybe [CtCodelistRefElement]) -- ^ "codelists"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtPackageCodelistsLinks
instance A.FromJSON CtPackageCodelistsLinks where
  parseJSON = A.withObject "CtPackageCodelistsLinks" $ \o ->
    CtPackageCodelistsLinks
      <$> (o .:? "self")
      <*> (o .:? "priorVersion")
      <*> (o .:? "codelists")

-- | ToJSON CtPackageCodelistsLinks
instance A.ToJSON CtPackageCodelistsLinks where
  toJSON CtPackageCodelistsLinks {..} =
   _omitNulls
      [ "self" .= ctPackageCodelistsLinksSelf
      , "priorVersion" .= ctPackageCodelistsLinksPriorVersion
      , "codelists" .= ctPackageCodelistsLinksCodelists
      ]


-- | Construct a value of type 'CtPackageCodelistsLinks' (by applying it's required fields, if any)
mkCtPackageCodelistsLinks
  :: CtPackageCodelistsLinks
mkCtPackageCodelistsLinks =
  CtPackageCodelistsLinks
  { ctPackageCodelistsLinksSelf = Nothing
  , ctPackageCodelistsLinksPriorVersion = Nothing
  , ctPackageCodelistsLinksCodelists = Nothing
  }

-- ** CtPackageCodelistsRef
-- | CtPackageCodelistsRef
data CtPackageCodelistsRef = CtPackageCodelistsRef
  { ctPackageCodelistsRefHref :: !(Maybe Text) -- ^ "href"
  , ctPackageCodelistsRefTitle :: !(Maybe Text) -- ^ "title"
  , ctPackageCodelistsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtPackageCodelistsRef
instance A.FromJSON CtPackageCodelistsRef where
  parseJSON = A.withObject "CtPackageCodelistsRef" $ \o ->
    CtPackageCodelistsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CtPackageCodelistsRef
instance A.ToJSON CtPackageCodelistsRef where
  toJSON CtPackageCodelistsRef {..} =
   _omitNulls
      [ "href" .= ctPackageCodelistsRefHref
      , "title" .= ctPackageCodelistsRefTitle
      , "type" .= ctPackageCodelistsRefType
      ]


-- | Construct a value of type 'CtPackageCodelistsRef' (by applying it's required fields, if any)
mkCtPackageCodelistsRef
  :: CtPackageCodelistsRef
mkCtPackageCodelistsRef =
  CtPackageCodelistsRef
  { ctPackageCodelistsRefHref = Nothing
  , ctPackageCodelistsRefTitle = Nothing
  , ctPackageCodelistsRefType = Nothing
  }

-- ** CtPackageLinks
-- | CtPackageLinks
data CtPackageLinks = CtPackageLinks
  { ctPackageLinksSelf :: !(Maybe CtPackageRef) -- ^ "self"
  , ctPackageLinksPriorVersion :: !(Maybe CtPackageRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtPackageLinks
instance A.FromJSON CtPackageLinks where
  parseJSON = A.withObject "CtPackageLinks" $ \o ->
    CtPackageLinks
      <$> (o .:? "self")
      <*> (o .:? "priorVersion")

-- | ToJSON CtPackageLinks
instance A.ToJSON CtPackageLinks where
  toJSON CtPackageLinks {..} =
   _omitNulls
      [ "self" .= ctPackageLinksSelf
      , "priorVersion" .= ctPackageLinksPriorVersion
      ]


-- | Construct a value of type 'CtPackageLinks' (by applying it's required fields, if any)
mkCtPackageLinks
  :: CtPackageLinks
mkCtPackageLinks =
  CtPackageLinks
  { ctPackageLinksSelf = Nothing
  , ctPackageLinksPriorVersion = Nothing
  }

-- ** CtPackageRef
-- | CtPackageRef
data CtPackageRef = CtPackageRef
  { ctPackageRefHref :: !(Maybe Text) -- ^ "href"
  , ctPackageRefTitle :: !(Maybe Text) -- ^ "title"
  , ctPackageRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtPackageRef
instance A.FromJSON CtPackageRef where
  parseJSON = A.withObject "CtPackageRef" $ \o ->
    CtPackageRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CtPackageRef
instance A.ToJSON CtPackageRef where
  toJSON CtPackageRef {..} =
   _omitNulls
      [ "href" .= ctPackageRefHref
      , "title" .= ctPackageRefTitle
      , "type" .= ctPackageRefType
      ]


-- | Construct a value of type 'CtPackageRef' (by applying it's required fields, if any)
mkCtPackageRef
  :: CtPackageRef
mkCtPackageRef =
  CtPackageRef
  { ctPackageRefHref = Nothing
  , ctPackageRefTitle = Nothing
  , ctPackageRefType = Nothing
  }

-- ** CtPackageRefElement
-- | CtPackageRefElement
data CtPackageRefElement = CtPackageRefElement
  { ctPackageRefElementHref :: !(Maybe Text) -- ^ "href"
  , ctPackageRefElementTitle :: !(Maybe Text) -- ^ "title"
  , ctPackageRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtPackageRefElement
instance A.FromJSON CtPackageRefElement where
  parseJSON = A.withObject "CtPackageRefElement" $ \o ->
    CtPackageRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CtPackageRefElement
instance A.ToJSON CtPackageRefElement where
  toJSON CtPackageRefElement {..} =
   _omitNulls
      [ "href" .= ctPackageRefElementHref
      , "title" .= ctPackageRefElementTitle
      , "type" .= ctPackageRefElementType
      ]


-- | Construct a value of type 'CtPackageRefElement' (by applying it's required fields, if any)
mkCtPackageRefElement
  :: CtPackageRefElement
mkCtPackageRefElement =
  CtPackageRefElement
  { ctPackageRefElementHref = Nothing
  , ctPackageRefElementTitle = Nothing
  , ctPackageRefElementType = Nothing
  }

-- ** CtPackageTerm
-- | CtPackageTerm
data CtPackageTerm = CtPackageTerm
  { ctPackageTermConceptId :: !(Maybe Text) -- ^ "conceptId"
  , ctPackageTermSubmissionValue :: !(Maybe Text) -- ^ "submissionValue"
  , ctPackageTermDefinition :: !(Maybe Text) -- ^ "definition"
  , ctPackageTermPreferredTerm :: !(Maybe Text) -- ^ "preferredTerm"
  , ctPackageTermSynonyms :: !(Maybe [Text]) -- ^ "synonyms"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtPackageTerm
instance A.FromJSON CtPackageTerm where
  parseJSON = A.withObject "CtPackageTerm" $ \o ->
    CtPackageTerm
      <$> (o .:? "conceptId")
      <*> (o .:? "submissionValue")
      <*> (o .:? "definition")
      <*> (o .:? "preferredTerm")
      <*> (o .:? "synonyms")

-- | ToJSON CtPackageTerm
instance A.ToJSON CtPackageTerm where
  toJSON CtPackageTerm {..} =
   _omitNulls
      [ "conceptId" .= ctPackageTermConceptId
      , "submissionValue" .= ctPackageTermSubmissionValue
      , "definition" .= ctPackageTermDefinition
      , "preferredTerm" .= ctPackageTermPreferredTerm
      , "synonyms" .= ctPackageTermSynonyms
      ]


-- | Construct a value of type 'CtPackageTerm' (by applying it's required fields, if any)
mkCtPackageTerm
  :: CtPackageTerm
mkCtPackageTerm =
  CtPackageTerm
  { ctPackageTermConceptId = Nothing
  , ctPackageTermSubmissionValue = Nothing
  , ctPackageTermDefinition = Nothing
  , ctPackageTermPreferredTerm = Nothing
  , ctPackageTermSynonyms = Nothing
  }

-- ** CtPackages
-- | CtPackages
data CtPackages = CtPackages
  { ctPackagesLinks :: !(Maybe CtPackagesLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtPackages
instance A.FromJSON CtPackages where
  parseJSON = A.withObject "CtPackages" $ \o ->
    CtPackages
      <$> (o .:? "_links")

-- | ToJSON CtPackages
instance A.ToJSON CtPackages where
  toJSON CtPackages {..} =
   _omitNulls
      [ "_links" .= ctPackagesLinks
      ]


-- | Construct a value of type 'CtPackages' (by applying it's required fields, if any)
mkCtPackages
  :: CtPackages
mkCtPackages =
  CtPackages
  { ctPackagesLinks = Nothing
  }

-- ** CtPackagesLinks
-- | CtPackagesLinks
data CtPackagesLinks = CtPackagesLinks
  { ctPackagesLinksSelf :: !(Maybe CtPackagesRef) -- ^ "self"
  , ctPackagesLinksPackages :: !(Maybe [CtPackageRefElement]) -- ^ "packages"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtPackagesLinks
instance A.FromJSON CtPackagesLinks where
  parseJSON = A.withObject "CtPackagesLinks" $ \o ->
    CtPackagesLinks
      <$> (o .:? "self")
      <*> (o .:? "packages")

-- | ToJSON CtPackagesLinks
instance A.ToJSON CtPackagesLinks where
  toJSON CtPackagesLinks {..} =
   _omitNulls
      [ "self" .= ctPackagesLinksSelf
      , "packages" .= ctPackagesLinksPackages
      ]


-- | Construct a value of type 'CtPackagesLinks' (by applying it's required fields, if any)
mkCtPackagesLinks
  :: CtPackagesLinks
mkCtPackagesLinks =
  CtPackagesLinks
  { ctPackagesLinksSelf = Nothing
  , ctPackagesLinksPackages = Nothing
  }

-- ** CtPackagesRef
-- | CtPackagesRef
data CtPackagesRef = CtPackagesRef
  { ctPackagesRefHref :: !(Maybe Text) -- ^ "href"
  , ctPackagesRefTitle :: !(Maybe Text) -- ^ "title"
  , ctPackagesRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtPackagesRef
instance A.FromJSON CtPackagesRef where
  parseJSON = A.withObject "CtPackagesRef" $ \o ->
    CtPackagesRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CtPackagesRef
instance A.ToJSON CtPackagesRef where
  toJSON CtPackagesRef {..} =
   _omitNulls
      [ "href" .= ctPackagesRefHref
      , "title" .= ctPackagesRefTitle
      , "type" .= ctPackagesRefType
      ]


-- | Construct a value of type 'CtPackagesRef' (by applying it's required fields, if any)
mkCtPackagesRef
  :: CtPackagesRef
mkCtPackagesRef =
  CtPackagesRef
  { ctPackagesRefHref = Nothing
  , ctPackagesRefTitle = Nothing
  , ctPackagesRefType = Nothing
  }

-- ** CtTerm
-- | CtTerm
data CtTerm = CtTerm
  { ctTermConceptId :: !(Maybe Text) -- ^ "conceptId"
  , ctTermSubmissionValue :: !(Maybe Text) -- ^ "submissionValue"
  , ctTermDefinition :: !(Maybe Text) -- ^ "definition"
  , ctTermPreferredTerm :: !(Maybe Text) -- ^ "preferredTerm"
  , ctTermSynonyms :: !(Maybe [Text]) -- ^ "synonyms"
  , ctTermLinks :: !(Maybe CtTermLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtTerm
instance A.FromJSON CtTerm where
  parseJSON = A.withObject "CtTerm" $ \o ->
    CtTerm
      <$> (o .:? "conceptId")
      <*> (o .:? "submissionValue")
      <*> (o .:? "definition")
      <*> (o .:? "preferredTerm")
      <*> (o .:? "synonyms")
      <*> (o .:? "_links")

-- | ToJSON CtTerm
instance A.ToJSON CtTerm where
  toJSON CtTerm {..} =
   _omitNulls
      [ "conceptId" .= ctTermConceptId
      , "submissionValue" .= ctTermSubmissionValue
      , "definition" .= ctTermDefinition
      , "preferredTerm" .= ctTermPreferredTerm
      , "synonyms" .= ctTermSynonyms
      , "_links" .= ctTermLinks
      ]


-- | Construct a value of type 'CtTerm' (by applying it's required fields, if any)
mkCtTerm
  :: CtTerm
mkCtTerm =
  CtTerm
  { ctTermConceptId = Nothing
  , ctTermSubmissionValue = Nothing
  , ctTermDefinition = Nothing
  , ctTermPreferredTerm = Nothing
  , ctTermSynonyms = Nothing
  , ctTermLinks = Nothing
  }

-- ** CtTermLinks
-- | CtTermLinks
data CtTermLinks = CtTermLinks
  { ctTermLinksSelf :: !(Maybe CtTermRef) -- ^ "self"
  , ctTermLinksParentPackage :: !(Maybe CtPackageRef) -- ^ "parentPackage"
  , ctTermLinksParentCodelist :: !(Maybe CtCodelistRef) -- ^ "parentCodelist"
  , ctTermLinksRootItem :: !(Maybe RootCtTermRef) -- ^ "rootItem"
  , ctTermLinksPriorVersion :: !(Maybe CtTermRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtTermLinks
instance A.FromJSON CtTermLinks where
  parseJSON = A.withObject "CtTermLinks" $ \o ->
    CtTermLinks
      <$> (o .:? "self")
      <*> (o .:? "parentPackage")
      <*> (o .:? "parentCodelist")
      <*> (o .:? "rootItem")
      <*> (o .:? "priorVersion")

-- | ToJSON CtTermLinks
instance A.ToJSON CtTermLinks where
  toJSON CtTermLinks {..} =
   _omitNulls
      [ "self" .= ctTermLinksSelf
      , "parentPackage" .= ctTermLinksParentPackage
      , "parentCodelist" .= ctTermLinksParentCodelist
      , "rootItem" .= ctTermLinksRootItem
      , "priorVersion" .= ctTermLinksPriorVersion
      ]


-- | Construct a value of type 'CtTermLinks' (by applying it's required fields, if any)
mkCtTermLinks
  :: CtTermLinks
mkCtTermLinks =
  CtTermLinks
  { ctTermLinksSelf = Nothing
  , ctTermLinksParentPackage = Nothing
  , ctTermLinksParentCodelist = Nothing
  , ctTermLinksRootItem = Nothing
  , ctTermLinksPriorVersion = Nothing
  }

-- ** CtTermRef
-- | CtTermRef
data CtTermRef = CtTermRef
  { ctTermRefHref :: !(Maybe Text) -- ^ "href"
  , ctTermRefTitle :: !(Maybe Text) -- ^ "title"
  , ctTermRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtTermRef
instance A.FromJSON CtTermRef where
  parseJSON = A.withObject "CtTermRef" $ \o ->
    CtTermRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CtTermRef
instance A.ToJSON CtTermRef where
  toJSON CtTermRef {..} =
   _omitNulls
      [ "href" .= ctTermRefHref
      , "title" .= ctTermRefTitle
      , "type" .= ctTermRefType
      ]


-- | Construct a value of type 'CtTermRef' (by applying it's required fields, if any)
mkCtTermRef
  :: CtTermRef
mkCtTermRef =
  CtTermRef
  { ctTermRefHref = Nothing
  , ctTermRefTitle = Nothing
  , ctTermRefType = Nothing
  }

-- ** CtTermRefElement
-- | CtTermRefElement
data CtTermRefElement = CtTermRefElement
  { ctTermRefElementHref :: !(Maybe Text) -- ^ "href"
  , ctTermRefElementTitle :: !(Maybe Text) -- ^ "title"
  , ctTermRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtTermRefElement
instance A.FromJSON CtTermRefElement where
  parseJSON = A.withObject "CtTermRefElement" $ \o ->
    CtTermRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CtTermRefElement
instance A.ToJSON CtTermRefElement where
  toJSON CtTermRefElement {..} =
   _omitNulls
      [ "href" .= ctTermRefElementHref
      , "title" .= ctTermRefElementTitle
      , "type" .= ctTermRefElementType
      ]


-- | Construct a value of type 'CtTermRefElement' (by applying it's required fields, if any)
mkCtTermRefElement
  :: CtTermRefElement
mkCtTermRefElement =
  CtTermRefElement
  { ctTermRefElementHref = Nothing
  , ctTermRefElementTitle = Nothing
  , ctTermRefElementType = Nothing
  }

-- ** CtTermRefVersion
-- | CtTermRefVersion
data CtTermRefVersion = CtTermRefVersion
  { ctTermRefVersionHref :: !(Maybe Text) -- ^ "href"
  , ctTermRefVersionTitle :: !(Maybe Text) -- ^ "title"
  , ctTermRefVersionType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CtTermRefVersion
instance A.FromJSON CtTermRefVersion where
  parseJSON = A.withObject "CtTermRefVersion" $ \o ->
    CtTermRefVersion
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON CtTermRefVersion
instance A.ToJSON CtTermRefVersion where
  toJSON CtTermRefVersion {..} =
   _omitNulls
      [ "href" .= ctTermRefVersionHref
      , "title" .= ctTermRefVersionTitle
      , "type" .= ctTermRefVersionType
      ]


-- | Construct a value of type 'CtTermRefVersion' (by applying it's required fields, if any)
mkCtTermRefVersion
  :: CtTermRefVersion
mkCtTermRefVersion =
  CtTermRefVersion
  { ctTermRefVersionHref = Nothing
  , ctTermRefVersionTitle = Nothing
  , ctTermRefVersionType = Nothing
  }

-- ** DefaultErrorResponse
-- | DefaultErrorResponse
data DefaultErrorResponse = DefaultErrorResponse
  { defaultErrorResponseStatusCode :: !(Maybe Text) -- ^ "statusCode" - HTTP Status Code
  , defaultErrorResponseReasonPhrase :: !(Maybe Text) -- ^ "reasonPhrase" - HTTP Reason Phrase
  , defaultErrorResponseUserMessage :: !(Maybe Text) -- ^ "userMessage" - User Error Message
  , defaultErrorResponseAdminMessage :: !(Maybe Text) -- ^ "adminMessage" - Admin Error Message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DefaultErrorResponse
instance A.FromJSON DefaultErrorResponse where
  parseJSON = A.withObject "DefaultErrorResponse" $ \o ->
    DefaultErrorResponse
      <$> (o .:? "statusCode")
      <*> (o .:? "reasonPhrase")
      <*> (o .:? "userMessage")
      <*> (o .:? "adminMessage")

-- | ToJSON DefaultErrorResponse
instance A.ToJSON DefaultErrorResponse where
  toJSON DefaultErrorResponse {..} =
   _omitNulls
      [ "statusCode" .= defaultErrorResponseStatusCode
      , "reasonPhrase" .= defaultErrorResponseReasonPhrase
      , "userMessage" .= defaultErrorResponseUserMessage
      , "adminMessage" .= defaultErrorResponseAdminMessage
      ]


-- | Construct a value of type 'DefaultErrorResponse' (by applying it's required fields, if any)
mkDefaultErrorResponse
  :: DefaultErrorResponse
mkDefaultErrorResponse =
  DefaultErrorResponse
  { defaultErrorResponseStatusCode = Nothing
  , defaultErrorResponseReasonPhrase = Nothing
  , defaultErrorResponseUserMessage = Nothing
  , defaultErrorResponseAdminMessage = Nothing
  }

-- ** DefaultSearchResponse
-- | DefaultSearchResponse
data DefaultSearchResponse = DefaultSearchResponse
  { defaultSearchResponseHits :: !(Maybe [DefaultSearchResponseHitsInner]) -- ^ "hits"
  , defaultSearchResponseTotalHits :: !(Maybe Double) -- ^ "totalHits"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DefaultSearchResponse
instance A.FromJSON DefaultSearchResponse where
  parseJSON = A.withObject "DefaultSearchResponse" $ \o ->
    DefaultSearchResponse
      <$> (o .:? "hits")
      <*> (o .:? "totalHits")

-- | ToJSON DefaultSearchResponse
instance A.ToJSON DefaultSearchResponse where
  toJSON DefaultSearchResponse {..} =
   _omitNulls
      [ "hits" .= defaultSearchResponseHits
      , "totalHits" .= defaultSearchResponseTotalHits
      ]


-- | Construct a value of type 'DefaultSearchResponse' (by applying it's required fields, if any)
mkDefaultSearchResponse
  :: DefaultSearchResponse
mkDefaultSearchResponse =
  DefaultSearchResponse
  { defaultSearchResponseHits = Nothing
  , defaultSearchResponseTotalHits = Nothing
  }

-- ** DefaultSearchResponseHitsInner
-- | DefaultSearchResponseHitsInner
data DefaultSearchResponseHitsInner = DefaultSearchResponseHitsInner
  { defaultSearchResponseHitsInnerHref :: !(Text) -- ^ /Required/ "href"
  , defaultSearchResponseHitsInnerType :: !(Text) -- ^ /Required/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DefaultSearchResponseHitsInner
instance A.FromJSON DefaultSearchResponseHitsInner where
  parseJSON = A.withObject "DefaultSearchResponseHitsInner" $ \o ->
    DefaultSearchResponseHitsInner
      <$> (o .:  "href")
      <*> (o .:  "type")

-- | ToJSON DefaultSearchResponseHitsInner
instance A.ToJSON DefaultSearchResponseHitsInner where
  toJSON DefaultSearchResponseHitsInner {..} =
   _omitNulls
      [ "href" .= defaultSearchResponseHitsInnerHref
      , "type" .= defaultSearchResponseHitsInnerType
      ]


-- | Construct a value of type 'DefaultSearchResponseHitsInner' (by applying it's required fields, if any)
mkDefaultSearchResponseHitsInner
  :: Text -- ^ 'defaultSearchResponseHitsInnerHref' 
  -> Text -- ^ 'defaultSearchResponseHitsInnerType' 
  -> DefaultSearchResponseHitsInner
mkDefaultSearchResponseHitsInner defaultSearchResponseHitsInnerHref defaultSearchResponseHitsInnerType =
  DefaultSearchResponseHitsInner
  { defaultSearchResponseHitsInnerHref
  , defaultSearchResponseHitsInnerType
  }

-- ** ExportAdamDatastructuresRow
-- | ExportAdamDatastructuresRow
data ExportAdamDatastructuresRow = ExportAdamDatastructuresRow
  { exportAdamDatastructuresRowVersion :: !(Maybe Text) -- ^ "Version"
  , exportAdamDatastructuresRowDataStructureName :: !(Maybe Text) -- ^ "Data Structure Name"
  , exportAdamDatastructuresRowDatasetName :: !(Maybe Text) -- ^ "Dataset Name"
  , exportAdamDatastructuresRowDatasetLabel :: !(Maybe Text) -- ^ "Dataset Label"
  , exportAdamDatastructuresRowDatasetDescription :: !(Maybe Text) -- ^ "Dataset Description"
  , exportAdamDatastructuresRowClass :: !(Maybe Text) -- ^ "Class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportAdamDatastructuresRow
instance A.FromJSON ExportAdamDatastructuresRow where
  parseJSON = A.withObject "ExportAdamDatastructuresRow" $ \o ->
    ExportAdamDatastructuresRow
      <$> (o .:? "Version")
      <*> (o .:? "Data Structure Name")
      <*> (o .:? "Dataset Name")
      <*> (o .:? "Dataset Label")
      <*> (o .:? "Dataset Description")
      <*> (o .:? "Class")

-- | ToJSON ExportAdamDatastructuresRow
instance A.ToJSON ExportAdamDatastructuresRow where
  toJSON ExportAdamDatastructuresRow {..} =
   _omitNulls
      [ "Version" .= exportAdamDatastructuresRowVersion
      , "Data Structure Name" .= exportAdamDatastructuresRowDataStructureName
      , "Dataset Name" .= exportAdamDatastructuresRowDatasetName
      , "Dataset Label" .= exportAdamDatastructuresRowDatasetLabel
      , "Dataset Description" .= exportAdamDatastructuresRowDatasetDescription
      , "Class" .= exportAdamDatastructuresRowClass
      ]


-- | Construct a value of type 'ExportAdamDatastructuresRow' (by applying it's required fields, if any)
mkExportAdamDatastructuresRow
  :: ExportAdamDatastructuresRow
mkExportAdamDatastructuresRow =
  ExportAdamDatastructuresRow
  { exportAdamDatastructuresRowVersion = Nothing
  , exportAdamDatastructuresRowDataStructureName = Nothing
  , exportAdamDatastructuresRowDatasetName = Nothing
  , exportAdamDatastructuresRowDatasetLabel = Nothing
  , exportAdamDatastructuresRowDatasetDescription = Nothing
  , exportAdamDatastructuresRowClass = Nothing
  }

-- ** ExportAdamDatastructuresTable
-- | ExportAdamDatastructuresTable
data ExportAdamDatastructuresTable = ExportAdamDatastructuresTable
  { exportAdamDatastructuresTableDatastructures :: !(Maybe [ExportAdamDatastructuresRow]) -- ^ "datastructures"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportAdamDatastructuresTable
instance A.FromJSON ExportAdamDatastructuresTable where
  parseJSON = A.withObject "ExportAdamDatastructuresTable" $ \o ->
    ExportAdamDatastructuresTable
      <$> (o .:? "datastructures")

-- | ToJSON ExportAdamDatastructuresTable
instance A.ToJSON ExportAdamDatastructuresTable where
  toJSON ExportAdamDatastructuresTable {..} =
   _omitNulls
      [ "datastructures" .= exportAdamDatastructuresTableDatastructures
      ]


-- | Construct a value of type 'ExportAdamDatastructuresTable' (by applying it's required fields, if any)
mkExportAdamDatastructuresTable
  :: ExportAdamDatastructuresTable
mkExportAdamDatastructuresTable =
  ExportAdamDatastructuresTable
  { exportAdamDatastructuresTableDatastructures = Nothing
  }

-- ** ExportAdamVariablesRow
-- | ExportAdamVariablesRow
data ExportAdamVariablesRow = ExportAdamVariablesRow
  { exportAdamVariablesRowVersion :: !(Maybe Text) -- ^ "Version"
  , exportAdamVariablesRowDataStructureName :: !(Maybe Text) -- ^ "Data Structure Name"
  , exportAdamVariablesRowDatasetName :: !(Maybe Text) -- ^ "Dataset Name"
  , exportAdamVariablesRowVariableGroup :: !(Maybe Text) -- ^ "Variable Group"
  , exportAdamVariablesRowVariableName :: !(Maybe Text) -- ^ "Variable Name"
  , exportAdamVariablesRowVariableLabel :: !(Maybe Text) -- ^ "Variable Label"
  , exportAdamVariablesRowType :: !(Maybe Text) -- ^ "Type"
  , exportAdamVariablesRowCodelistControlledTerms :: !(Maybe Text) -- ^ "Codelist/Controlled Terms"
  , exportAdamVariablesRowCore :: !(Maybe Text) -- ^ "Core"
  , exportAdamVariablesRowCdiscNotes :: !(Maybe Text) -- ^ "CDISC Notes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportAdamVariablesRow
instance A.FromJSON ExportAdamVariablesRow where
  parseJSON = A.withObject "ExportAdamVariablesRow" $ \o ->
    ExportAdamVariablesRow
      <$> (o .:? "Version")
      <*> (o .:? "Data Structure Name")
      <*> (o .:? "Dataset Name")
      <*> (o .:? "Variable Group")
      <*> (o .:? "Variable Name")
      <*> (o .:? "Variable Label")
      <*> (o .:? "Type")
      <*> (o .:? "Codelist/Controlled Terms")
      <*> (o .:? "Core")
      <*> (o .:? "CDISC Notes")

-- | ToJSON ExportAdamVariablesRow
instance A.ToJSON ExportAdamVariablesRow where
  toJSON ExportAdamVariablesRow {..} =
   _omitNulls
      [ "Version" .= exportAdamVariablesRowVersion
      , "Data Structure Name" .= exportAdamVariablesRowDataStructureName
      , "Dataset Name" .= exportAdamVariablesRowDatasetName
      , "Variable Group" .= exportAdamVariablesRowVariableGroup
      , "Variable Name" .= exportAdamVariablesRowVariableName
      , "Variable Label" .= exportAdamVariablesRowVariableLabel
      , "Type" .= exportAdamVariablesRowType
      , "Codelist/Controlled Terms" .= exportAdamVariablesRowCodelistControlledTerms
      , "Core" .= exportAdamVariablesRowCore
      , "CDISC Notes" .= exportAdamVariablesRowCdiscNotes
      ]


-- | Construct a value of type 'ExportAdamVariablesRow' (by applying it's required fields, if any)
mkExportAdamVariablesRow
  :: ExportAdamVariablesRow
mkExportAdamVariablesRow =
  ExportAdamVariablesRow
  { exportAdamVariablesRowVersion = Nothing
  , exportAdamVariablesRowDataStructureName = Nothing
  , exportAdamVariablesRowDatasetName = Nothing
  , exportAdamVariablesRowVariableGroup = Nothing
  , exportAdamVariablesRowVariableName = Nothing
  , exportAdamVariablesRowVariableLabel = Nothing
  , exportAdamVariablesRowType = Nothing
  , exportAdamVariablesRowCodelistControlledTerms = Nothing
  , exportAdamVariablesRowCore = Nothing
  , exportAdamVariablesRowCdiscNotes = Nothing
  }

-- ** ExportAdamVariablesTable
-- | ExportAdamVariablesTable
data ExportAdamVariablesTable = ExportAdamVariablesTable
  { exportAdamVariablesTableVariables :: !(Maybe [ExportAdamVariablesRow]) -- ^ "variables"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportAdamVariablesTable
instance A.FromJSON ExportAdamVariablesTable where
  parseJSON = A.withObject "ExportAdamVariablesTable" $ \o ->
    ExportAdamVariablesTable
      <$> (o .:? "variables")

-- | ToJSON ExportAdamVariablesTable
instance A.ToJSON ExportAdamVariablesTable where
  toJSON ExportAdamVariablesTable {..} =
   _omitNulls
      [ "variables" .= exportAdamVariablesTableVariables
      ]


-- | Construct a value of type 'ExportAdamVariablesTable' (by applying it's required fields, if any)
mkExportAdamVariablesTable
  :: ExportAdamVariablesTable
mkExportAdamVariablesTable =
  ExportAdamVariablesTable
  { exportAdamVariablesTableVariables = Nothing
  }

-- ** ExportAdamWorkbook
-- | ExportAdamWorkbook
data ExportAdamWorkbook = ExportAdamWorkbook
  { exportAdamWorkbookVariables :: !(Maybe [ExportAdamVariablesRow]) -- ^ "variables"
  , exportAdamWorkbookDatastructures :: !(Maybe [ExportAdamDatastructuresRow]) -- ^ "datastructures"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportAdamWorkbook
instance A.FromJSON ExportAdamWorkbook where
  parseJSON = A.withObject "ExportAdamWorkbook" $ \o ->
    ExportAdamWorkbook
      <$> (o .:? "variables")
      <*> (o .:? "datastructures")

-- | ToJSON ExportAdamWorkbook
instance A.ToJSON ExportAdamWorkbook where
  toJSON ExportAdamWorkbook {..} =
   _omitNulls
      [ "variables" .= exportAdamWorkbookVariables
      , "datastructures" .= exportAdamWorkbookDatastructures
      ]


-- | Construct a value of type 'ExportAdamWorkbook' (by applying it's required fields, if any)
mkExportAdamWorkbook
  :: ExportAdamWorkbook
mkExportAdamWorkbook =
  ExportAdamWorkbook
  { exportAdamWorkbookVariables = Nothing
  , exportAdamWorkbookDatastructures = Nothing
  }

-- ** ExportCdashClassVariablesRow
-- | ExportCdashClassVariablesRow
data ExportCdashClassVariablesRow = ExportCdashClassVariablesRow
  { exportCdashClassVariablesRowVersion :: !(Maybe Text) -- ^ "Version"
  , exportCdashClassVariablesRowClass :: !(Maybe Text) -- ^ "Class"
  , exportCdashClassVariablesRowDomain :: !(Maybe Text) -- ^ "Domain"
  , exportCdashClassVariablesRowVariableOrder :: !(Maybe Text) -- ^ "Variable Order"
  , exportCdashClassVariablesRowCdashVariable :: !(Maybe Text) -- ^ "CDASH Variable"
  , exportCdashClassVariablesRowCdashVariableLabel :: !(Maybe Text) -- ^ "CDASH Variable Label"
  , exportCdashClassVariablesRowDraftCdashDefinition :: !(Maybe Text) -- ^ "DRAFT CDASH Definition"
  , exportCdashClassVariablesRowDomainSpecific :: !(Maybe Text) -- ^ "Domain Specific"
  , exportCdashClassVariablesRowQuestionText :: !(Maybe Text) -- ^ "Question Text"
  , exportCdashClassVariablesRowPrompt :: !(Maybe Text) -- ^ "Prompt"
  , exportCdashClassVariablesRowType :: !(Maybe Text) -- ^ "Type"
  , exportCdashClassVariablesRowSdtmTarget :: !(Maybe [Text]) -- ^ "SDTM Target"
  , exportCdashClassVariablesRowMappingInstructions :: !(Maybe Text) -- ^ "Mapping Instructions"
  , exportCdashClassVariablesRowControlledTerminologyCodelistName :: !(Maybe Text) -- ^ "Controlled Terminology Codelist Name"
  , exportCdashClassVariablesRowImplementationNotes :: !(Maybe Text) -- ^ "Implementation Notes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportCdashClassVariablesRow
instance A.FromJSON ExportCdashClassVariablesRow where
  parseJSON = A.withObject "ExportCdashClassVariablesRow" $ \o ->
    ExportCdashClassVariablesRow
      <$> (o .:? "Version")
      <*> (o .:? "Class")
      <*> (o .:? "Domain")
      <*> (o .:? "Variable Order")
      <*> (o .:? "CDASH Variable")
      <*> (o .:? "CDASH Variable Label")
      <*> (o .:? "DRAFT CDASH Definition")
      <*> (o .:? "Domain Specific")
      <*> (o .:? "Question Text")
      <*> (o .:? "Prompt")
      <*> (o .:? "Type")
      <*> (o .:? "SDTM Target")
      <*> (o .:? "Mapping Instructions")
      <*> (o .:? "Controlled Terminology Codelist Name")
      <*> (o .:? "Implementation Notes")

-- | ToJSON ExportCdashClassVariablesRow
instance A.ToJSON ExportCdashClassVariablesRow where
  toJSON ExportCdashClassVariablesRow {..} =
   _omitNulls
      [ "Version" .= exportCdashClassVariablesRowVersion
      , "Class" .= exportCdashClassVariablesRowClass
      , "Domain" .= exportCdashClassVariablesRowDomain
      , "Variable Order" .= exportCdashClassVariablesRowVariableOrder
      , "CDASH Variable" .= exportCdashClassVariablesRowCdashVariable
      , "CDASH Variable Label" .= exportCdashClassVariablesRowCdashVariableLabel
      , "DRAFT CDASH Definition" .= exportCdashClassVariablesRowDraftCdashDefinition
      , "Domain Specific" .= exportCdashClassVariablesRowDomainSpecific
      , "Question Text" .= exportCdashClassVariablesRowQuestionText
      , "Prompt" .= exportCdashClassVariablesRowPrompt
      , "Type" .= exportCdashClassVariablesRowType
      , "SDTM Target" .= exportCdashClassVariablesRowSdtmTarget
      , "Mapping Instructions" .= exportCdashClassVariablesRowMappingInstructions
      , "Controlled Terminology Codelist Name" .= exportCdashClassVariablesRowControlledTerminologyCodelistName
      , "Implementation Notes" .= exportCdashClassVariablesRowImplementationNotes
      ]


-- | Construct a value of type 'ExportCdashClassVariablesRow' (by applying it's required fields, if any)
mkExportCdashClassVariablesRow
  :: ExportCdashClassVariablesRow
mkExportCdashClassVariablesRow =
  ExportCdashClassVariablesRow
  { exportCdashClassVariablesRowVersion = Nothing
  , exportCdashClassVariablesRowClass = Nothing
  , exportCdashClassVariablesRowDomain = Nothing
  , exportCdashClassVariablesRowVariableOrder = Nothing
  , exportCdashClassVariablesRowCdashVariable = Nothing
  , exportCdashClassVariablesRowCdashVariableLabel = Nothing
  , exportCdashClassVariablesRowDraftCdashDefinition = Nothing
  , exportCdashClassVariablesRowDomainSpecific = Nothing
  , exportCdashClassVariablesRowQuestionText = Nothing
  , exportCdashClassVariablesRowPrompt = Nothing
  , exportCdashClassVariablesRowType = Nothing
  , exportCdashClassVariablesRowSdtmTarget = Nothing
  , exportCdashClassVariablesRowMappingInstructions = Nothing
  , exportCdashClassVariablesRowControlledTerminologyCodelistName = Nothing
  , exportCdashClassVariablesRowImplementationNotes = Nothing
  }

-- ** ExportCdashDomainVariablesRow
-- | ExportCdashDomainVariablesRow
data ExportCdashDomainVariablesRow = ExportCdashDomainVariablesRow
  { exportCdashDomainVariablesRowVersion :: !(Maybe Text) -- ^ "Version"
  , exportCdashDomainVariablesRowClass :: !(Maybe Text) -- ^ "Class"
  , exportCdashDomainVariablesRowDomain :: !(Maybe Text) -- ^ "Domain"
  , exportCdashDomainVariablesRowVariableOrder :: !(Maybe Text) -- ^ "Variable Order"
  , exportCdashDomainVariablesRowCdashVariable :: !(Maybe Text) -- ^ "CDASH Variable"
  , exportCdashDomainVariablesRowCdashVariableLabel :: !(Maybe Text) -- ^ "CDASH Variable Label"
  , exportCdashDomainVariablesRowDraftCdashDefinition :: !(Maybe Text) -- ^ "DRAFT CDASH Definition"
  , exportCdashDomainVariablesRowDomainSpecific :: !(Maybe Text) -- ^ "Domain Specific"
  , exportCdashDomainVariablesRowQuestionText :: !(Maybe Text) -- ^ "Question Text"
  , exportCdashDomainVariablesRowPrompt :: !(Maybe Text) -- ^ "Prompt"
  , exportCdashDomainVariablesRowType :: !(Maybe Text) -- ^ "Type"
  , exportCdashDomainVariablesRowSdtmTarget :: !(Maybe [Text]) -- ^ "SDTM Target"
  , exportCdashDomainVariablesRowMappingInstructions :: !(Maybe Text) -- ^ "Mapping Instructions"
  , exportCdashDomainVariablesRowControlledTerminologyCodelistName :: !(Maybe Text) -- ^ "Controlled Terminology Codelist Name"
  , exportCdashDomainVariablesRowImplementationNotes :: !(Maybe Text) -- ^ "Implementation Notes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportCdashDomainVariablesRow
instance A.FromJSON ExportCdashDomainVariablesRow where
  parseJSON = A.withObject "ExportCdashDomainVariablesRow" $ \o ->
    ExportCdashDomainVariablesRow
      <$> (o .:? "Version")
      <*> (o .:? "Class")
      <*> (o .:? "Domain")
      <*> (o .:? "Variable Order")
      <*> (o .:? "CDASH Variable")
      <*> (o .:? "CDASH Variable Label")
      <*> (o .:? "DRAFT CDASH Definition")
      <*> (o .:? "Domain Specific")
      <*> (o .:? "Question Text")
      <*> (o .:? "Prompt")
      <*> (o .:? "Type")
      <*> (o .:? "SDTM Target")
      <*> (o .:? "Mapping Instructions")
      <*> (o .:? "Controlled Terminology Codelist Name")
      <*> (o .:? "Implementation Notes")

-- | ToJSON ExportCdashDomainVariablesRow
instance A.ToJSON ExportCdashDomainVariablesRow where
  toJSON ExportCdashDomainVariablesRow {..} =
   _omitNulls
      [ "Version" .= exportCdashDomainVariablesRowVersion
      , "Class" .= exportCdashDomainVariablesRowClass
      , "Domain" .= exportCdashDomainVariablesRowDomain
      , "Variable Order" .= exportCdashDomainVariablesRowVariableOrder
      , "CDASH Variable" .= exportCdashDomainVariablesRowCdashVariable
      , "CDASH Variable Label" .= exportCdashDomainVariablesRowCdashVariableLabel
      , "DRAFT CDASH Definition" .= exportCdashDomainVariablesRowDraftCdashDefinition
      , "Domain Specific" .= exportCdashDomainVariablesRowDomainSpecific
      , "Question Text" .= exportCdashDomainVariablesRowQuestionText
      , "Prompt" .= exportCdashDomainVariablesRowPrompt
      , "Type" .= exportCdashDomainVariablesRowType
      , "SDTM Target" .= exportCdashDomainVariablesRowSdtmTarget
      , "Mapping Instructions" .= exportCdashDomainVariablesRowMappingInstructions
      , "Controlled Terminology Codelist Name" .= exportCdashDomainVariablesRowControlledTerminologyCodelistName
      , "Implementation Notes" .= exportCdashDomainVariablesRowImplementationNotes
      ]


-- | Construct a value of type 'ExportCdashDomainVariablesRow' (by applying it's required fields, if any)
mkExportCdashDomainVariablesRow
  :: ExportCdashDomainVariablesRow
mkExportCdashDomainVariablesRow =
  ExportCdashDomainVariablesRow
  { exportCdashDomainVariablesRowVersion = Nothing
  , exportCdashDomainVariablesRowClass = Nothing
  , exportCdashDomainVariablesRowDomain = Nothing
  , exportCdashDomainVariablesRowVariableOrder = Nothing
  , exportCdashDomainVariablesRowCdashVariable = Nothing
  , exportCdashDomainVariablesRowCdashVariableLabel = Nothing
  , exportCdashDomainVariablesRowDraftCdashDefinition = Nothing
  , exportCdashDomainVariablesRowDomainSpecific = Nothing
  , exportCdashDomainVariablesRowQuestionText = Nothing
  , exportCdashDomainVariablesRowPrompt = Nothing
  , exportCdashDomainVariablesRowType = Nothing
  , exportCdashDomainVariablesRowSdtmTarget = Nothing
  , exportCdashDomainVariablesRowMappingInstructions = Nothing
  , exportCdashDomainVariablesRowControlledTerminologyCodelistName = Nothing
  , exportCdashDomainVariablesRowImplementationNotes = Nothing
  }

-- ** ExportCdashTable
-- | ExportCdashTable
data ExportCdashTable = ExportCdashTable
  { exportCdashTableClassVariables :: !(Maybe [ExportCdashClassVariablesRow]) -- ^ "class-variables"
  , exportCdashTableDomainVariables :: !(Maybe [ExportCdashDomainVariablesRow]) -- ^ "domain-variables"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportCdashTable
instance A.FromJSON ExportCdashTable where
  parseJSON = A.withObject "ExportCdashTable" $ \o ->
    ExportCdashTable
      <$> (o .:? "class-variables")
      <*> (o .:? "domain-variables")

-- | ToJSON ExportCdashTable
instance A.ToJSON ExportCdashTable where
  toJSON ExportCdashTable {..} =
   _omitNulls
      [ "class-variables" .= exportCdashTableClassVariables
      , "domain-variables" .= exportCdashTableDomainVariables
      ]


-- | Construct a value of type 'ExportCdashTable' (by applying it's required fields, if any)
mkExportCdashTable
  :: ExportCdashTable
mkExportCdashTable =
  ExportCdashTable
  { exportCdashTableClassVariables = Nothing
  , exportCdashTableDomainVariables = Nothing
  }

-- ** ExportCdashigDomainVariablesRow
-- | ExportCdashigDomainVariablesRow
data ExportCdashigDomainVariablesRow = ExportCdashigDomainVariablesRow
  { exportCdashigDomainVariablesRowVersion :: !(Maybe Text) -- ^ "Version"
  , exportCdashigDomainVariablesRowClass :: !(Maybe Text) -- ^ "Class"
  , exportCdashigDomainVariablesRowDomain :: !(Maybe Text) -- ^ "Domain"
  , exportCdashigDomainVariablesRowDataCollectionScenario :: !(Maybe Text) -- ^ "Data Collection Scenario"
  , exportCdashigDomainVariablesRowVariableOrder :: !(Maybe Text) -- ^ "Variable Order"
  , exportCdashigDomainVariablesRowCdashigVariable :: !(Maybe Text) -- ^ "CDASHIG Variable"
  , exportCdashigDomainVariablesRowCdashigVariableLabel :: !(Maybe Text) -- ^ "CDASHIG Variable Label"
  , exportCdashigDomainVariablesRowDraftCdashigDefinition :: !(Maybe Text) -- ^ "DRAFT CDASHIG Definition"
  , exportCdashigDomainVariablesRowQuestionText :: !(Maybe Text) -- ^ "Question Text"
  , exportCdashigDomainVariablesRowPrompt :: !(Maybe Text) -- ^ "Prompt"
  , exportCdashigDomainVariablesRowType :: !(Maybe Text) -- ^ "Type"
  , exportCdashigDomainVariablesRowCdashigCore :: !(Maybe Text) -- ^ "CDASHIG Core"
  , exportCdashigDomainVariablesRowCaseReportFormCompletionInstructions :: !(Maybe Text) -- ^ "Case Report Form Completion Instructions"
  , exportCdashigDomainVariablesRowSdtmigTarget :: !(Maybe [Text]) -- ^ "SDTMIG Target"
  , exportCdashigDomainVariablesRowMappingInstructions :: !(Maybe Text) -- ^ "Mapping Instructions"
  , exportCdashigDomainVariablesRowControlledTerminologyCodelistName :: !(Maybe Text) -- ^ "Controlled Terminology Codelist Name"
  , exportCdashigDomainVariablesRowImplementationNotes :: !(Maybe Text) -- ^ "Implementation Notes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportCdashigDomainVariablesRow
instance A.FromJSON ExportCdashigDomainVariablesRow where
  parseJSON = A.withObject "ExportCdashigDomainVariablesRow" $ \o ->
    ExportCdashigDomainVariablesRow
      <$> (o .:? "Version")
      <*> (o .:? "Class")
      <*> (o .:? "Domain")
      <*> (o .:? "Data Collection Scenario")
      <*> (o .:? "Variable Order")
      <*> (o .:? "CDASHIG Variable")
      <*> (o .:? "CDASHIG Variable Label")
      <*> (o .:? "DRAFT CDASHIG Definition")
      <*> (o .:? "Question Text")
      <*> (o .:? "Prompt")
      <*> (o .:? "Type")
      <*> (o .:? "CDASHIG Core")
      <*> (o .:? "Case Report Form Completion Instructions")
      <*> (o .:? "SDTMIG Target")
      <*> (o .:? "Mapping Instructions")
      <*> (o .:? "Controlled Terminology Codelist Name")
      <*> (o .:? "Implementation Notes")

-- | ToJSON ExportCdashigDomainVariablesRow
instance A.ToJSON ExportCdashigDomainVariablesRow where
  toJSON ExportCdashigDomainVariablesRow {..} =
   _omitNulls
      [ "Version" .= exportCdashigDomainVariablesRowVersion
      , "Class" .= exportCdashigDomainVariablesRowClass
      , "Domain" .= exportCdashigDomainVariablesRowDomain
      , "Data Collection Scenario" .= exportCdashigDomainVariablesRowDataCollectionScenario
      , "Variable Order" .= exportCdashigDomainVariablesRowVariableOrder
      , "CDASHIG Variable" .= exportCdashigDomainVariablesRowCdashigVariable
      , "CDASHIG Variable Label" .= exportCdashigDomainVariablesRowCdashigVariableLabel
      , "DRAFT CDASHIG Definition" .= exportCdashigDomainVariablesRowDraftCdashigDefinition
      , "Question Text" .= exportCdashigDomainVariablesRowQuestionText
      , "Prompt" .= exportCdashigDomainVariablesRowPrompt
      , "Type" .= exportCdashigDomainVariablesRowType
      , "CDASHIG Core" .= exportCdashigDomainVariablesRowCdashigCore
      , "Case Report Form Completion Instructions" .= exportCdashigDomainVariablesRowCaseReportFormCompletionInstructions
      , "SDTMIG Target" .= exportCdashigDomainVariablesRowSdtmigTarget
      , "Mapping Instructions" .= exportCdashigDomainVariablesRowMappingInstructions
      , "Controlled Terminology Codelist Name" .= exportCdashigDomainVariablesRowControlledTerminologyCodelistName
      , "Implementation Notes" .= exportCdashigDomainVariablesRowImplementationNotes
      ]


-- | Construct a value of type 'ExportCdashigDomainVariablesRow' (by applying it's required fields, if any)
mkExportCdashigDomainVariablesRow
  :: ExportCdashigDomainVariablesRow
mkExportCdashigDomainVariablesRow =
  ExportCdashigDomainVariablesRow
  { exportCdashigDomainVariablesRowVersion = Nothing
  , exportCdashigDomainVariablesRowClass = Nothing
  , exportCdashigDomainVariablesRowDomain = Nothing
  , exportCdashigDomainVariablesRowDataCollectionScenario = Nothing
  , exportCdashigDomainVariablesRowVariableOrder = Nothing
  , exportCdashigDomainVariablesRowCdashigVariable = Nothing
  , exportCdashigDomainVariablesRowCdashigVariableLabel = Nothing
  , exportCdashigDomainVariablesRowDraftCdashigDefinition = Nothing
  , exportCdashigDomainVariablesRowQuestionText = Nothing
  , exportCdashigDomainVariablesRowPrompt = Nothing
  , exportCdashigDomainVariablesRowType = Nothing
  , exportCdashigDomainVariablesRowCdashigCore = Nothing
  , exportCdashigDomainVariablesRowCaseReportFormCompletionInstructions = Nothing
  , exportCdashigDomainVariablesRowSdtmigTarget = Nothing
  , exportCdashigDomainVariablesRowMappingInstructions = Nothing
  , exportCdashigDomainVariablesRowControlledTerminologyCodelistName = Nothing
  , exportCdashigDomainVariablesRowImplementationNotes = Nothing
  }

-- ** ExportCdashigScenarioVariablesRow
-- | ExportCdashigScenarioVariablesRow
data ExportCdashigScenarioVariablesRow = ExportCdashigScenarioVariablesRow
  { exportCdashigScenarioVariablesRowVersion :: !(Maybe Text) -- ^ "Version"
  , exportCdashigScenarioVariablesRowClass :: !(Maybe Text) -- ^ "Class"
  , exportCdashigScenarioVariablesRowDomain :: !(Maybe Text) -- ^ "Domain"
  , exportCdashigScenarioVariablesRowDataCollectionScenario :: !(Maybe Text) -- ^ "Data Collection Scenario"
  , exportCdashigScenarioVariablesRowVariableOrder :: !(Maybe Text) -- ^ "Variable Order"
  , exportCdashigScenarioVariablesRowCdashigVariable :: !(Maybe Text) -- ^ "CDASHIG Variable"
  , exportCdashigScenarioVariablesRowCdashigVariableLabel :: !(Maybe Text) -- ^ "CDASHIG Variable Label"
  , exportCdashigScenarioVariablesRowDraftCdashigDefinition :: !(Maybe Text) -- ^ "DRAFT CDASHIG Definition"
  , exportCdashigScenarioVariablesRowQuestionText :: !(Maybe Text) -- ^ "Question Text"
  , exportCdashigScenarioVariablesRowPrompt :: !(Maybe Text) -- ^ "Prompt"
  , exportCdashigScenarioVariablesRowType :: !(Maybe Text) -- ^ "Type"
  , exportCdashigScenarioVariablesRowCdashigCore :: !(Maybe Text) -- ^ "CDASHIG Core"
  , exportCdashigScenarioVariablesRowCaseReportFormCompletionInstructions :: !(Maybe Text) -- ^ "Case Report Form Completion Instructions"
  , exportCdashigScenarioVariablesRowSdtmigTarget :: !(Maybe [Text]) -- ^ "SDTMIG Target"
  , exportCdashigScenarioVariablesRowMappingInstructions :: !(Maybe Text) -- ^ "Mapping Instructions"
  , exportCdashigScenarioVariablesRowControlledTerminologyCodelistName :: !(Maybe Text) -- ^ "Controlled Terminology Codelist Name"
  , exportCdashigScenarioVariablesRowImplementationNotes :: !(Maybe Text) -- ^ "Implementation Notes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportCdashigScenarioVariablesRow
instance A.FromJSON ExportCdashigScenarioVariablesRow where
  parseJSON = A.withObject "ExportCdashigScenarioVariablesRow" $ \o ->
    ExportCdashigScenarioVariablesRow
      <$> (o .:? "Version")
      <*> (o .:? "Class")
      <*> (o .:? "Domain")
      <*> (o .:? "Data Collection Scenario")
      <*> (o .:? "Variable Order")
      <*> (o .:? "CDASHIG Variable")
      <*> (o .:? "CDASHIG Variable Label")
      <*> (o .:? "DRAFT CDASHIG Definition")
      <*> (o .:? "Question Text")
      <*> (o .:? "Prompt")
      <*> (o .:? "Type")
      <*> (o .:? "CDASHIG Core")
      <*> (o .:? "Case Report Form Completion Instructions")
      <*> (o .:? "SDTMIG Target")
      <*> (o .:? "Mapping Instructions")
      <*> (o .:? "Controlled Terminology Codelist Name")
      <*> (o .:? "Implementation Notes")

-- | ToJSON ExportCdashigScenarioVariablesRow
instance A.ToJSON ExportCdashigScenarioVariablesRow where
  toJSON ExportCdashigScenarioVariablesRow {..} =
   _omitNulls
      [ "Version" .= exportCdashigScenarioVariablesRowVersion
      , "Class" .= exportCdashigScenarioVariablesRowClass
      , "Domain" .= exportCdashigScenarioVariablesRowDomain
      , "Data Collection Scenario" .= exportCdashigScenarioVariablesRowDataCollectionScenario
      , "Variable Order" .= exportCdashigScenarioVariablesRowVariableOrder
      , "CDASHIG Variable" .= exportCdashigScenarioVariablesRowCdashigVariable
      , "CDASHIG Variable Label" .= exportCdashigScenarioVariablesRowCdashigVariableLabel
      , "DRAFT CDASHIG Definition" .= exportCdashigScenarioVariablesRowDraftCdashigDefinition
      , "Question Text" .= exportCdashigScenarioVariablesRowQuestionText
      , "Prompt" .= exportCdashigScenarioVariablesRowPrompt
      , "Type" .= exportCdashigScenarioVariablesRowType
      , "CDASHIG Core" .= exportCdashigScenarioVariablesRowCdashigCore
      , "Case Report Form Completion Instructions" .= exportCdashigScenarioVariablesRowCaseReportFormCompletionInstructions
      , "SDTMIG Target" .= exportCdashigScenarioVariablesRowSdtmigTarget
      , "Mapping Instructions" .= exportCdashigScenarioVariablesRowMappingInstructions
      , "Controlled Terminology Codelist Name" .= exportCdashigScenarioVariablesRowControlledTerminologyCodelistName
      , "Implementation Notes" .= exportCdashigScenarioVariablesRowImplementationNotes
      ]


-- | Construct a value of type 'ExportCdashigScenarioVariablesRow' (by applying it's required fields, if any)
mkExportCdashigScenarioVariablesRow
  :: ExportCdashigScenarioVariablesRow
mkExportCdashigScenarioVariablesRow =
  ExportCdashigScenarioVariablesRow
  { exportCdashigScenarioVariablesRowVersion = Nothing
  , exportCdashigScenarioVariablesRowClass = Nothing
  , exportCdashigScenarioVariablesRowDomain = Nothing
  , exportCdashigScenarioVariablesRowDataCollectionScenario = Nothing
  , exportCdashigScenarioVariablesRowVariableOrder = Nothing
  , exportCdashigScenarioVariablesRowCdashigVariable = Nothing
  , exportCdashigScenarioVariablesRowCdashigVariableLabel = Nothing
  , exportCdashigScenarioVariablesRowDraftCdashigDefinition = Nothing
  , exportCdashigScenarioVariablesRowQuestionText = Nothing
  , exportCdashigScenarioVariablesRowPrompt = Nothing
  , exportCdashigScenarioVariablesRowType = Nothing
  , exportCdashigScenarioVariablesRowCdashigCore = Nothing
  , exportCdashigScenarioVariablesRowCaseReportFormCompletionInstructions = Nothing
  , exportCdashigScenarioVariablesRowSdtmigTarget = Nothing
  , exportCdashigScenarioVariablesRowMappingInstructions = Nothing
  , exportCdashigScenarioVariablesRowControlledTerminologyCodelistName = Nothing
  , exportCdashigScenarioVariablesRowImplementationNotes = Nothing
  }

-- ** ExportCdashigTable
-- | ExportCdashigTable
data ExportCdashigTable = ExportCdashigTable
  { exportCdashigTableDomainVariables :: !(Maybe [ExportCdashigDomainVariablesRow]) -- ^ "domain-variables"
  , exportCdashigTableScenarioVariables :: !(Maybe [ExportCdashigScenarioVariablesRow]) -- ^ "scenario-variables"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportCdashigTable
instance A.FromJSON ExportCdashigTable where
  parseJSON = A.withObject "ExportCdashigTable" $ \o ->
    ExportCdashigTable
      <$> (o .:? "domain-variables")
      <*> (o .:? "scenario-variables")

-- | ToJSON ExportCdashigTable
instance A.ToJSON ExportCdashigTable where
  toJSON ExportCdashigTable {..} =
   _omitNulls
      [ "domain-variables" .= exportCdashigTableDomainVariables
      , "scenario-variables" .= exportCdashigTableScenarioVariables
      ]


-- | Construct a value of type 'ExportCdashigTable' (by applying it's required fields, if any)
mkExportCdashigTable
  :: ExportCdashigTable
mkExportCdashigTable =
  ExportCdashigTable
  { exportCdashigTableDomainVariables = Nothing
  , exportCdashigTableScenarioVariables = Nothing
  }

-- ** ExportCtCodelist
-- | ExportCtCodelist
data ExportCtCodelist = ExportCtCodelist
  { exportCtCodelistCode :: !(Maybe Text) -- ^ "Code"
  , exportCtCodelistCodelistCode :: !(Maybe Text) -- ^ "Codelist Code"
  , exportCtCodelistCodelistExtensibleYesNo :: !(Maybe Text) -- ^ "Codelist Extensible (Yes/No)"
  , exportCtCodelistCodelistName :: !(Maybe Text) -- ^ "Codelist Name"
  , exportCtCodelistCdiscSubmissionValue :: !(Maybe Text) -- ^ "CDISC Submission Value"
  , exportCtCodelistCdiscSynonymS :: !(Maybe [Text]) -- ^ "CDISC Synonym(s)"
  , exportCtCodelistCdiscDefinition :: !(Maybe Text) -- ^ "CDISC Definition"
  , exportCtCodelistNciPreferredTerm :: !(Maybe Text) -- ^ "NCI Preferred Term"
  , exportCtCodelistStandardAndDate :: !(Maybe Text) -- ^ "Standard and Date"
  , exportCtCodelist :: !(Maybe [ExportCtTerm]) -- ^ ""
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportCtCodelist
instance A.FromJSON ExportCtCodelist where
  parseJSON = A.withObject "ExportCtCodelist" $ \o ->
    ExportCtCodelist
      <$> (o .:? "Code")
      <*> (o .:? "Codelist Code")
      <*> (o .:? "Codelist Extensible (Yes/No)")
      <*> (o .:? "Codelist Name")
      <*> (o .:? "CDISC Submission Value")
      <*> (o .:? "CDISC Synonym(s)")
      <*> (o .:? "CDISC Definition")
      <*> (o .:? "NCI Preferred Term")
      <*> (o .:? "Standard and Date")
      <*> (o .:? "")

-- | ToJSON ExportCtCodelist
instance A.ToJSON ExportCtCodelist where
  toJSON ExportCtCodelist {..} =
   _omitNulls
      [ "Code" .= exportCtCodelistCode
      , "Codelist Code" .= exportCtCodelistCodelistCode
      , "Codelist Extensible (Yes/No)" .= exportCtCodelistCodelistExtensibleYesNo
      , "Codelist Name" .= exportCtCodelistCodelistName
      , "CDISC Submission Value" .= exportCtCodelistCdiscSubmissionValue
      , "CDISC Synonym(s)" .= exportCtCodelistCdiscSynonymS
      , "CDISC Definition" .= exportCtCodelistCdiscDefinition
      , "NCI Preferred Term" .= exportCtCodelistNciPreferredTerm
      , "Standard and Date" .= exportCtCodelistStandardAndDate
      , "" .= exportCtCodelist
      ]


-- | Construct a value of type 'ExportCtCodelist' (by applying it's required fields, if any)
mkExportCtCodelist
  :: ExportCtCodelist
mkExportCtCodelist =
  ExportCtCodelist
  { exportCtCodelistCode = Nothing
  , exportCtCodelistCodelistCode = Nothing
  , exportCtCodelistCodelistExtensibleYesNo = Nothing
  , exportCtCodelistCodelistName = Nothing
  , exportCtCodelistCdiscSubmissionValue = Nothing
  , exportCtCodelistCdiscSynonymS = Nothing
  , exportCtCodelistCdiscDefinition = Nothing
  , exportCtCodelistNciPreferredTerm = Nothing
  , exportCtCodelistStandardAndDate = Nothing
  , exportCtCodelist = Nothing
  }

-- ** ExportCtTable
-- | ExportCtTable
data ExportCtTable = ExportCtTable
  { exportCtTableCt :: !(Maybe [ExportCtCodelist]) -- ^ "ct"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportCtTable
instance A.FromJSON ExportCtTable where
  parseJSON = A.withObject "ExportCtTable" $ \o ->
    ExportCtTable
      <$> (o .:? "ct")

-- | ToJSON ExportCtTable
instance A.ToJSON ExportCtTable where
  toJSON ExportCtTable {..} =
   _omitNulls
      [ "ct" .= exportCtTableCt
      ]


-- | Construct a value of type 'ExportCtTable' (by applying it's required fields, if any)
mkExportCtTable
  :: ExportCtTable
mkExportCtTable =
  ExportCtTable
  { exportCtTableCt = Nothing
  }

-- ** ExportCtTerm
-- | ExportCtTerm
data ExportCtTerm = ExportCtTerm
  { exportCtTermBundle1 :: !(Maybe Text) -- ^ "bundle-1"
  , exportCtTermCdiscSynonymS :: !(Maybe [Text]) -- ^ "CDISC Synonym(s)"
  , exportCtTermBundle2 :: !(Maybe Text) -- ^ "bundle-2"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportCtTerm
instance A.FromJSON ExportCtTerm where
  parseJSON = A.withObject "ExportCtTerm" $ \o ->
    ExportCtTerm
      <$> (o .:? "bundle-1")
      <*> (o .:? "CDISC Synonym(s)")
      <*> (o .:? "bundle-2")

-- | ToJSON ExportCtTerm
instance A.ToJSON ExportCtTerm where
  toJSON ExportCtTerm {..} =
   _omitNulls
      [ "bundle-1" .= exportCtTermBundle1
      , "CDISC Synonym(s)" .= exportCtTermCdiscSynonymS
      , "bundle-2" .= exportCtTermBundle2
      ]


-- | Construct a value of type 'ExportCtTerm' (by applying it's required fields, if any)
mkExportCtTerm
  :: ExportCtTerm
mkExportCtTerm =
  ExportCtTerm
  { exportCtTermBundle1 = Nothing
  , exportCtTermCdiscSynonymS = Nothing
  , exportCtTermBundle2 = Nothing
  }

-- ** ExportQrsCsvItemsRow
-- | ExportQrsCsvItemsRow
data ExportQrsCsvItemsRow = ExportQrsCsvItemsRow
  { exportQrsCsvItemsRowQrsMeasureName :: !(Maybe Text) -- ^ "QRS Measure Name"
  , exportQrsCsvItemsRowQrsMeasureLabel :: !(Maybe Text) -- ^ "QRS Measure Label"
  , exportQrsCsvItemsRowQrsMeasureType :: !(Maybe Text) -- ^ "QRS Measure Type"
  , exportQrsCsvItemsRowItemSequence :: !(Maybe Text) -- ^ "Item Sequence"
  , exportQrsCsvItemsRowTestName :: !(Maybe Text) -- ^ "Test Name"
  , exportQrsCsvItemsRowItemText :: !(Maybe Text) -- ^ "Item Text"
  , exportQrsCsvItemsRowTestsCodelistCCode :: !(Maybe Text) -- ^ "Test&#39;s Codelist C-Code"
  , exportQrsCsvItemsRowTestsTermCCode :: !(Maybe Text) -- ^ "Test&#39;s Term C-Code"
  , exportQrsCsvItemsRowTestCodesCodelistCCode :: !(Maybe Text) -- ^ "Test Code&#39;s Codelist C-Code"
  , exportQrsCsvItemsRowTestCodesTermCCode :: !(Maybe Text) -- ^ "Test Code&#39;s Term C-Code"
  , exportQrsCsvItemsRowSubcategorysCodelistCCode :: !(Maybe Text) -- ^ "Subcategory&#39;s Codelist C-Code"
  , exportQrsCsvItemsRowSubcategorysTermCCode :: !(Maybe Text) -- ^ "Subcategory&#39;s Term C-Code"
  , exportQrsCsvItemsRowEvaluatorsCodelistCCode :: !(Maybe Text) -- ^ "Evaluator&#39;s Codelist C-Code"
  , exportQrsCsvItemsRowEvaluatorsTermCCode :: !(Maybe Text) -- ^ "Evaluator&#39;s Term C-Code"
  , exportQrsCsvItemsRowFreeFormResponsesDatatype :: !(Maybe Text) -- ^ "Free-form Response&#39;s Datatype"
  , exportQrsCsvItemsRowResponseGroup :: !(Maybe Text) -- ^ "Response Group"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportQrsCsvItemsRow
instance A.FromJSON ExportQrsCsvItemsRow where
  parseJSON = A.withObject "ExportQrsCsvItemsRow" $ \o ->
    ExportQrsCsvItemsRow
      <$> (o .:? "QRS Measure Name")
      <*> (o .:? "QRS Measure Label")
      <*> (o .:? "QRS Measure Type")
      <*> (o .:? "Item Sequence")
      <*> (o .:? "Test Name")
      <*> (o .:? "Item Text")
      <*> (o .:? "Test&#39;s Codelist C-Code")
      <*> (o .:? "Test&#39;s Term C-Code")
      <*> (o .:? "Test Code&#39;s Codelist C-Code")
      <*> (o .:? "Test Code&#39;s Term C-Code")
      <*> (o .:? "Subcategory&#39;s Codelist C-Code")
      <*> (o .:? "Subcategory&#39;s Term C-Code")
      <*> (o .:? "Evaluator&#39;s Codelist C-Code")
      <*> (o .:? "Evaluator&#39;s Term C-Code")
      <*> (o .:? "Free-form Response&#39;s Datatype")
      <*> (o .:? "Response Group")

-- | ToJSON ExportQrsCsvItemsRow
instance A.ToJSON ExportQrsCsvItemsRow where
  toJSON ExportQrsCsvItemsRow {..} =
   _omitNulls
      [ "QRS Measure Name" .= exportQrsCsvItemsRowQrsMeasureName
      , "QRS Measure Label" .= exportQrsCsvItemsRowQrsMeasureLabel
      , "QRS Measure Type" .= exportQrsCsvItemsRowQrsMeasureType
      , "Item Sequence" .= exportQrsCsvItemsRowItemSequence
      , "Test Name" .= exportQrsCsvItemsRowTestName
      , "Item Text" .= exportQrsCsvItemsRowItemText
      , "Test&#39;s Codelist C-Code" .= exportQrsCsvItemsRowTestsCodelistCCode
      , "Test&#39;s Term C-Code" .= exportQrsCsvItemsRowTestsTermCCode
      , "Test Code&#39;s Codelist C-Code" .= exportQrsCsvItemsRowTestCodesCodelistCCode
      , "Test Code&#39;s Term C-Code" .= exportQrsCsvItemsRowTestCodesTermCCode
      , "Subcategory&#39;s Codelist C-Code" .= exportQrsCsvItemsRowSubcategorysCodelistCCode
      , "Subcategory&#39;s Term C-Code" .= exportQrsCsvItemsRowSubcategorysTermCCode
      , "Evaluator&#39;s Codelist C-Code" .= exportQrsCsvItemsRowEvaluatorsCodelistCCode
      , "Evaluator&#39;s Term C-Code" .= exportQrsCsvItemsRowEvaluatorsTermCCode
      , "Free-form Response&#39;s Datatype" .= exportQrsCsvItemsRowFreeFormResponsesDatatype
      , "Response Group" .= exportQrsCsvItemsRowResponseGroup
      ]


-- | Construct a value of type 'ExportQrsCsvItemsRow' (by applying it's required fields, if any)
mkExportQrsCsvItemsRow
  :: ExportQrsCsvItemsRow
mkExportQrsCsvItemsRow =
  ExportQrsCsvItemsRow
  { exportQrsCsvItemsRowQrsMeasureName = Nothing
  , exportQrsCsvItemsRowQrsMeasureLabel = Nothing
  , exportQrsCsvItemsRowQrsMeasureType = Nothing
  , exportQrsCsvItemsRowItemSequence = Nothing
  , exportQrsCsvItemsRowTestName = Nothing
  , exportQrsCsvItemsRowItemText = Nothing
  , exportQrsCsvItemsRowTestsCodelistCCode = Nothing
  , exportQrsCsvItemsRowTestsTermCCode = Nothing
  , exportQrsCsvItemsRowTestCodesCodelistCCode = Nothing
  , exportQrsCsvItemsRowTestCodesTermCCode = Nothing
  , exportQrsCsvItemsRowSubcategorysCodelistCCode = Nothing
  , exportQrsCsvItemsRowSubcategorysTermCCode = Nothing
  , exportQrsCsvItemsRowEvaluatorsCodelistCCode = Nothing
  , exportQrsCsvItemsRowEvaluatorsTermCCode = Nothing
  , exportQrsCsvItemsRowFreeFormResponsesDatatype = Nothing
  , exportQrsCsvItemsRowResponseGroup = Nothing
  }

-- ** ExportQrsGeneral
-- | ExportQrsGeneral
data ExportQrsGeneral = ExportQrsGeneral
  { exportQrsGeneralName :: !(Maybe Text) -- ^ "Name"
  , exportQrsGeneralLabel :: !(Maybe Text) -- ^ "Label"
  , exportQrsGeneralEffectiveDate :: !(Maybe Text) -- ^ "Effective Date"
  , exportQrsGeneralDescription :: !(Maybe Text) -- ^ "Description"
  , exportQrsGeneralType :: !(Maybe Text) -- ^ "Type"
  , exportQrsGeneralCategorysCodelistCCode :: !(Maybe Text) -- ^ "Category&#39;s Codelist C-Code"
  , exportQrsGeneralCategorysTermCCode :: !(Maybe Text) -- ^ "Category&#39;s Term C-Code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportQrsGeneral
instance A.FromJSON ExportQrsGeneral where
  parseJSON = A.withObject "ExportQrsGeneral" $ \o ->
    ExportQrsGeneral
      <$> (o .:? "Name")
      <*> (o .:? "Label")
      <*> (o .:? "Effective Date")
      <*> (o .:? "Description")
      <*> (o .:? "Type")
      <*> (o .:? "Category&#39;s Codelist C-Code")
      <*> (o .:? "Category&#39;s Term C-Code")

-- | ToJSON ExportQrsGeneral
instance A.ToJSON ExportQrsGeneral where
  toJSON ExportQrsGeneral {..} =
   _omitNulls
      [ "Name" .= exportQrsGeneralName
      , "Label" .= exportQrsGeneralLabel
      , "Effective Date" .= exportQrsGeneralEffectiveDate
      , "Description" .= exportQrsGeneralDescription
      , "Type" .= exportQrsGeneralType
      , "Category&#39;s Codelist C-Code" .= exportQrsGeneralCategorysCodelistCCode
      , "Category&#39;s Term C-Code" .= exportQrsGeneralCategorysTermCCode
      ]


-- | Construct a value of type 'ExportQrsGeneral' (by applying it's required fields, if any)
mkExportQrsGeneral
  :: ExportQrsGeneral
mkExportQrsGeneral =
  ExportQrsGeneral
  { exportQrsGeneralName = Nothing
  , exportQrsGeneralLabel = Nothing
  , exportQrsGeneralEffectiveDate = Nothing
  , exportQrsGeneralDescription = Nothing
  , exportQrsGeneralType = Nothing
  , exportQrsGeneralCategorysCodelistCCode = Nothing
  , exportQrsGeneralCategorysTermCCode = Nothing
  }

-- ** ExportQrsItemsTable
-- | ExportQrsItemsTable
data ExportQrsItemsTable = ExportQrsItemsTable
  { exportQrsItemsTableItems :: !(Maybe [ExportQrsCsvItemsRow]) -- ^ "items"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportQrsItemsTable
instance A.FromJSON ExportQrsItemsTable where
  parseJSON = A.withObject "ExportQrsItemsTable" $ \o ->
    ExportQrsItemsTable
      <$> (o .:? "items")

-- | ToJSON ExportQrsItemsTable
instance A.ToJSON ExportQrsItemsTable where
  toJSON ExportQrsItemsTable {..} =
   _omitNulls
      [ "items" .= exportQrsItemsTableItems
      ]


-- | Construct a value of type 'ExportQrsItemsTable' (by applying it's required fields, if any)
mkExportQrsItemsTable
  :: ExportQrsItemsTable
mkExportQrsItemsTable =
  ExportQrsItemsTable
  { exportQrsItemsTableItems = Nothing
  }

-- ** ExportQrsResponses
-- | ExportQrsResponses
data ExportQrsResponses = ExportQrsResponses
  { exportQrsResponsesResponseGroup :: !(Maybe Text) -- ^ "Response Group"
  , exportQrsResponsesSequence :: !(Maybe Text) -- ^ "Sequence"
  , exportQrsResponsesResponsesOriginalResultCodelistCCode :: !(Maybe Text) -- ^ "Response&#39;s Original Result Codelist C-Code"
  , exportQrsResponsesResponsesOriginalResultTermCCode :: !(Maybe Text) -- ^ "Response&#39;s Original Result Term C-Code"
  , exportQrsResponsesResponsesOriginalResultUnitCodelistCCode :: !(Maybe Text) -- ^ "Response&#39;s Original Result Unit Codelist C-Code"
  , exportQrsResponsesResponsesOriginalResultUnitTermCCode :: !(Maybe Text) -- ^ "Response&#39;s Original Result Unit Term C-Code"
  , exportQrsResponsesResponsesStandardizedResultCodelistCCode :: !(Maybe Text) -- ^ "Response&#39;s Standardized Result Codelist C-Code"
  , exportQrsResponsesResponsesStandardizedResultTermCCode :: !(Maybe Text) -- ^ "Response&#39;s Standardized Result Term C-Code"
  , exportQrsResponsesResponsesStandardizedResultUnitCodelistCCode :: !(Maybe Text) -- ^ "Response&#39;s Standardized Result Unit Codelist C-Code"
  , exportQrsResponsesResponsesStandardizedResultUnitTermCCode :: !(Maybe Text) -- ^ "Response&#39;s Standardized Result Unit Term C-Code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportQrsResponses
instance A.FromJSON ExportQrsResponses where
  parseJSON = A.withObject "ExportQrsResponses" $ \o ->
    ExportQrsResponses
      <$> (o .:? "Response Group")
      <*> (o .:? "Sequence")
      <*> (o .:? "Response&#39;s Original Result Codelist C-Code")
      <*> (o .:? "Response&#39;s Original Result Term C-Code")
      <*> (o .:? "Response&#39;s Original Result Unit Codelist C-Code")
      <*> (o .:? "Response&#39;s Original Result Unit Term C-Code")
      <*> (o .:? "Response&#39;s Standardized Result Codelist C-Code")
      <*> (o .:? "Response&#39;s Standardized Result Term C-Code")
      <*> (o .:? "Response&#39;s Standardized Result Unit Codelist C-Code")
      <*> (o .:? "Response&#39;s Standardized Result Unit Term C-Code")

-- | ToJSON ExportQrsResponses
instance A.ToJSON ExportQrsResponses where
  toJSON ExportQrsResponses {..} =
   _omitNulls
      [ "Response Group" .= exportQrsResponsesResponseGroup
      , "Sequence" .= exportQrsResponsesSequence
      , "Response&#39;s Original Result Codelist C-Code" .= exportQrsResponsesResponsesOriginalResultCodelistCCode
      , "Response&#39;s Original Result Term C-Code" .= exportQrsResponsesResponsesOriginalResultTermCCode
      , "Response&#39;s Original Result Unit Codelist C-Code" .= exportQrsResponsesResponsesOriginalResultUnitCodelistCCode
      , "Response&#39;s Original Result Unit Term C-Code" .= exportQrsResponsesResponsesOriginalResultUnitTermCCode
      , "Response&#39;s Standardized Result Codelist C-Code" .= exportQrsResponsesResponsesStandardizedResultCodelistCCode
      , "Response&#39;s Standardized Result Term C-Code" .= exportQrsResponsesResponsesStandardizedResultTermCCode
      , "Response&#39;s Standardized Result Unit Codelist C-Code" .= exportQrsResponsesResponsesStandardizedResultUnitCodelistCCode
      , "Response&#39;s Standardized Result Unit Term C-Code" .= exportQrsResponsesResponsesStandardizedResultUnitTermCCode
      ]


-- | Construct a value of type 'ExportQrsResponses' (by applying it's required fields, if any)
mkExportQrsResponses
  :: ExportQrsResponses
mkExportQrsResponses =
  ExportQrsResponses
  { exportQrsResponsesResponseGroup = Nothing
  , exportQrsResponsesSequence = Nothing
  , exportQrsResponsesResponsesOriginalResultCodelistCCode = Nothing
  , exportQrsResponsesResponsesOriginalResultTermCCode = Nothing
  , exportQrsResponsesResponsesOriginalResultUnitCodelistCCode = Nothing
  , exportQrsResponsesResponsesOriginalResultUnitTermCCode = Nothing
  , exportQrsResponsesResponsesStandardizedResultCodelistCCode = Nothing
  , exportQrsResponsesResponsesStandardizedResultTermCCode = Nothing
  , exportQrsResponsesResponsesStandardizedResultUnitCodelistCCode = Nothing
  , exportQrsResponsesResponsesStandardizedResultUnitTermCCode = Nothing
  }

-- ** ExportQrsWorkbook
-- | ExportQrsWorkbook
data ExportQrsWorkbook = ExportQrsWorkbook
  { exportQrsWorkbookSelf :: !(Maybe ExportQrsGeneral) -- ^ "self"
  , exportQrsWorkbookItems :: !(Maybe [ExportQrsWorkbookItemsRow]) -- ^ "items"
  , exportQrsWorkbookResponses :: !(Maybe [ExportQrsResponses]) -- ^ "responses"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportQrsWorkbook
instance A.FromJSON ExportQrsWorkbook where
  parseJSON = A.withObject "ExportQrsWorkbook" $ \o ->
    ExportQrsWorkbook
      <$> (o .:? "self")
      <*> (o .:? "items")
      <*> (o .:? "responses")

-- | ToJSON ExportQrsWorkbook
instance A.ToJSON ExportQrsWorkbook where
  toJSON ExportQrsWorkbook {..} =
   _omitNulls
      [ "self" .= exportQrsWorkbookSelf
      , "items" .= exportQrsWorkbookItems
      , "responses" .= exportQrsWorkbookResponses
      ]


-- | Construct a value of type 'ExportQrsWorkbook' (by applying it's required fields, if any)
mkExportQrsWorkbook
  :: ExportQrsWorkbook
mkExportQrsWorkbook =
  ExportQrsWorkbook
  { exportQrsWorkbookSelf = Nothing
  , exportQrsWorkbookItems = Nothing
  , exportQrsWorkbookResponses = Nothing
  }

-- ** ExportQrsWorkbookItemsRow
-- | ExportQrsWorkbookItemsRow
data ExportQrsWorkbookItemsRow = ExportQrsWorkbookItemsRow
  { exportQrsWorkbookItemsRowItemSequence :: !(Maybe Text) -- ^ "Item Sequence"
  , exportQrsWorkbookItemsRowTestName :: !(Maybe Text) -- ^ "Test Name"
  , exportQrsWorkbookItemsRowItemText :: !(Maybe Text) -- ^ "Item Text"
  , exportQrsWorkbookItemsRowTestsCodelistCCode :: !(Maybe Text) -- ^ "Test&#39;s Codelist C-Code"
  , exportQrsWorkbookItemsRowTestsTermCCode :: !(Maybe Text) -- ^ "Test&#39;s Term C-Code"
  , exportQrsWorkbookItemsRowTestCodesCodelistCCode :: !(Maybe Text) -- ^ "Test Code&#39;s Codelist C-Code"
  , exportQrsWorkbookItemsRowTestCodesTermCCode :: !(Maybe Text) -- ^ "Test Code&#39;s Term C-Code"
  , exportQrsWorkbookItemsRowSubcategorysCodelistCCode :: !(Maybe Text) -- ^ "Subcategory&#39;s Codelist C-Code"
  , exportQrsWorkbookItemsRowSubcategorysTermCCode :: !(Maybe Text) -- ^ "Subcategory&#39;s Term C-Code"
  , exportQrsWorkbookItemsRowEvaluatorsCodelistCCode :: !(Maybe Text) -- ^ "Evaluator&#39;s Codelist C-Code"
  , exportQrsWorkbookItemsRowEvaluatorsTermCCode :: !(Maybe Text) -- ^ "Evaluator&#39;s Term C-Code"
  , exportQrsWorkbookItemsRowFreeFormResponsesDatatype :: !(Maybe Text) -- ^ "Free-form Response&#39;s Datatype"
  , exportQrsWorkbookItemsRowResponseGroup :: !(Maybe Text) -- ^ "Response Group"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportQrsWorkbookItemsRow
instance A.FromJSON ExportQrsWorkbookItemsRow where
  parseJSON = A.withObject "ExportQrsWorkbookItemsRow" $ \o ->
    ExportQrsWorkbookItemsRow
      <$> (o .:? "Item Sequence")
      <*> (o .:? "Test Name")
      <*> (o .:? "Item Text")
      <*> (o .:? "Test&#39;s Codelist C-Code")
      <*> (o .:? "Test&#39;s Term C-Code")
      <*> (o .:? "Test Code&#39;s Codelist C-Code")
      <*> (o .:? "Test Code&#39;s Term C-Code")
      <*> (o .:? "Subcategory&#39;s Codelist C-Code")
      <*> (o .:? "Subcategory&#39;s Term C-Code")
      <*> (o .:? "Evaluator&#39;s Codelist C-Code")
      <*> (o .:? "Evaluator&#39;s Term C-Code")
      <*> (o .:? "Free-form Response&#39;s Datatype")
      <*> (o .:? "Response Group")

-- | ToJSON ExportQrsWorkbookItemsRow
instance A.ToJSON ExportQrsWorkbookItemsRow where
  toJSON ExportQrsWorkbookItemsRow {..} =
   _omitNulls
      [ "Item Sequence" .= exportQrsWorkbookItemsRowItemSequence
      , "Test Name" .= exportQrsWorkbookItemsRowTestName
      , "Item Text" .= exportQrsWorkbookItemsRowItemText
      , "Test&#39;s Codelist C-Code" .= exportQrsWorkbookItemsRowTestsCodelistCCode
      , "Test&#39;s Term C-Code" .= exportQrsWorkbookItemsRowTestsTermCCode
      , "Test Code&#39;s Codelist C-Code" .= exportQrsWorkbookItemsRowTestCodesCodelistCCode
      , "Test Code&#39;s Term C-Code" .= exportQrsWorkbookItemsRowTestCodesTermCCode
      , "Subcategory&#39;s Codelist C-Code" .= exportQrsWorkbookItemsRowSubcategorysCodelistCCode
      , "Subcategory&#39;s Term C-Code" .= exportQrsWorkbookItemsRowSubcategorysTermCCode
      , "Evaluator&#39;s Codelist C-Code" .= exportQrsWorkbookItemsRowEvaluatorsCodelistCCode
      , "Evaluator&#39;s Term C-Code" .= exportQrsWorkbookItemsRowEvaluatorsTermCCode
      , "Free-form Response&#39;s Datatype" .= exportQrsWorkbookItemsRowFreeFormResponsesDatatype
      , "Response Group" .= exportQrsWorkbookItemsRowResponseGroup
      ]


-- | Construct a value of type 'ExportQrsWorkbookItemsRow' (by applying it's required fields, if any)
mkExportQrsWorkbookItemsRow
  :: ExportQrsWorkbookItemsRow
mkExportQrsWorkbookItemsRow =
  ExportQrsWorkbookItemsRow
  { exportQrsWorkbookItemsRowItemSequence = Nothing
  , exportQrsWorkbookItemsRowTestName = Nothing
  , exportQrsWorkbookItemsRowItemText = Nothing
  , exportQrsWorkbookItemsRowTestsCodelistCCode = Nothing
  , exportQrsWorkbookItemsRowTestsTermCCode = Nothing
  , exportQrsWorkbookItemsRowTestCodesCodelistCCode = Nothing
  , exportQrsWorkbookItemsRowTestCodesTermCCode = Nothing
  , exportQrsWorkbookItemsRowSubcategorysCodelistCCode = Nothing
  , exportQrsWorkbookItemsRowSubcategorysTermCCode = Nothing
  , exportQrsWorkbookItemsRowEvaluatorsCodelistCCode = Nothing
  , exportQrsWorkbookItemsRowEvaluatorsTermCCode = Nothing
  , exportQrsWorkbookItemsRowFreeFormResponsesDatatype = Nothing
  , exportQrsWorkbookItemsRowResponseGroup = Nothing
  }

-- ** ExportSdtmClassVariablesRow
-- | ExportSdtmClassVariablesRow
data ExportSdtmClassVariablesRow = ExportSdtmClassVariablesRow
  { exportSdtmClassVariablesRowVersion :: !(Maybe Text) -- ^ "Version"
  , exportSdtmClassVariablesRowVariableOrder :: !(Maybe Text) -- ^ "Variable Order"
  , exportSdtmClassVariablesRowClass :: !(Maybe Text) -- ^ "Class"
  , exportSdtmClassVariablesRowDatasetName :: !(Maybe Text) -- ^ "Dataset Name"
  , exportSdtmClassVariablesRowVariableName :: !(Maybe Text) -- ^ "Variable Name"
  , exportSdtmClassVariablesRowVariableLabel :: !(Maybe Text) -- ^ "Variable Label"
  , exportSdtmClassVariablesRowType :: !(Maybe Text) -- ^ "Type"
  , exportSdtmClassVariablesRowControlledTermsCodelistOrFormat :: !(Maybe Text) -- ^ "Controlled Terms, Codelist or Format"
  , exportSdtmClassVariablesRowRole :: !(Maybe Text) -- ^ "Role"
  , exportSdtmClassVariablesRowRoleDescription :: !(Maybe Text) -- ^ "Role Description"
  , exportSdtmClassVariablesRowDescription :: !(Maybe Text) -- ^ "Description"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSdtmClassVariablesRow
instance A.FromJSON ExportSdtmClassVariablesRow where
  parseJSON = A.withObject "ExportSdtmClassVariablesRow" $ \o ->
    ExportSdtmClassVariablesRow
      <$> (o .:? "Version")
      <*> (o .:? "Variable Order")
      <*> (o .:? "Class")
      <*> (o .:? "Dataset Name")
      <*> (o .:? "Variable Name")
      <*> (o .:? "Variable Label")
      <*> (o .:? "Type")
      <*> (o .:? "Controlled Terms, Codelist or Format")
      <*> (o .:? "Role")
      <*> (o .:? "Role Description")
      <*> (o .:? "Description")

-- | ToJSON ExportSdtmClassVariablesRow
instance A.ToJSON ExportSdtmClassVariablesRow where
  toJSON ExportSdtmClassVariablesRow {..} =
   _omitNulls
      [ "Version" .= exportSdtmClassVariablesRowVersion
      , "Variable Order" .= exportSdtmClassVariablesRowVariableOrder
      , "Class" .= exportSdtmClassVariablesRowClass
      , "Dataset Name" .= exportSdtmClassVariablesRowDatasetName
      , "Variable Name" .= exportSdtmClassVariablesRowVariableName
      , "Variable Label" .= exportSdtmClassVariablesRowVariableLabel
      , "Type" .= exportSdtmClassVariablesRowType
      , "Controlled Terms, Codelist or Format" .= exportSdtmClassVariablesRowControlledTermsCodelistOrFormat
      , "Role" .= exportSdtmClassVariablesRowRole
      , "Role Description" .= exportSdtmClassVariablesRowRoleDescription
      , "Description" .= exportSdtmClassVariablesRowDescription
      ]


-- | Construct a value of type 'ExportSdtmClassVariablesRow' (by applying it's required fields, if any)
mkExportSdtmClassVariablesRow
  :: ExportSdtmClassVariablesRow
mkExportSdtmClassVariablesRow =
  ExportSdtmClassVariablesRow
  { exportSdtmClassVariablesRowVersion = Nothing
  , exportSdtmClassVariablesRowVariableOrder = Nothing
  , exportSdtmClassVariablesRowClass = Nothing
  , exportSdtmClassVariablesRowDatasetName = Nothing
  , exportSdtmClassVariablesRowVariableName = Nothing
  , exportSdtmClassVariablesRowVariableLabel = Nothing
  , exportSdtmClassVariablesRowType = Nothing
  , exportSdtmClassVariablesRowControlledTermsCodelistOrFormat = Nothing
  , exportSdtmClassVariablesRowRole = Nothing
  , exportSdtmClassVariablesRowRoleDescription = Nothing
  , exportSdtmClassVariablesRowDescription = Nothing
  }

-- ** ExportSdtmDatasetVariablesRow
-- | ExportSdtmDatasetVariablesRow
data ExportSdtmDatasetVariablesRow = ExportSdtmDatasetVariablesRow
  { exportSdtmDatasetVariablesRowVersion :: !(Maybe Text) -- ^ "Version"
  , exportSdtmDatasetVariablesRowVariableOrder :: !(Maybe Text) -- ^ "Variable Order"
  , exportSdtmDatasetVariablesRowClass :: !(Maybe Text) -- ^ "Class"
  , exportSdtmDatasetVariablesRowDatasetName :: !(Maybe Text) -- ^ "Dataset Name"
  , exportSdtmDatasetVariablesRowVariableName :: !(Maybe Text) -- ^ "Variable Name"
  , exportSdtmDatasetVariablesRowVariableLabel :: !(Maybe Text) -- ^ "Variable Label"
  , exportSdtmDatasetVariablesRowType :: !(Maybe Text) -- ^ "Type"
  , exportSdtmDatasetVariablesRowControlledTermsCodelistOrFormat :: !(Maybe Text) -- ^ "Controlled Terms, Codelist or Format"
  , exportSdtmDatasetVariablesRowRole :: !(Maybe Text) -- ^ "Role"
  , exportSdtmDatasetVariablesRowRoleDescription :: !(Maybe Text) -- ^ "Role Description"
  , exportSdtmDatasetVariablesRowDescription :: !(Maybe Text) -- ^ "Description"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSdtmDatasetVariablesRow
instance A.FromJSON ExportSdtmDatasetVariablesRow where
  parseJSON = A.withObject "ExportSdtmDatasetVariablesRow" $ \o ->
    ExportSdtmDatasetVariablesRow
      <$> (o .:? "Version")
      <*> (o .:? "Variable Order")
      <*> (o .:? "Class")
      <*> (o .:? "Dataset Name")
      <*> (o .:? "Variable Name")
      <*> (o .:? "Variable Label")
      <*> (o .:? "Type")
      <*> (o .:? "Controlled Terms, Codelist or Format")
      <*> (o .:? "Role")
      <*> (o .:? "Role Description")
      <*> (o .:? "Description")

-- | ToJSON ExportSdtmDatasetVariablesRow
instance A.ToJSON ExportSdtmDatasetVariablesRow where
  toJSON ExportSdtmDatasetVariablesRow {..} =
   _omitNulls
      [ "Version" .= exportSdtmDatasetVariablesRowVersion
      , "Variable Order" .= exportSdtmDatasetVariablesRowVariableOrder
      , "Class" .= exportSdtmDatasetVariablesRowClass
      , "Dataset Name" .= exportSdtmDatasetVariablesRowDatasetName
      , "Variable Name" .= exportSdtmDatasetVariablesRowVariableName
      , "Variable Label" .= exportSdtmDatasetVariablesRowVariableLabel
      , "Type" .= exportSdtmDatasetVariablesRowType
      , "Controlled Terms, Codelist or Format" .= exportSdtmDatasetVariablesRowControlledTermsCodelistOrFormat
      , "Role" .= exportSdtmDatasetVariablesRowRole
      , "Role Description" .= exportSdtmDatasetVariablesRowRoleDescription
      , "Description" .= exportSdtmDatasetVariablesRowDescription
      ]


-- | Construct a value of type 'ExportSdtmDatasetVariablesRow' (by applying it's required fields, if any)
mkExportSdtmDatasetVariablesRow
  :: ExportSdtmDatasetVariablesRow
mkExportSdtmDatasetVariablesRow =
  ExportSdtmDatasetVariablesRow
  { exportSdtmDatasetVariablesRowVersion = Nothing
  , exportSdtmDatasetVariablesRowVariableOrder = Nothing
  , exportSdtmDatasetVariablesRowClass = Nothing
  , exportSdtmDatasetVariablesRowDatasetName = Nothing
  , exportSdtmDatasetVariablesRowVariableName = Nothing
  , exportSdtmDatasetVariablesRowVariableLabel = Nothing
  , exportSdtmDatasetVariablesRowType = Nothing
  , exportSdtmDatasetVariablesRowControlledTermsCodelistOrFormat = Nothing
  , exportSdtmDatasetVariablesRowRole = Nothing
  , exportSdtmDatasetVariablesRowRoleDescription = Nothing
  , exportSdtmDatasetVariablesRowDescription = Nothing
  }

-- ** ExportSdtmDatasetsRow
-- | ExportSdtmDatasetsRow
data ExportSdtmDatasetsRow = ExportSdtmDatasetsRow
  { exportSdtmDatasetsRowVersion :: !(Maybe Text) -- ^ "Version"
  , exportSdtmDatasetsRowClass :: !(Maybe Text) -- ^ "Class"
  , exportSdtmDatasetsRowDatasetName :: !(Maybe Text) -- ^ "Dataset Name"
  , exportSdtmDatasetsRowDatasetLabel :: !(Maybe Text) -- ^ "Dataset Label"
  , exportSdtmDatasetsRowStructure :: !(Maybe Text) -- ^ "Structure"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSdtmDatasetsRow
instance A.FromJSON ExportSdtmDatasetsRow where
  parseJSON = A.withObject "ExportSdtmDatasetsRow" $ \o ->
    ExportSdtmDatasetsRow
      <$> (o .:? "Version")
      <*> (o .:? "Class")
      <*> (o .:? "Dataset Name")
      <*> (o .:? "Dataset Label")
      <*> (o .:? "Structure")

-- | ToJSON ExportSdtmDatasetsRow
instance A.ToJSON ExportSdtmDatasetsRow where
  toJSON ExportSdtmDatasetsRow {..} =
   _omitNulls
      [ "Version" .= exportSdtmDatasetsRowVersion
      , "Class" .= exportSdtmDatasetsRowClass
      , "Dataset Name" .= exportSdtmDatasetsRowDatasetName
      , "Dataset Label" .= exportSdtmDatasetsRowDatasetLabel
      , "Structure" .= exportSdtmDatasetsRowStructure
      ]


-- | Construct a value of type 'ExportSdtmDatasetsRow' (by applying it's required fields, if any)
mkExportSdtmDatasetsRow
  :: ExportSdtmDatasetsRow
mkExportSdtmDatasetsRow =
  ExportSdtmDatasetsRow
  { exportSdtmDatasetsRowVersion = Nothing
  , exportSdtmDatasetsRowClass = Nothing
  , exportSdtmDatasetsRowDatasetName = Nothing
  , exportSdtmDatasetsRowDatasetLabel = Nothing
  , exportSdtmDatasetsRowStructure = Nothing
  }

-- ** ExportSdtmDatasetsTable
-- | ExportSdtmDatasetsTable
data ExportSdtmDatasetsTable = ExportSdtmDatasetsTable
  { exportSdtmDatasetsTableDatasets :: !(Maybe [ExportSdtmDatasetsRow]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSdtmDatasetsTable
instance A.FromJSON ExportSdtmDatasetsTable where
  parseJSON = A.withObject "ExportSdtmDatasetsTable" $ \o ->
    ExportSdtmDatasetsTable
      <$> (o .:? "datasets")

-- | ToJSON ExportSdtmDatasetsTable
instance A.ToJSON ExportSdtmDatasetsTable where
  toJSON ExportSdtmDatasetsTable {..} =
   _omitNulls
      [ "datasets" .= exportSdtmDatasetsTableDatasets
      ]


-- | Construct a value of type 'ExportSdtmDatasetsTable' (by applying it's required fields, if any)
mkExportSdtmDatasetsTable
  :: ExportSdtmDatasetsTable
mkExportSdtmDatasetsTable =
  ExportSdtmDatasetsTable
  { exportSdtmDatasetsTableDatasets = Nothing
  }

-- ** ExportSdtmVariablesTable
-- | ExportSdtmVariablesTable
data ExportSdtmVariablesTable = ExportSdtmVariablesTable
  { exportSdtmVariablesTableClassVariables :: !(Maybe [ExportSdtmClassVariablesRow]) -- ^ "class-variables"
  , exportSdtmVariablesTableDatasetVariables :: !(Maybe [ExportSdtmDatasetVariablesRow]) -- ^ "dataset-variables"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSdtmVariablesTable
instance A.FromJSON ExportSdtmVariablesTable where
  parseJSON = A.withObject "ExportSdtmVariablesTable" $ \o ->
    ExportSdtmVariablesTable
      <$> (o .:? "class-variables")
      <*> (o .:? "dataset-variables")

-- | ToJSON ExportSdtmVariablesTable
instance A.ToJSON ExportSdtmVariablesTable where
  toJSON ExportSdtmVariablesTable {..} =
   _omitNulls
      [ "class-variables" .= exportSdtmVariablesTableClassVariables
      , "dataset-variables" .= exportSdtmVariablesTableDatasetVariables
      ]


-- | Construct a value of type 'ExportSdtmVariablesTable' (by applying it's required fields, if any)
mkExportSdtmVariablesTable
  :: ExportSdtmVariablesTable
mkExportSdtmVariablesTable =
  ExportSdtmVariablesTable
  { exportSdtmVariablesTableClassVariables = Nothing
  , exportSdtmVariablesTableDatasetVariables = Nothing
  }

-- ** ExportSdtmWorkbook
-- | ExportSdtmWorkbook
data ExportSdtmWorkbook = ExportSdtmWorkbook
  { exportSdtmWorkbookClassVariables :: !(Maybe [ExportSdtmClassVariablesRow]) -- ^ "class-variables"
  , exportSdtmWorkbookDatasetVariables :: !(Maybe [ExportSdtmDatasetVariablesRow]) -- ^ "dataset-variables"
  , exportSdtmWorkbookDatasets :: !(Maybe [ExportSdtmDatasetsRow]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSdtmWorkbook
instance A.FromJSON ExportSdtmWorkbook where
  parseJSON = A.withObject "ExportSdtmWorkbook" $ \o ->
    ExportSdtmWorkbook
      <$> (o .:? "class-variables")
      <*> (o .:? "dataset-variables")
      <*> (o .:? "datasets")

-- | ToJSON ExportSdtmWorkbook
instance A.ToJSON ExportSdtmWorkbook where
  toJSON ExportSdtmWorkbook {..} =
   _omitNulls
      [ "class-variables" .= exportSdtmWorkbookClassVariables
      , "dataset-variables" .= exportSdtmWorkbookDatasetVariables
      , "datasets" .= exportSdtmWorkbookDatasets
      ]


-- | Construct a value of type 'ExportSdtmWorkbook' (by applying it's required fields, if any)
mkExportSdtmWorkbook
  :: ExportSdtmWorkbook
mkExportSdtmWorkbook =
  ExportSdtmWorkbook
  { exportSdtmWorkbookClassVariables = Nothing
  , exportSdtmWorkbookDatasetVariables = Nothing
  , exportSdtmWorkbookDatasets = Nothing
  }

-- ** ExportSdtmigDatasetsRow
-- | ExportSdtmigDatasetsRow
data ExportSdtmigDatasetsRow = ExportSdtmigDatasetsRow
  { exportSdtmigDatasetsRowVersion :: !(Maybe Text) -- ^ "Version"
  , exportSdtmigDatasetsRowClass :: !(Maybe Text) -- ^ "Class"
  , exportSdtmigDatasetsRowDatasetName :: !(Maybe Text) -- ^ "Dataset Name"
  , exportSdtmigDatasetsRowDatasetLabel :: !(Maybe Text) -- ^ "Dataset Label"
  , exportSdtmigDatasetsRowStructure :: !(Maybe Text) -- ^ "Structure"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSdtmigDatasetsRow
instance A.FromJSON ExportSdtmigDatasetsRow where
  parseJSON = A.withObject "ExportSdtmigDatasetsRow" $ \o ->
    ExportSdtmigDatasetsRow
      <$> (o .:? "Version")
      <*> (o .:? "Class")
      <*> (o .:? "Dataset Name")
      <*> (o .:? "Dataset Label")
      <*> (o .:? "Structure")

-- | ToJSON ExportSdtmigDatasetsRow
instance A.ToJSON ExportSdtmigDatasetsRow where
  toJSON ExportSdtmigDatasetsRow {..} =
   _omitNulls
      [ "Version" .= exportSdtmigDatasetsRowVersion
      , "Class" .= exportSdtmigDatasetsRowClass
      , "Dataset Name" .= exportSdtmigDatasetsRowDatasetName
      , "Dataset Label" .= exportSdtmigDatasetsRowDatasetLabel
      , "Structure" .= exportSdtmigDatasetsRowStructure
      ]


-- | Construct a value of type 'ExportSdtmigDatasetsRow' (by applying it's required fields, if any)
mkExportSdtmigDatasetsRow
  :: ExportSdtmigDatasetsRow
mkExportSdtmigDatasetsRow =
  ExportSdtmigDatasetsRow
  { exportSdtmigDatasetsRowVersion = Nothing
  , exportSdtmigDatasetsRowClass = Nothing
  , exportSdtmigDatasetsRowDatasetName = Nothing
  , exportSdtmigDatasetsRowDatasetLabel = Nothing
  , exportSdtmigDatasetsRowStructure = Nothing
  }

-- ** ExportSdtmigDatasetsTable
-- | ExportSdtmigDatasetsTable
data ExportSdtmigDatasetsTable = ExportSdtmigDatasetsTable
  { exportSdtmigDatasetsTableDatasets :: !(Maybe [ExportSdtmigDatasetsRow]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSdtmigDatasetsTable
instance A.FromJSON ExportSdtmigDatasetsTable where
  parseJSON = A.withObject "ExportSdtmigDatasetsTable" $ \o ->
    ExportSdtmigDatasetsTable
      <$> (o .:? "datasets")

-- | ToJSON ExportSdtmigDatasetsTable
instance A.ToJSON ExportSdtmigDatasetsTable where
  toJSON ExportSdtmigDatasetsTable {..} =
   _omitNulls
      [ "datasets" .= exportSdtmigDatasetsTableDatasets
      ]


-- | Construct a value of type 'ExportSdtmigDatasetsTable' (by applying it's required fields, if any)
mkExportSdtmigDatasetsTable
  :: ExportSdtmigDatasetsTable
mkExportSdtmigDatasetsTable =
  ExportSdtmigDatasetsTable
  { exportSdtmigDatasetsTableDatasets = Nothing
  }

-- ** ExportSdtmigVariablesRow
-- | ExportSdtmigVariablesRow
data ExportSdtmigVariablesRow = ExportSdtmigVariablesRow
  { exportSdtmigVariablesRowVersion :: !(Maybe Text) -- ^ "Version"
  , exportSdtmigVariablesRowVariableOrder :: !(Maybe Text) -- ^ "Variable Order"
  , exportSdtmigVariablesRowClass :: !(Maybe Text) -- ^ "Class"
  , exportSdtmigVariablesRowDatasetName :: !(Maybe Text) -- ^ "Dataset Name"
  , exportSdtmigVariablesRowVariableName :: !(Maybe Text) -- ^ "Variable Name"
  , exportSdtmigVariablesRowVariableLabel :: !(Maybe Text) -- ^ "Variable Label"
  , exportSdtmigVariablesRowType :: !(Maybe Text) -- ^ "Type"
  , exportSdtmigVariablesRowControlledTermsCodelistOrFormat :: !(Maybe Text) -- ^ "Controlled Terms, Codelist or Format"
  , exportSdtmigVariablesRowRole :: !(Maybe Text) -- ^ "Role"
  , exportSdtmigVariablesRowCdiscNotes :: !(Maybe Text) -- ^ "CDISC Notes"
  , exportSdtmigVariablesRowCore :: !(Maybe Text) -- ^ "Core"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSdtmigVariablesRow
instance A.FromJSON ExportSdtmigVariablesRow where
  parseJSON = A.withObject "ExportSdtmigVariablesRow" $ \o ->
    ExportSdtmigVariablesRow
      <$> (o .:? "Version")
      <*> (o .:? "Variable Order")
      <*> (o .:? "Class")
      <*> (o .:? "Dataset Name")
      <*> (o .:? "Variable Name")
      <*> (o .:? "Variable Label")
      <*> (o .:? "Type")
      <*> (o .:? "Controlled Terms, Codelist or Format")
      <*> (o .:? "Role")
      <*> (o .:? "CDISC Notes")
      <*> (o .:? "Core")

-- | ToJSON ExportSdtmigVariablesRow
instance A.ToJSON ExportSdtmigVariablesRow where
  toJSON ExportSdtmigVariablesRow {..} =
   _omitNulls
      [ "Version" .= exportSdtmigVariablesRowVersion
      , "Variable Order" .= exportSdtmigVariablesRowVariableOrder
      , "Class" .= exportSdtmigVariablesRowClass
      , "Dataset Name" .= exportSdtmigVariablesRowDatasetName
      , "Variable Name" .= exportSdtmigVariablesRowVariableName
      , "Variable Label" .= exportSdtmigVariablesRowVariableLabel
      , "Type" .= exportSdtmigVariablesRowType
      , "Controlled Terms, Codelist or Format" .= exportSdtmigVariablesRowControlledTermsCodelistOrFormat
      , "Role" .= exportSdtmigVariablesRowRole
      , "CDISC Notes" .= exportSdtmigVariablesRowCdiscNotes
      , "Core" .= exportSdtmigVariablesRowCore
      ]


-- | Construct a value of type 'ExportSdtmigVariablesRow' (by applying it's required fields, if any)
mkExportSdtmigVariablesRow
  :: ExportSdtmigVariablesRow
mkExportSdtmigVariablesRow =
  ExportSdtmigVariablesRow
  { exportSdtmigVariablesRowVersion = Nothing
  , exportSdtmigVariablesRowVariableOrder = Nothing
  , exportSdtmigVariablesRowClass = Nothing
  , exportSdtmigVariablesRowDatasetName = Nothing
  , exportSdtmigVariablesRowVariableName = Nothing
  , exportSdtmigVariablesRowVariableLabel = Nothing
  , exportSdtmigVariablesRowType = Nothing
  , exportSdtmigVariablesRowControlledTermsCodelistOrFormat = Nothing
  , exportSdtmigVariablesRowRole = Nothing
  , exportSdtmigVariablesRowCdiscNotes = Nothing
  , exportSdtmigVariablesRowCore = Nothing
  }

-- ** ExportSdtmigVariablesTable
-- | ExportSdtmigVariablesTable
data ExportSdtmigVariablesTable = ExportSdtmigVariablesTable
  { exportSdtmigVariablesTableVariables :: !(Maybe [ExportSdtmigVariablesRow]) -- ^ "variables"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSdtmigVariablesTable
instance A.FromJSON ExportSdtmigVariablesTable where
  parseJSON = A.withObject "ExportSdtmigVariablesTable" $ \o ->
    ExportSdtmigVariablesTable
      <$> (o .:? "variables")

-- | ToJSON ExportSdtmigVariablesTable
instance A.ToJSON ExportSdtmigVariablesTable where
  toJSON ExportSdtmigVariablesTable {..} =
   _omitNulls
      [ "variables" .= exportSdtmigVariablesTableVariables
      ]


-- | Construct a value of type 'ExportSdtmigVariablesTable' (by applying it's required fields, if any)
mkExportSdtmigVariablesTable
  :: ExportSdtmigVariablesTable
mkExportSdtmigVariablesTable =
  ExportSdtmigVariablesTable
  { exportSdtmigVariablesTableVariables = Nothing
  }

-- ** ExportSdtmigWorkbook
-- | ExportSdtmigWorkbook
data ExportSdtmigWorkbook = ExportSdtmigWorkbook
  { exportSdtmigWorkbookVariables :: !(Maybe [ExportSdtmigVariablesRow]) -- ^ "variables"
  , exportSdtmigWorkbookDatasets :: !(Maybe [ExportSdtmigDatasetsRow]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSdtmigWorkbook
instance A.FromJSON ExportSdtmigWorkbook where
  parseJSON = A.withObject "ExportSdtmigWorkbook" $ \o ->
    ExportSdtmigWorkbook
      <$> (o .:? "variables")
      <*> (o .:? "datasets")

-- | ToJSON ExportSdtmigWorkbook
instance A.ToJSON ExportSdtmigWorkbook where
  toJSON ExportSdtmigWorkbook {..} =
   _omitNulls
      [ "variables" .= exportSdtmigWorkbookVariables
      , "datasets" .= exportSdtmigWorkbookDatasets
      ]


-- | Construct a value of type 'ExportSdtmigWorkbook' (by applying it's required fields, if any)
mkExportSdtmigWorkbook
  :: ExportSdtmigWorkbook
mkExportSdtmigWorkbook =
  ExportSdtmigWorkbook
  { exportSdtmigWorkbookVariables = Nothing
  , exportSdtmigWorkbookDatasets = Nothing
  }

-- ** ExportSendigDatasetsRow
-- | ExportSendigDatasetsRow
data ExportSendigDatasetsRow = ExportSendigDatasetsRow
  { exportSendigDatasetsRowVersion :: !(Maybe Text) -- ^ "Version"
  , exportSendigDatasetsRowClass :: !(Maybe Text) -- ^ "Class"
  , exportSendigDatasetsRowDatasetName :: !(Maybe Text) -- ^ "Dataset Name"
  , exportSendigDatasetsRowDatasetLabel :: !(Maybe Text) -- ^ "Dataset Label"
  , exportSendigDatasetsRowStructure :: !(Maybe Text) -- ^ "Structure"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSendigDatasetsRow
instance A.FromJSON ExportSendigDatasetsRow where
  parseJSON = A.withObject "ExportSendigDatasetsRow" $ \o ->
    ExportSendigDatasetsRow
      <$> (o .:? "Version")
      <*> (o .:? "Class")
      <*> (o .:? "Dataset Name")
      <*> (o .:? "Dataset Label")
      <*> (o .:? "Structure")

-- | ToJSON ExportSendigDatasetsRow
instance A.ToJSON ExportSendigDatasetsRow where
  toJSON ExportSendigDatasetsRow {..} =
   _omitNulls
      [ "Version" .= exportSendigDatasetsRowVersion
      , "Class" .= exportSendigDatasetsRowClass
      , "Dataset Name" .= exportSendigDatasetsRowDatasetName
      , "Dataset Label" .= exportSendigDatasetsRowDatasetLabel
      , "Structure" .= exportSendigDatasetsRowStructure
      ]


-- | Construct a value of type 'ExportSendigDatasetsRow' (by applying it's required fields, if any)
mkExportSendigDatasetsRow
  :: ExportSendigDatasetsRow
mkExportSendigDatasetsRow =
  ExportSendigDatasetsRow
  { exportSendigDatasetsRowVersion = Nothing
  , exportSendigDatasetsRowClass = Nothing
  , exportSendigDatasetsRowDatasetName = Nothing
  , exportSendigDatasetsRowDatasetLabel = Nothing
  , exportSendigDatasetsRowStructure = Nothing
  }

-- ** ExportSendigDatasetsTable
-- | ExportSendigDatasetsTable
data ExportSendigDatasetsTable = ExportSendigDatasetsTable
  { exportSendigDatasetsTableDatasets :: !(Maybe [ExportSendigDatasetsRow]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSendigDatasetsTable
instance A.FromJSON ExportSendigDatasetsTable where
  parseJSON = A.withObject "ExportSendigDatasetsTable" $ \o ->
    ExportSendigDatasetsTable
      <$> (o .:? "datasets")

-- | ToJSON ExportSendigDatasetsTable
instance A.ToJSON ExportSendigDatasetsTable where
  toJSON ExportSendigDatasetsTable {..} =
   _omitNulls
      [ "datasets" .= exportSendigDatasetsTableDatasets
      ]


-- | Construct a value of type 'ExportSendigDatasetsTable' (by applying it's required fields, if any)
mkExportSendigDatasetsTable
  :: ExportSendigDatasetsTable
mkExportSendigDatasetsTable =
  ExportSendigDatasetsTable
  { exportSendigDatasetsTableDatasets = Nothing
  }

-- ** ExportSendigVariablesRow
-- | ExportSendigVariablesRow
data ExportSendigVariablesRow = ExportSendigVariablesRow
  { exportSendigVariablesRowVersion :: !(Maybe Text) -- ^ "Version"
  , exportSendigVariablesRowVariableOrder :: !(Maybe Text) -- ^ "Variable Order"
  , exportSendigVariablesRowClass :: !(Maybe Text) -- ^ "Class"
  , exportSendigVariablesRowDatasetName :: !(Maybe Text) -- ^ "Dataset Name"
  , exportSendigVariablesRowVariableName :: !(Maybe Text) -- ^ "Variable Name"
  , exportSendigVariablesRowVariableLabel :: !(Maybe Text) -- ^ "Variable Label"
  , exportSendigVariablesRowType :: !(Maybe Text) -- ^ "Type"
  , exportSendigVariablesRowControlledTermsCodelistOrFormat :: !(Maybe Text) -- ^ "Controlled Terms, Codelist or Format"
  , exportSendigVariablesRowRole :: !(Maybe Text) -- ^ "Role"
  , exportSendigVariablesRowCdiscNotes :: !(Maybe Text) -- ^ "CDISC Notes"
  , exportSendigVariablesRowCore :: !(Maybe Text) -- ^ "Core"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSendigVariablesRow
instance A.FromJSON ExportSendigVariablesRow where
  parseJSON = A.withObject "ExportSendigVariablesRow" $ \o ->
    ExportSendigVariablesRow
      <$> (o .:? "Version")
      <*> (o .:? "Variable Order")
      <*> (o .:? "Class")
      <*> (o .:? "Dataset Name")
      <*> (o .:? "Variable Name")
      <*> (o .:? "Variable Label")
      <*> (o .:? "Type")
      <*> (o .:? "Controlled Terms, Codelist or Format")
      <*> (o .:? "Role")
      <*> (o .:? "CDISC Notes")
      <*> (o .:? "Core")

-- | ToJSON ExportSendigVariablesRow
instance A.ToJSON ExportSendigVariablesRow where
  toJSON ExportSendigVariablesRow {..} =
   _omitNulls
      [ "Version" .= exportSendigVariablesRowVersion
      , "Variable Order" .= exportSendigVariablesRowVariableOrder
      , "Class" .= exportSendigVariablesRowClass
      , "Dataset Name" .= exportSendigVariablesRowDatasetName
      , "Variable Name" .= exportSendigVariablesRowVariableName
      , "Variable Label" .= exportSendigVariablesRowVariableLabel
      , "Type" .= exportSendigVariablesRowType
      , "Controlled Terms, Codelist or Format" .= exportSendigVariablesRowControlledTermsCodelistOrFormat
      , "Role" .= exportSendigVariablesRowRole
      , "CDISC Notes" .= exportSendigVariablesRowCdiscNotes
      , "Core" .= exportSendigVariablesRowCore
      ]


-- | Construct a value of type 'ExportSendigVariablesRow' (by applying it's required fields, if any)
mkExportSendigVariablesRow
  :: ExportSendigVariablesRow
mkExportSendigVariablesRow =
  ExportSendigVariablesRow
  { exportSendigVariablesRowVersion = Nothing
  , exportSendigVariablesRowVariableOrder = Nothing
  , exportSendigVariablesRowClass = Nothing
  , exportSendigVariablesRowDatasetName = Nothing
  , exportSendigVariablesRowVariableName = Nothing
  , exportSendigVariablesRowVariableLabel = Nothing
  , exportSendigVariablesRowType = Nothing
  , exportSendigVariablesRowControlledTermsCodelistOrFormat = Nothing
  , exportSendigVariablesRowRole = Nothing
  , exportSendigVariablesRowCdiscNotes = Nothing
  , exportSendigVariablesRowCore = Nothing
  }

-- ** ExportSendigVariablesTable
-- | ExportSendigVariablesTable
data ExportSendigVariablesTable = ExportSendigVariablesTable
  { exportSendigVariablesTableVariables :: !(Maybe [ExportSendigVariablesRow]) -- ^ "variables"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSendigVariablesTable
instance A.FromJSON ExportSendigVariablesTable where
  parseJSON = A.withObject "ExportSendigVariablesTable" $ \o ->
    ExportSendigVariablesTable
      <$> (o .:? "variables")

-- | ToJSON ExportSendigVariablesTable
instance A.ToJSON ExportSendigVariablesTable where
  toJSON ExportSendigVariablesTable {..} =
   _omitNulls
      [ "variables" .= exportSendigVariablesTableVariables
      ]


-- | Construct a value of type 'ExportSendigVariablesTable' (by applying it's required fields, if any)
mkExportSendigVariablesTable
  :: ExportSendigVariablesTable
mkExportSendigVariablesTable =
  ExportSendigVariablesTable
  { exportSendigVariablesTableVariables = Nothing
  }

-- ** ExportSendigWorkbook
-- | ExportSendigWorkbook
data ExportSendigWorkbook = ExportSendigWorkbook
  { exportSendigWorkbookVariables :: !(Maybe [ExportSendigVariablesRow]) -- ^ "variables"
  , exportSendigWorkbookDatasets :: !(Maybe [ExportSendigDatasetsRow]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExportSendigWorkbook
instance A.FromJSON ExportSendigWorkbook where
  parseJSON = A.withObject "ExportSendigWorkbook" $ \o ->
    ExportSendigWorkbook
      <$> (o .:? "variables")
      <*> (o .:? "datasets")

-- | ToJSON ExportSendigWorkbook
instance A.ToJSON ExportSendigWorkbook where
  toJSON ExportSendigWorkbook {..} =
   _omitNulls
      [ "variables" .= exportSendigWorkbookVariables
      , "datasets" .= exportSendigWorkbookDatasets
      ]


-- | Construct a value of type 'ExportSendigWorkbook' (by applying it's required fields, if any)
mkExportSendigWorkbook
  :: ExportSendigWorkbook
mkExportSendigWorkbook =
  ExportSendigWorkbook
  { exportSendigWorkbookVariables = Nothing
  , exportSendigWorkbookDatasets = Nothing
  }

-- ** Health
-- | Health
data Health = Health
  { healthHealthy :: !(Maybe Bool) -- ^ "healthy"
  , healthLdapAuthenticationHealthy :: !(Maybe Bool) -- ^ "ldapAuthenticationHealthy"
  , healthLdapAuthorizationHealthy :: !(Maybe Bool) -- ^ "ldapAuthorizationHealthy"
  , healthDatabaseHealthy :: !(Maybe Bool) -- ^ "databaseHealthy"
  , healthEsHealthy :: !(Maybe Bool) -- ^ "esHealthy"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Health
instance A.FromJSON Health where
  parseJSON = A.withObject "Health" $ \o ->
    Health
      <$> (o .:? "healthy")
      <*> (o .:? "ldapAuthenticationHealthy")
      <*> (o .:? "ldapAuthorizationHealthy")
      <*> (o .:? "databaseHealthy")
      <*> (o .:? "esHealthy")

-- | ToJSON Health
instance A.ToJSON Health where
  toJSON Health {..} =
   _omitNulls
      [ "healthy" .= healthHealthy
      , "ldapAuthenticationHealthy" .= healthLdapAuthenticationHealthy
      , "ldapAuthorizationHealthy" .= healthLdapAuthorizationHealthy
      , "databaseHealthy" .= healthDatabaseHealthy
      , "esHealthy" .= healthEsHealthy
      ]


-- | Construct a value of type 'Health' (by applying it's required fields, if any)
mkHealth
  :: Health
mkHealth =
  Health
  { healthHealthy = Nothing
  , healthLdapAuthenticationHealthy = Nothing
  , healthLdapAuthorizationHealthy = Nothing
  , healthDatabaseHealthy = Nothing
  , healthEsHealthy = Nothing
  }

-- ** Lastupdated
-- | Lastupdated
data Lastupdated = Lastupdated
  { lastupdatedLinks :: !(Maybe LastupdatedLinks) -- ^ "_links"
  , lastupdatedOverall :: !(Maybe Text) -- ^ "overall"
  , lastupdatedDataAnalysis :: !(Maybe Text) -- ^ "data-analysis"
  , lastupdatedDataCollection :: !(Maybe Text) -- ^ "data-collection"
  , lastupdatedDataTabulation :: !(Maybe Text) -- ^ "data-tabulation"
  , lastupdatedMeasure :: !(Maybe Text) -- ^ "measure"
  , lastupdatedTerminology :: !(Maybe Text) -- ^ "terminology"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Lastupdated
instance A.FromJSON Lastupdated where
  parseJSON = A.withObject "Lastupdated" $ \o ->
    Lastupdated
      <$> (o .:? "_links")
      <*> (o .:? "overall")
      <*> (o .:? "data-analysis")
      <*> (o .:? "data-collection")
      <*> (o .:? "data-tabulation")
      <*> (o .:? "measure")
      <*> (o .:? "terminology")

-- | ToJSON Lastupdated
instance A.ToJSON Lastupdated where
  toJSON Lastupdated {..} =
   _omitNulls
      [ "_links" .= lastupdatedLinks
      , "overall" .= lastupdatedOverall
      , "data-analysis" .= lastupdatedDataAnalysis
      , "data-collection" .= lastupdatedDataCollection
      , "data-tabulation" .= lastupdatedDataTabulation
      , "measure" .= lastupdatedMeasure
      , "terminology" .= lastupdatedTerminology
      ]


-- | Construct a value of type 'Lastupdated' (by applying it's required fields, if any)
mkLastupdated
  :: Lastupdated
mkLastupdated =
  Lastupdated
  { lastupdatedLinks = Nothing
  , lastupdatedOverall = Nothing
  , lastupdatedDataAnalysis = Nothing
  , lastupdatedDataCollection = Nothing
  , lastupdatedDataTabulation = Nothing
  , lastupdatedMeasure = Nothing
  , lastupdatedTerminology = Nothing
  }

-- ** LastupdatedLinks
-- | LastupdatedLinks
data LastupdatedLinks = LastupdatedLinks
  { lastupdatedLinksSelf :: !(Maybe LastupdatedRef) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LastupdatedLinks
instance A.FromJSON LastupdatedLinks where
  parseJSON = A.withObject "LastupdatedLinks" $ \o ->
    LastupdatedLinks
      <$> (o .:? "self")

-- | ToJSON LastupdatedLinks
instance A.ToJSON LastupdatedLinks where
  toJSON LastupdatedLinks {..} =
   _omitNulls
      [ "self" .= lastupdatedLinksSelf
      ]


-- | Construct a value of type 'LastupdatedLinks' (by applying it's required fields, if any)
mkLastupdatedLinks
  :: LastupdatedLinks
mkLastupdatedLinks =
  LastupdatedLinks
  { lastupdatedLinksSelf = Nothing
  }

-- ** LastupdatedRef
-- | LastupdatedRef
data LastupdatedRef = LastupdatedRef
  { lastupdatedRefHref :: !(Maybe Text) -- ^ "href"
  , lastupdatedRefTitle :: !(Maybe Text) -- ^ "title"
  , lastupdatedRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LastupdatedRef
instance A.FromJSON LastupdatedRef where
  parseJSON = A.withObject "LastupdatedRef" $ \o ->
    LastupdatedRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON LastupdatedRef
instance A.ToJSON LastupdatedRef where
  toJSON LastupdatedRef {..} =
   _omitNulls
      [ "href" .= lastupdatedRefHref
      , "title" .= lastupdatedRefTitle
      , "type" .= lastupdatedRefType
      ]


-- | Construct a value of type 'LastupdatedRef' (by applying it's required fields, if any)
mkLastupdatedRef
  :: LastupdatedRef
mkLastupdatedRef =
  LastupdatedRef
  { lastupdatedRefHref = Nothing
  , lastupdatedRefTitle = Nothing
  , lastupdatedRefType = Nothing
  }

-- ** MaintenanceBody
-- | MaintenanceBody
data MaintenanceBody = MaintenanceBody
  { maintenanceBodyMaintenanceMode :: !(Maybe Bool) -- ^ "maintenanceMode"
  , maintenanceBodyMaintenanceMessage :: !(Maybe Text) -- ^ "maintenanceMessage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MaintenanceBody
instance A.FromJSON MaintenanceBody where
  parseJSON = A.withObject "MaintenanceBody" $ \o ->
    MaintenanceBody
      <$> (o .:? "maintenanceMode")
      <*> (o .:? "maintenanceMessage")

-- | ToJSON MaintenanceBody
instance A.ToJSON MaintenanceBody where
  toJSON MaintenanceBody {..} =
   _omitNulls
      [ "maintenanceMode" .= maintenanceBodyMaintenanceMode
      , "maintenanceMessage" .= maintenanceBodyMaintenanceMessage
      ]


-- | Construct a value of type 'MaintenanceBody' (by applying it's required fields, if any)
mkMaintenanceBody
  :: MaintenanceBody
mkMaintenanceBody =
  MaintenanceBody
  { maintenanceBodyMaintenanceMode = Nothing
  , maintenanceBodyMaintenanceMessage = Nothing
  }

-- ** MdrSearchScopesGet200Response
-- | MdrSearchScopesGet200Response
data MdrSearchScopesGet200Response = MdrSearchScopesGet200Response
  { mdrSearchScopesGet200ResponseScopes :: !(Maybe [DefaultSearchScopes]) -- ^ "scopes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MdrSearchScopesGet200Response
instance A.FromJSON MdrSearchScopesGet200Response where
  parseJSON = A.withObject "MdrSearchScopesGet200Response" $ \o ->
    MdrSearchScopesGet200Response
      <$> (o .:? "scopes")

-- | ToJSON MdrSearchScopesGet200Response
instance A.ToJSON MdrSearchScopesGet200Response where
  toJSON MdrSearchScopesGet200Response {..} =
   _omitNulls
      [ "scopes" .= mdrSearchScopesGet200ResponseScopes
      ]


-- | Construct a value of type 'MdrSearchScopesGet200Response' (by applying it's required fields, if any)
mkMdrSearchScopesGet200Response
  :: MdrSearchScopesGet200Response
mkMdrSearchScopesGet200Response =
  MdrSearchScopesGet200Response
  { mdrSearchScopesGet200ResponseScopes = Nothing
  }

-- ** ProductgroupDataAnalysis
-- | ProductgroupDataAnalysis
data ProductgroupDataAnalysis = ProductgroupDataAnalysis
  { productgroupDataAnalysisLinks :: !(Maybe ProductgroupDataAnalysisLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProductgroupDataAnalysis
instance A.FromJSON ProductgroupDataAnalysis where
  parseJSON = A.withObject "ProductgroupDataAnalysis" $ \o ->
    ProductgroupDataAnalysis
      <$> (o .:? "_links")

-- | ToJSON ProductgroupDataAnalysis
instance A.ToJSON ProductgroupDataAnalysis where
  toJSON ProductgroupDataAnalysis {..} =
   _omitNulls
      [ "_links" .= productgroupDataAnalysisLinks
      ]


-- | Construct a value of type 'ProductgroupDataAnalysis' (by applying it's required fields, if any)
mkProductgroupDataAnalysis
  :: ProductgroupDataAnalysis
mkProductgroupDataAnalysis =
  ProductgroupDataAnalysis
  { productgroupDataAnalysisLinks = Nothing
  }

-- ** ProductgroupDataAnalysisLinks
-- | ProductgroupDataAnalysisLinks
data ProductgroupDataAnalysisLinks = ProductgroupDataAnalysisLinks
  { productgroupDataAnalysisLinksSelf :: !(Maybe ProductgroupRef) -- ^ "self"
  , productgroupDataAnalysisLinksAdam :: !(Maybe [AdamProductRefElement]) -- ^ "adam"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProductgroupDataAnalysisLinks
instance A.FromJSON ProductgroupDataAnalysisLinks where
  parseJSON = A.withObject "ProductgroupDataAnalysisLinks" $ \o ->
    ProductgroupDataAnalysisLinks
      <$> (o .:? "self")
      <*> (o .:? "adam")

-- | ToJSON ProductgroupDataAnalysisLinks
instance A.ToJSON ProductgroupDataAnalysisLinks where
  toJSON ProductgroupDataAnalysisLinks {..} =
   _omitNulls
      [ "self" .= productgroupDataAnalysisLinksSelf
      , "adam" .= productgroupDataAnalysisLinksAdam
      ]


-- | Construct a value of type 'ProductgroupDataAnalysisLinks' (by applying it's required fields, if any)
mkProductgroupDataAnalysisLinks
  :: ProductgroupDataAnalysisLinks
mkProductgroupDataAnalysisLinks =
  ProductgroupDataAnalysisLinks
  { productgroupDataAnalysisLinksSelf = Nothing
  , productgroupDataAnalysisLinksAdam = Nothing
  }

-- ** ProductgroupDataCollection
-- | ProductgroupDataCollection
data ProductgroupDataCollection = ProductgroupDataCollection
  { productgroupDataCollectionLinks :: !(Maybe ProductgroupDataCollectionLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProductgroupDataCollection
instance A.FromJSON ProductgroupDataCollection where
  parseJSON = A.withObject "ProductgroupDataCollection" $ \o ->
    ProductgroupDataCollection
      <$> (o .:? "_links")

-- | ToJSON ProductgroupDataCollection
instance A.ToJSON ProductgroupDataCollection where
  toJSON ProductgroupDataCollection {..} =
   _omitNulls
      [ "_links" .= productgroupDataCollectionLinks
      ]


-- | Construct a value of type 'ProductgroupDataCollection' (by applying it's required fields, if any)
mkProductgroupDataCollection
  :: ProductgroupDataCollection
mkProductgroupDataCollection =
  ProductgroupDataCollection
  { productgroupDataCollectionLinks = Nothing
  }

-- ** ProductgroupDataCollectionLinks
-- | ProductgroupDataCollectionLinks
data ProductgroupDataCollectionLinks = ProductgroupDataCollectionLinks
  { productgroupDataCollectionLinksSelf :: !(Maybe ProductgroupRef) -- ^ "self"
  , productgroupDataCollectionLinksCdash :: !(Maybe [CdashProductRefElement]) -- ^ "cdash"
  , productgroupDataCollectionLinksCdashig :: !(Maybe [CdashigProductRefElement]) -- ^ "cdashig"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProductgroupDataCollectionLinks
instance A.FromJSON ProductgroupDataCollectionLinks where
  parseJSON = A.withObject "ProductgroupDataCollectionLinks" $ \o ->
    ProductgroupDataCollectionLinks
      <$> (o .:? "self")
      <*> (o .:? "cdash")
      <*> (o .:? "cdashig")

-- | ToJSON ProductgroupDataCollectionLinks
instance A.ToJSON ProductgroupDataCollectionLinks where
  toJSON ProductgroupDataCollectionLinks {..} =
   _omitNulls
      [ "self" .= productgroupDataCollectionLinksSelf
      , "cdash" .= productgroupDataCollectionLinksCdash
      , "cdashig" .= productgroupDataCollectionLinksCdashig
      ]


-- | Construct a value of type 'ProductgroupDataCollectionLinks' (by applying it's required fields, if any)
mkProductgroupDataCollectionLinks
  :: ProductgroupDataCollectionLinks
mkProductgroupDataCollectionLinks =
  ProductgroupDataCollectionLinks
  { productgroupDataCollectionLinksSelf = Nothing
  , productgroupDataCollectionLinksCdash = Nothing
  , productgroupDataCollectionLinksCdashig = Nothing
  }

-- ** ProductgroupDataTabulation
-- | ProductgroupDataTabulation
data ProductgroupDataTabulation = ProductgroupDataTabulation
  { productgroupDataTabulationLinks :: !(Maybe ProductgroupDataTabulationLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProductgroupDataTabulation
instance A.FromJSON ProductgroupDataTabulation where
  parseJSON = A.withObject "ProductgroupDataTabulation" $ \o ->
    ProductgroupDataTabulation
      <$> (o .:? "_links")

-- | ToJSON ProductgroupDataTabulation
instance A.ToJSON ProductgroupDataTabulation where
  toJSON ProductgroupDataTabulation {..} =
   _omitNulls
      [ "_links" .= productgroupDataTabulationLinks
      ]


-- | Construct a value of type 'ProductgroupDataTabulation' (by applying it's required fields, if any)
mkProductgroupDataTabulation
  :: ProductgroupDataTabulation
mkProductgroupDataTabulation =
  ProductgroupDataTabulation
  { productgroupDataTabulationLinks = Nothing
  }

-- ** ProductgroupDataTabulationLinks
-- | ProductgroupDataTabulationLinks
data ProductgroupDataTabulationLinks = ProductgroupDataTabulationLinks
  { productgroupDataTabulationLinksSelf :: !(Maybe ProductgroupRef) -- ^ "self"
  , productgroupDataTabulationLinksSdtm :: !(Maybe [SdtmProductRefElement]) -- ^ "sdtm"
  , productgroupDataTabulationLinksSdtmig :: !(Maybe [SdtmigProductRefElement]) -- ^ "sdtmig"
  , productgroupDataTabulationLinksSendig :: !(Maybe [SendigProductRefElement]) -- ^ "sendig"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProductgroupDataTabulationLinks
instance A.FromJSON ProductgroupDataTabulationLinks where
  parseJSON = A.withObject "ProductgroupDataTabulationLinks" $ \o ->
    ProductgroupDataTabulationLinks
      <$> (o .:? "self")
      <*> (o .:? "sdtm")
      <*> (o .:? "sdtmig")
      <*> (o .:? "sendig")

-- | ToJSON ProductgroupDataTabulationLinks
instance A.ToJSON ProductgroupDataTabulationLinks where
  toJSON ProductgroupDataTabulationLinks {..} =
   _omitNulls
      [ "self" .= productgroupDataTabulationLinksSelf
      , "sdtm" .= productgroupDataTabulationLinksSdtm
      , "sdtmig" .= productgroupDataTabulationLinksSdtmig
      , "sendig" .= productgroupDataTabulationLinksSendig
      ]


-- | Construct a value of type 'ProductgroupDataTabulationLinks' (by applying it's required fields, if any)
mkProductgroupDataTabulationLinks
  :: ProductgroupDataTabulationLinks
mkProductgroupDataTabulationLinks =
  ProductgroupDataTabulationLinks
  { productgroupDataTabulationLinksSelf = Nothing
  , productgroupDataTabulationLinksSdtm = Nothing
  , productgroupDataTabulationLinksSdtmig = Nothing
  , productgroupDataTabulationLinksSendig = Nothing
  }

-- ** ProductgroupQrs
-- | ProductgroupQrs
data ProductgroupQrs = ProductgroupQrs
  { productgroupQrsLinks :: !(Maybe ProductgroupQrsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProductgroupQrs
instance A.FromJSON ProductgroupQrs where
  parseJSON = A.withObject "ProductgroupQrs" $ \o ->
    ProductgroupQrs
      <$> (o .:? "_links")

-- | ToJSON ProductgroupQrs
instance A.ToJSON ProductgroupQrs where
  toJSON ProductgroupQrs {..} =
   _omitNulls
      [ "_links" .= productgroupQrsLinks
      ]


-- | Construct a value of type 'ProductgroupQrs' (by applying it's required fields, if any)
mkProductgroupQrs
  :: ProductgroupQrs
mkProductgroupQrs =
  ProductgroupQrs
  { productgroupQrsLinks = Nothing
  }

-- ** ProductgroupQrsLinks
-- | ProductgroupQrsLinks
data ProductgroupQrsLinks = ProductgroupQrsLinks
  { productgroupQrsLinksSelf :: !(Maybe ProductgroupRef) -- ^ "self"
  , productgroupQrsLinksQrs :: !(Maybe [QrsRefElement]) -- ^ "qrs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProductgroupQrsLinks
instance A.FromJSON ProductgroupQrsLinks where
  parseJSON = A.withObject "ProductgroupQrsLinks" $ \o ->
    ProductgroupQrsLinks
      <$> (o .:? "self")
      <*> (o .:? "qrs")

-- | ToJSON ProductgroupQrsLinks
instance A.ToJSON ProductgroupQrsLinks where
  toJSON ProductgroupQrsLinks {..} =
   _omitNulls
      [ "self" .= productgroupQrsLinksSelf
      , "qrs" .= productgroupQrsLinksQrs
      ]


-- | Construct a value of type 'ProductgroupQrsLinks' (by applying it's required fields, if any)
mkProductgroupQrsLinks
  :: ProductgroupQrsLinks
mkProductgroupQrsLinks =
  ProductgroupQrsLinks
  { productgroupQrsLinksSelf = Nothing
  , productgroupQrsLinksQrs = Nothing
  }

-- ** ProductgroupRef
-- | ProductgroupRef
data ProductgroupRef = ProductgroupRef
  { productgroupRefHref :: !(Maybe Text) -- ^ "href"
  , productgroupRefTitle :: !(Maybe Text) -- ^ "title"
  , productgroupRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProductgroupRef
instance A.FromJSON ProductgroupRef where
  parseJSON = A.withObject "ProductgroupRef" $ \o ->
    ProductgroupRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON ProductgroupRef
instance A.ToJSON ProductgroupRef where
  toJSON ProductgroupRef {..} =
   _omitNulls
      [ "href" .= productgroupRefHref
      , "title" .= productgroupRefTitle
      , "type" .= productgroupRefType
      ]


-- | Construct a value of type 'ProductgroupRef' (by applying it's required fields, if any)
mkProductgroupRef
  :: ProductgroupRef
mkProductgroupRef =
  ProductgroupRef
  { productgroupRefHref = Nothing
  , productgroupRefTitle = Nothing
  , productgroupRefType = Nothing
  }

-- ** ProductgroupTerminology
-- | ProductgroupTerminology
data ProductgroupTerminology = ProductgroupTerminology
  { productgroupTerminologyLinks :: !(Maybe ProductgroupTerminologyLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProductgroupTerminology
instance A.FromJSON ProductgroupTerminology where
  parseJSON = A.withObject "ProductgroupTerminology" $ \o ->
    ProductgroupTerminology
      <$> (o .:? "_links")

-- | ToJSON ProductgroupTerminology
instance A.ToJSON ProductgroupTerminology where
  toJSON ProductgroupTerminology {..} =
   _omitNulls
      [ "_links" .= productgroupTerminologyLinks
      ]


-- | Construct a value of type 'ProductgroupTerminology' (by applying it's required fields, if any)
mkProductgroupTerminology
  :: ProductgroupTerminology
mkProductgroupTerminology =
  ProductgroupTerminology
  { productgroupTerminologyLinks = Nothing
  }

-- ** ProductgroupTerminologyLinks
-- | ProductgroupTerminologyLinks
data ProductgroupTerminologyLinks = ProductgroupTerminologyLinks
  { productgroupTerminologyLinksSelf :: !(Maybe ProductgroupRef) -- ^ "self"
  , productgroupTerminologyLinksPackages :: !(Maybe [CtPackageRefElement]) -- ^ "packages"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProductgroupTerminologyLinks
instance A.FromJSON ProductgroupTerminologyLinks where
  parseJSON = A.withObject "ProductgroupTerminologyLinks" $ \o ->
    ProductgroupTerminologyLinks
      <$> (o .:? "self")
      <*> (o .:? "packages")

-- | ToJSON ProductgroupTerminologyLinks
instance A.ToJSON ProductgroupTerminologyLinks where
  toJSON ProductgroupTerminologyLinks {..} =
   _omitNulls
      [ "self" .= productgroupTerminologyLinksSelf
      , "packages" .= productgroupTerminologyLinksPackages
      ]


-- | Construct a value of type 'ProductgroupTerminologyLinks' (by applying it's required fields, if any)
mkProductgroupTerminologyLinks
  :: ProductgroupTerminologyLinks
mkProductgroupTerminologyLinks =
  ProductgroupTerminologyLinks
  { productgroupTerminologyLinksSelf = Nothing
  , productgroupTerminologyLinksPackages = Nothing
  }

-- ** Products
-- | Products
data Products = Products
  { productsLinks :: !(Maybe ProductsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Products
instance A.FromJSON Products where
  parseJSON = A.withObject "Products" $ \o ->
    Products
      <$> (o .:? "_links")

-- | ToJSON Products
instance A.ToJSON Products where
  toJSON Products {..} =
   _omitNulls
      [ "_links" .= productsLinks
      ]


-- | Construct a value of type 'Products' (by applying it's required fields, if any)
mkProducts
  :: Products
mkProducts =
  Products
  { productsLinks = Nothing
  }

-- ** ProductsLinks
-- | ProductsLinks
data ProductsLinks = ProductsLinks
  { productsLinksSelf :: !(Maybe ProductsRef) -- ^ "self"
  , productsLinksDataCollection :: !(Maybe ProductgroupDataCollection) -- ^ "data-collection"
  , productsLinksDataTabulation :: !(Maybe ProductgroupDataTabulation) -- ^ "data-tabulation"
  , productsLinksDataAnalysis :: !(Maybe ProductgroupDataAnalysis) -- ^ "data-analysis"
  , productsLinksTerminology :: !(Maybe ProductgroupTerminology) -- ^ "terminology"
  , productsLinksMeasure :: !(Maybe ProductgroupQrs) -- ^ "measure"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProductsLinks
instance A.FromJSON ProductsLinks where
  parseJSON = A.withObject "ProductsLinks" $ \o ->
    ProductsLinks
      <$> (o .:? "self")
      <*> (o .:? "data-collection")
      <*> (o .:? "data-tabulation")
      <*> (o .:? "data-analysis")
      <*> (o .:? "terminology")
      <*> (o .:? "measure")

-- | ToJSON ProductsLinks
instance A.ToJSON ProductsLinks where
  toJSON ProductsLinks {..} =
   _omitNulls
      [ "self" .= productsLinksSelf
      , "data-collection" .= productsLinksDataCollection
      , "data-tabulation" .= productsLinksDataTabulation
      , "data-analysis" .= productsLinksDataAnalysis
      , "terminology" .= productsLinksTerminology
      , "measure" .= productsLinksMeasure
      ]


-- | Construct a value of type 'ProductsLinks' (by applying it's required fields, if any)
mkProductsLinks
  :: ProductsLinks
mkProductsLinks =
  ProductsLinks
  { productsLinksSelf = Nothing
  , productsLinksDataCollection = Nothing
  , productsLinksDataTabulation = Nothing
  , productsLinksDataAnalysis = Nothing
  , productsLinksTerminology = Nothing
  , productsLinksMeasure = Nothing
  }

-- ** ProductsRef
-- | ProductsRef
data ProductsRef = ProductsRef
  { productsRefHref :: !(Maybe Text) -- ^ "href"
  , productsRefTitle :: !(Maybe Text) -- ^ "title"
  , productsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProductsRef
instance A.FromJSON ProductsRef where
  parseJSON = A.withObject "ProductsRef" $ \o ->
    ProductsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON ProductsRef
instance A.ToJSON ProductsRef where
  toJSON ProductsRef {..} =
   _omitNulls
      [ "href" .= productsRefHref
      , "title" .= productsRefTitle
      , "type" .= productsRefType
      ]


-- | Construct a value of type 'ProductsRef' (by applying it's required fields, if any)
mkProductsRef
  :: ProductsRef
mkProductsRef =
  ProductsRef
  { productsRefHref = Nothing
  , productsRefTitle = Nothing
  , productsRefType = Nothing
  }

-- ** QrsItem
-- | QrsItem
data QrsItem = QrsItem
  { qrsItemOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , qrsItemLabel :: !(Maybe Text) -- ^ "label"
  , qrsItemQuestionText :: !(Maybe Text) -- ^ "questionText"
  , qrsItemLinks :: !(Maybe QrsItemLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsItem
instance A.FromJSON QrsItem where
  parseJSON = A.withObject "QrsItem" $ \o ->
    QrsItem
      <$> (o .:? "ordinal")
      <*> (o .:? "label")
      <*> (o .:? "questionText")
      <*> (o .:? "_links")

-- | ToJSON QrsItem
instance A.ToJSON QrsItem where
  toJSON QrsItem {..} =
   _omitNulls
      [ "ordinal" .= qrsItemOrdinal
      , "label" .= qrsItemLabel
      , "questionText" .= qrsItemQuestionText
      , "_links" .= qrsItemLinks
      ]


-- | Construct a value of type 'QrsItem' (by applying it's required fields, if any)
mkQrsItem
  :: QrsItem
mkQrsItem =
  QrsItem
  { qrsItemOrdinal = Nothing
  , qrsItemLabel = Nothing
  , qrsItemQuestionText = Nothing
  , qrsItemLinks = Nothing
  }

-- ** QrsItemLinks
-- | QrsItemLinks
data QrsItemLinks = QrsItemLinks
  { qrsItemLinksQrsItemTest :: !(Maybe RootCtTermRef) -- ^ "qrsItemTEST"
  , qrsItemLinksQrsItemTestcd :: !(Maybe RootCtTermRef) -- ^ "qrsItemTESTCD"
  , qrsItemLinksQrsItemEval :: !(Maybe RootCtTermRef) -- ^ "qrsItemEVAL"
  , qrsItemLinksQrsItemScat :: !(Maybe RootCtTermRef) -- ^ "qrsItemSCAT"
  , qrsItemLinksResponsegroup :: !(Maybe QrsResponsegroup) -- ^ "responsegroup"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsItemLinks
instance A.FromJSON QrsItemLinks where
  parseJSON = A.withObject "QrsItemLinks" $ \o ->
    QrsItemLinks
      <$> (o .:? "qrsItemTEST")
      <*> (o .:? "qrsItemTESTCD")
      <*> (o .:? "qrsItemEVAL")
      <*> (o .:? "qrsItemSCAT")
      <*> (o .:? "responsegroup")

-- | ToJSON QrsItemLinks
instance A.ToJSON QrsItemLinks where
  toJSON QrsItemLinks {..} =
   _omitNulls
      [ "qrsItemTEST" .= qrsItemLinksQrsItemTest
      , "qrsItemTESTCD" .= qrsItemLinksQrsItemTestcd
      , "qrsItemEVAL" .= qrsItemLinksQrsItemEval
      , "qrsItemSCAT" .= qrsItemLinksQrsItemScat
      , "responsegroup" .= qrsItemLinksResponsegroup
      ]


-- | Construct a value of type 'QrsItemLinks' (by applying it's required fields, if any)
mkQrsItemLinks
  :: QrsItemLinks
mkQrsItemLinks =
  QrsItemLinks
  { qrsItemLinksQrsItemTest = Nothing
  , qrsItemLinksQrsItemTestcd = Nothing
  , qrsItemLinksQrsItemEval = Nothing
  , qrsItemLinksQrsItemScat = Nothing
  , qrsItemLinksResponsegroup = Nothing
  }

-- ** QrsItemRefElement
-- | QrsItemRefElement
data QrsItemRefElement = QrsItemRefElement
  { qrsItemRefElementHref :: !(Maybe Text) -- ^ "href"
  , qrsItemRefElementTitle :: !(Maybe Text) -- ^ "title"
  , qrsItemRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsItemRefElement
instance A.FromJSON QrsItemRefElement where
  parseJSON = A.withObject "QrsItemRefElement" $ \o ->
    QrsItemRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON QrsItemRefElement
instance A.ToJSON QrsItemRefElement where
  toJSON QrsItemRefElement {..} =
   _omitNulls
      [ "href" .= qrsItemRefElementHref
      , "title" .= qrsItemRefElementTitle
      , "type" .= qrsItemRefElementType
      ]


-- | Construct a value of type 'QrsItemRefElement' (by applying it's required fields, if any)
mkQrsItemRefElement
  :: QrsItemRefElement
mkQrsItemRefElement =
  QrsItemRefElement
  { qrsItemRefElementHref = Nothing
  , qrsItemRefElementTitle = Nothing
  , qrsItemRefElementType = Nothing
  }

-- ** QrsItems
-- | QrsItems
data QrsItems = QrsItems
  { qrsItemsName :: !(Maybe Text) -- ^ "name"
  , qrsItemsLabel :: !(Maybe Text) -- ^ "label"
  , qrsItemsDescription :: !(Maybe Text) -- ^ "description"
  , qrsItemsEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , qrsItemsUntilDate :: !(Maybe Text) -- ^ "untilDate"
  , qrsItemsRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , qrsItemsVersion :: !(Maybe Text) -- ^ "version"
  , qrsItemsQrsType :: !(Maybe Text) -- ^ "qrsType"
  , qrsItemsLinks :: !(Maybe QrsItemsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsItems
instance A.FromJSON QrsItems where
  parseJSON = A.withObject "QrsItems" $ \o ->
    QrsItems
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "untilDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "qrsType")
      <*> (o .:? "_links")

-- | ToJSON QrsItems
instance A.ToJSON QrsItems where
  toJSON QrsItems {..} =
   _omitNulls
      [ "name" .= qrsItemsName
      , "label" .= qrsItemsLabel
      , "description" .= qrsItemsDescription
      , "effectiveDate" .= qrsItemsEffectiveDate
      , "untilDate" .= qrsItemsUntilDate
      , "registrationStatus" .= qrsItemsRegistrationStatus
      , "version" .= qrsItemsVersion
      , "qrsType" .= qrsItemsQrsType
      , "_links" .= qrsItemsLinks
      ]


-- | Construct a value of type 'QrsItems' (by applying it's required fields, if any)
mkQrsItems
  :: QrsItems
mkQrsItems =
  QrsItems
  { qrsItemsName = Nothing
  , qrsItemsLabel = Nothing
  , qrsItemsDescription = Nothing
  , qrsItemsEffectiveDate = Nothing
  , qrsItemsUntilDate = Nothing
  , qrsItemsRegistrationStatus = Nothing
  , qrsItemsVersion = Nothing
  , qrsItemsQrsType = Nothing
  , qrsItemsLinks = Nothing
  }

-- ** QrsItemsLinks
-- | QrsItemsLinks
data QrsItemsLinks = QrsItemsLinks
  { qrsItemsLinksSelf :: !(Maybe QrsItemsRef) -- ^ "self"
  , qrsItemsLinksParentProduct :: !(Maybe QrsProductRef) -- ^ "parentProduct"
  , qrsItemsLinksItems :: !(Maybe [QrsItemRefElement]) -- ^ "items"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsItemsLinks
instance A.FromJSON QrsItemsLinks where
  parseJSON = A.withObject "QrsItemsLinks" $ \o ->
    QrsItemsLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "items")

-- | ToJSON QrsItemsLinks
instance A.ToJSON QrsItemsLinks where
  toJSON QrsItemsLinks {..} =
   _omitNulls
      [ "self" .= qrsItemsLinksSelf
      , "parentProduct" .= qrsItemsLinksParentProduct
      , "items" .= qrsItemsLinksItems
      ]


-- | Construct a value of type 'QrsItemsLinks' (by applying it's required fields, if any)
mkQrsItemsLinks
  :: QrsItemsLinks
mkQrsItemsLinks =
  QrsItemsLinks
  { qrsItemsLinksSelf = Nothing
  , qrsItemsLinksParentProduct = Nothing
  , qrsItemsLinksItems = Nothing
  }

-- ** QrsItemsRef
-- | QrsItemsRef
data QrsItemsRef = QrsItemsRef
  { qrsItemsRefHref :: !(Maybe Text) -- ^ "href"
  , qrsItemsRefTitle :: !(Maybe Text) -- ^ "title"
  , qrsItemsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsItemsRef
instance A.FromJSON QrsItemsRef where
  parseJSON = A.withObject "QrsItemsRef" $ \o ->
    QrsItemsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON QrsItemsRef
instance A.ToJSON QrsItemsRef where
  toJSON QrsItemsRef {..} =
   _omitNulls
      [ "href" .= qrsItemsRefHref
      , "title" .= qrsItemsRefTitle
      , "type" .= qrsItemsRefType
      ]


-- | Construct a value of type 'QrsItemsRef' (by applying it's required fields, if any)
mkQrsItemsRef
  :: QrsItemsRef
mkQrsItemsRef =
  QrsItemsRef
  { qrsItemsRefHref = Nothing
  , qrsItemsRefTitle = Nothing
  , qrsItemsRefType = Nothing
  }

-- ** QrsProduct
-- | QrsProduct
data QrsProduct = QrsProduct
  { qrsProductName :: !(Maybe Text) -- ^ "name"
  , qrsProductLabel :: !(Maybe Text) -- ^ "label"
  , qrsProductDescription :: !(Maybe Text) -- ^ "description"
  , qrsProductEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , qrsProductUntilDate :: !(Maybe Text) -- ^ "untilDate"
  , qrsProductRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , qrsProductVersion :: !(Maybe Text) -- ^ "version"
  , qrsProductQrsType :: !(Maybe Text) -- ^ "qrsType"
  , qrsProductLinks :: !(Maybe QrsProductLinks) -- ^ "_links"
  , qrsProductItems :: !(Maybe [QrsItem]) -- ^ "items"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsProduct
instance A.FromJSON QrsProduct where
  parseJSON = A.withObject "QrsProduct" $ \o ->
    QrsProduct
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "untilDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "qrsType")
      <*> (o .:? "_links")
      <*> (o .:? "items")

-- | ToJSON QrsProduct
instance A.ToJSON QrsProduct where
  toJSON QrsProduct {..} =
   _omitNulls
      [ "name" .= qrsProductName
      , "label" .= qrsProductLabel
      , "description" .= qrsProductDescription
      , "effectiveDate" .= qrsProductEffectiveDate
      , "untilDate" .= qrsProductUntilDate
      , "registrationStatus" .= qrsProductRegistrationStatus
      , "version" .= qrsProductVersion
      , "qrsType" .= qrsProductQrsType
      , "_links" .= qrsProductLinks
      , "items" .= qrsProductItems
      ]


-- | Construct a value of type 'QrsProduct' (by applying it's required fields, if any)
mkQrsProduct
  :: QrsProduct
mkQrsProduct =
  QrsProduct
  { qrsProductName = Nothing
  , qrsProductLabel = Nothing
  , qrsProductDescription = Nothing
  , qrsProductEffectiveDate = Nothing
  , qrsProductUntilDate = Nothing
  , qrsProductRegistrationStatus = Nothing
  , qrsProductVersion = Nothing
  , qrsProductQrsType = Nothing
  , qrsProductLinks = Nothing
  , qrsProductItems = Nothing
  }

-- ** QrsProductLinks
-- | QrsProductLinks
data QrsProductLinks = QrsProductLinks
  { qrsProductLinksSelf :: !(Maybe QrsProductRef) -- ^ "self"
  , qrsProductLinksPriorVersion :: !(Maybe QrsProductRef) -- ^ "priorVersion"
  , qrsProductLinksQrsTermCat :: !(Maybe RootCtTermRef) -- ^ "qrsTermCAT"
  , qrsProductLinksQrsItems :: !(Maybe QrsItemsRef) -- ^ "qrsItems"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsProductLinks
instance A.FromJSON QrsProductLinks where
  parseJSON = A.withObject "QrsProductLinks" $ \o ->
    QrsProductLinks
      <$> (o .:? "self")
      <*> (o .:? "priorVersion")
      <*> (o .:? "qrsTermCAT")
      <*> (o .:? "qrsItems")

-- | ToJSON QrsProductLinks
instance A.ToJSON QrsProductLinks where
  toJSON QrsProductLinks {..} =
   _omitNulls
      [ "self" .= qrsProductLinksSelf
      , "priorVersion" .= qrsProductLinksPriorVersion
      , "qrsTermCAT" .= qrsProductLinksQrsTermCat
      , "qrsItems" .= qrsProductLinksQrsItems
      ]


-- | Construct a value of type 'QrsProductLinks' (by applying it's required fields, if any)
mkQrsProductLinks
  :: QrsProductLinks
mkQrsProductLinks =
  QrsProductLinks
  { qrsProductLinksSelf = Nothing
  , qrsProductLinksPriorVersion = Nothing
  , qrsProductLinksQrsTermCat = Nothing
  , qrsProductLinksQrsItems = Nothing
  }

-- ** QrsProductRef
-- | QrsProductRef
data QrsProductRef = QrsProductRef
  { qrsProductRefHref :: !(Maybe Text) -- ^ "href"
  , qrsProductRefTitle :: !(Maybe Text) -- ^ "title"
  , qrsProductRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsProductRef
instance A.FromJSON QrsProductRef where
  parseJSON = A.withObject "QrsProductRef" $ \o ->
    QrsProductRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON QrsProductRef
instance A.ToJSON QrsProductRef where
  toJSON QrsProductRef {..} =
   _omitNulls
      [ "href" .= qrsProductRefHref
      , "title" .= qrsProductRefTitle
      , "type" .= qrsProductRefType
      ]


-- | Construct a value of type 'QrsProductRef' (by applying it's required fields, if any)
mkQrsProductRef
  :: QrsProductRef
mkQrsProductRef =
  QrsProductRef
  { qrsProductRefHref = Nothing
  , qrsProductRefTitle = Nothing
  , qrsProductRefType = Nothing
  }

-- ** QrsRefElement
-- | QrsRefElement
data QrsRefElement = QrsRefElement
  { qrsRefElementHref :: !(Maybe Text) -- ^ "href"
  , qrsRefElementTitle :: !(Maybe Text) -- ^ "title"
  , qrsRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsRefElement
instance A.FromJSON QrsRefElement where
  parseJSON = A.withObject "QrsRefElement" $ \o ->
    QrsRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON QrsRefElement
instance A.ToJSON QrsRefElement where
  toJSON QrsRefElement {..} =
   _omitNulls
      [ "href" .= qrsRefElementHref
      , "title" .= qrsRefElementTitle
      , "type" .= qrsRefElementType
      ]


-- | Construct a value of type 'QrsRefElement' (by applying it's required fields, if any)
mkQrsRefElement
  :: QrsRefElement
mkQrsRefElement =
  QrsRefElement
  { qrsRefElementHref = Nothing
  , qrsRefElementTitle = Nothing
  , qrsRefElementType = Nothing
  }

-- ** QrsResponseLinks
-- | QrsResponseLinks
data QrsResponseLinks = QrsResponseLinks
  { qrsResponseLinksQrsResponseOrres :: !(Maybe RootCtTermRef) -- ^ "qrsResponseORRES"
  , qrsResponseLinksQrsResponseOrresu :: !(Maybe RootCtTermRef) -- ^ "qrsResponseORRESU"
  , qrsResponseLinksQrsResponseStresc :: !(Maybe RootCtTermRef) -- ^ "qrsResponseSTRESC"
  , qrsResponseLinksQrsResponseStrescu :: !(Maybe RootCtTermRef) -- ^ "qrsResponseSTRESCU"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsResponseLinks
instance A.FromJSON QrsResponseLinks where
  parseJSON = A.withObject "QrsResponseLinks" $ \o ->
    QrsResponseLinks
      <$> (o .:? "qrsResponseORRES")
      <*> (o .:? "qrsResponseORRESU")
      <*> (o .:? "qrsResponseSTRESC")
      <*> (o .:? "qrsResponseSTRESCU")

-- | ToJSON QrsResponseLinks
instance A.ToJSON QrsResponseLinks where
  toJSON QrsResponseLinks {..} =
   _omitNulls
      [ "qrsResponseORRES" .= qrsResponseLinksQrsResponseOrres
      , "qrsResponseORRESU" .= qrsResponseLinksQrsResponseOrresu
      , "qrsResponseSTRESC" .= qrsResponseLinksQrsResponseStresc
      , "qrsResponseSTRESCU" .= qrsResponseLinksQrsResponseStrescu
      ]


-- | Construct a value of type 'QrsResponseLinks' (by applying it's required fields, if any)
mkQrsResponseLinks
  :: QrsResponseLinks
mkQrsResponseLinks =
  QrsResponseLinks
  { qrsResponseLinksQrsResponseOrres = Nothing
  , qrsResponseLinksQrsResponseOrresu = Nothing
  , qrsResponseLinksQrsResponseStresc = Nothing
  , qrsResponseLinksQrsResponseStrescu = Nothing
  }

-- ** QrsResponsegroup
-- | QrsResponsegroup
data QrsResponsegroup = QrsResponsegroup
  { qrsResponsegroupLabel :: !(Maybe Text) -- ^ "label"
  , qrsResponsegroupLinks :: !(Maybe QrsResponsegroupLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsResponsegroup
instance A.FromJSON QrsResponsegroup where
  parseJSON = A.withObject "QrsResponsegroup" $ \o ->
    QrsResponsegroup
      <$> (o .:? "label")
      <*> (o .:? "_links")

-- | ToJSON QrsResponsegroup
instance A.ToJSON QrsResponsegroup where
  toJSON QrsResponsegroup {..} =
   _omitNulls
      [ "label" .= qrsResponsegroupLabel
      , "_links" .= qrsResponsegroupLinks
      ]


-- | Construct a value of type 'QrsResponsegroup' (by applying it's required fields, if any)
mkQrsResponsegroup
  :: QrsResponsegroup
mkQrsResponsegroup =
  QrsResponsegroup
  { qrsResponsegroupLabel = Nothing
  , qrsResponsegroupLinks = Nothing
  }

-- ** QrsResponsegroupLinks
-- | QrsResponsegroupLinks
data QrsResponsegroupLinks = QrsResponsegroupLinks
  { qrsResponsegroupLinksSelf :: !(Maybe QrsResponsegroupRef) -- ^ "self"
  , qrsResponsegroupLinksResponses :: !(Maybe [QrsResponses]) -- ^ "responses"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsResponsegroupLinks
instance A.FromJSON QrsResponsegroupLinks where
  parseJSON = A.withObject "QrsResponsegroupLinks" $ \o ->
    QrsResponsegroupLinks
      <$> (o .:? "self")
      <*> (o .:? "responses")

-- | ToJSON QrsResponsegroupLinks
instance A.ToJSON QrsResponsegroupLinks where
  toJSON QrsResponsegroupLinks {..} =
   _omitNulls
      [ "self" .= qrsResponsegroupLinksSelf
      , "responses" .= qrsResponsegroupLinksResponses
      ]


-- | Construct a value of type 'QrsResponsegroupLinks' (by applying it's required fields, if any)
mkQrsResponsegroupLinks
  :: QrsResponsegroupLinks
mkQrsResponsegroupLinks =
  QrsResponsegroupLinks
  { qrsResponsegroupLinksSelf = Nothing
  , qrsResponsegroupLinksResponses = Nothing
  }

-- ** QrsResponsegroupRef
-- | QrsResponsegroupRef
data QrsResponsegroupRef = QrsResponsegroupRef
  { qrsResponsegroupRefHref :: !(Maybe Text) -- ^ "href"
  , qrsResponsegroupRefTitle :: !(Maybe Text) -- ^ "title"
  , qrsResponsegroupRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsResponsegroupRef
instance A.FromJSON QrsResponsegroupRef where
  parseJSON = A.withObject "QrsResponsegroupRef" $ \o ->
    QrsResponsegroupRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON QrsResponsegroupRef
instance A.ToJSON QrsResponsegroupRef where
  toJSON QrsResponsegroupRef {..} =
   _omitNulls
      [ "href" .= qrsResponsegroupRefHref
      , "title" .= qrsResponsegroupRefTitle
      , "type" .= qrsResponsegroupRefType
      ]


-- | Construct a value of type 'QrsResponsegroupRef' (by applying it's required fields, if any)
mkQrsResponsegroupRef
  :: QrsResponsegroupRef
mkQrsResponsegroupRef =
  QrsResponsegroupRef
  { qrsResponsegroupRefHref = Nothing
  , qrsResponsegroupRefTitle = Nothing
  , qrsResponsegroupRefType = Nothing
  }

-- ** QrsResponsegroupRefElement
-- | QrsResponsegroupRefElement
data QrsResponsegroupRefElement = QrsResponsegroupRefElement
  { qrsResponsegroupRefElementHref :: !(Maybe Text) -- ^ "href"
  , qrsResponsegroupRefElementTitle :: !(Maybe Text) -- ^ "title"
  , qrsResponsegroupRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsResponsegroupRefElement
instance A.FromJSON QrsResponsegroupRefElement where
  parseJSON = A.withObject "QrsResponsegroupRefElement" $ \o ->
    QrsResponsegroupRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON QrsResponsegroupRefElement
instance A.ToJSON QrsResponsegroupRefElement where
  toJSON QrsResponsegroupRefElement {..} =
   _omitNulls
      [ "href" .= qrsResponsegroupRefElementHref
      , "title" .= qrsResponsegroupRefElementTitle
      , "type" .= qrsResponsegroupRefElementType
      ]


-- | Construct a value of type 'QrsResponsegroupRefElement' (by applying it's required fields, if any)
mkQrsResponsegroupRefElement
  :: QrsResponsegroupRefElement
mkQrsResponsegroupRefElement =
  QrsResponsegroupRefElement
  { qrsResponsegroupRefElementHref = Nothing
  , qrsResponsegroupRefElementTitle = Nothing
  , qrsResponsegroupRefElementType = Nothing
  }

-- ** QrsResponsegroups
-- | QrsResponsegroups
data QrsResponsegroups = QrsResponsegroups
  { qrsResponsegroupsName :: !(Maybe Text) -- ^ "name"
  , qrsResponsegroupsLabel :: !(Maybe Text) -- ^ "label"
  , qrsResponsegroupsDescription :: !(Maybe Text) -- ^ "description"
  , qrsResponsegroupsEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , qrsResponsegroupsUntilDate :: !(Maybe Text) -- ^ "untilDate"
  , qrsResponsegroupsRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , qrsResponsegroupsVersion :: !(Maybe Text) -- ^ "version"
  , qrsResponsegroupsQrsType :: !(Maybe Text) -- ^ "qrsType"
  , qrsResponsegroupsLinks :: !(Maybe QrsResponsegroupsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsResponsegroups
instance A.FromJSON QrsResponsegroups where
  parseJSON = A.withObject "QrsResponsegroups" $ \o ->
    QrsResponsegroups
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "untilDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "qrsType")
      <*> (o .:? "_links")

-- | ToJSON QrsResponsegroups
instance A.ToJSON QrsResponsegroups where
  toJSON QrsResponsegroups {..} =
   _omitNulls
      [ "name" .= qrsResponsegroupsName
      , "label" .= qrsResponsegroupsLabel
      , "description" .= qrsResponsegroupsDescription
      , "effectiveDate" .= qrsResponsegroupsEffectiveDate
      , "untilDate" .= qrsResponsegroupsUntilDate
      , "registrationStatus" .= qrsResponsegroupsRegistrationStatus
      , "version" .= qrsResponsegroupsVersion
      , "qrsType" .= qrsResponsegroupsQrsType
      , "_links" .= qrsResponsegroupsLinks
      ]


-- | Construct a value of type 'QrsResponsegroups' (by applying it's required fields, if any)
mkQrsResponsegroups
  :: QrsResponsegroups
mkQrsResponsegroups =
  QrsResponsegroups
  { qrsResponsegroupsName = Nothing
  , qrsResponsegroupsLabel = Nothing
  , qrsResponsegroupsDescription = Nothing
  , qrsResponsegroupsEffectiveDate = Nothing
  , qrsResponsegroupsUntilDate = Nothing
  , qrsResponsegroupsRegistrationStatus = Nothing
  , qrsResponsegroupsVersion = Nothing
  , qrsResponsegroupsQrsType = Nothing
  , qrsResponsegroupsLinks = Nothing
  }

-- ** QrsResponsegroupsLinks
-- | QrsResponsegroupsLinks
data QrsResponsegroupsLinks = QrsResponsegroupsLinks
  { qrsResponsegroupsLinksSelf :: !(Maybe QrsResponsegroupsRef) -- ^ "self"
  , qrsResponsegroupsLinksResponsegroups :: !(Maybe [QrsResponsegroupRefElement]) -- ^ "responsegroups"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsResponsegroupsLinks
instance A.FromJSON QrsResponsegroupsLinks where
  parseJSON = A.withObject "QrsResponsegroupsLinks" $ \o ->
    QrsResponsegroupsLinks
      <$> (o .:? "self")
      <*> (o .:? "responsegroups")

-- | ToJSON QrsResponsegroupsLinks
instance A.ToJSON QrsResponsegroupsLinks where
  toJSON QrsResponsegroupsLinks {..} =
   _omitNulls
      [ "self" .= qrsResponsegroupsLinksSelf
      , "responsegroups" .= qrsResponsegroupsLinksResponsegroups
      ]


-- | Construct a value of type 'QrsResponsegroupsLinks' (by applying it's required fields, if any)
mkQrsResponsegroupsLinks
  :: QrsResponsegroupsLinks
mkQrsResponsegroupsLinks =
  QrsResponsegroupsLinks
  { qrsResponsegroupsLinksSelf = Nothing
  , qrsResponsegroupsLinksResponsegroups = Nothing
  }

-- ** QrsResponsegroupsRef
-- | QrsResponsegroupsRef
data QrsResponsegroupsRef = QrsResponsegroupsRef
  { qrsResponsegroupsRefHref :: !(Maybe Text) -- ^ "href"
  , qrsResponsegroupsRefTitle :: !(Maybe Text) -- ^ "title"
  , qrsResponsegroupsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsResponsegroupsRef
instance A.FromJSON QrsResponsegroupsRef where
  parseJSON = A.withObject "QrsResponsegroupsRef" $ \o ->
    QrsResponsegroupsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON QrsResponsegroupsRef
instance A.ToJSON QrsResponsegroupsRef where
  toJSON QrsResponsegroupsRef {..} =
   _omitNulls
      [ "href" .= qrsResponsegroupsRefHref
      , "title" .= qrsResponsegroupsRefTitle
      , "type" .= qrsResponsegroupsRefType
      ]


-- | Construct a value of type 'QrsResponsegroupsRef' (by applying it's required fields, if any)
mkQrsResponsegroupsRef
  :: QrsResponsegroupsRef
mkQrsResponsegroupsRef =
  QrsResponsegroupsRef
  { qrsResponsegroupsRefHref = Nothing
  , qrsResponsegroupsRefTitle = Nothing
  , qrsResponsegroupsRefType = Nothing
  }

-- ** QrsResponses
-- | QrsResponses
data QrsResponses = QrsResponses
  { qrsResponsesOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , qrsResponsesLinks :: !(Maybe QrsResponseLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QrsResponses
instance A.FromJSON QrsResponses where
  parseJSON = A.withObject "QrsResponses" $ \o ->
    QrsResponses
      <$> (o .:? "ordinal")
      <*> (o .:? "_links")

-- | ToJSON QrsResponses
instance A.ToJSON QrsResponses where
  toJSON QrsResponses {..} =
   _omitNulls
      [ "ordinal" .= qrsResponsesOrdinal
      , "_links" .= qrsResponsesLinks
      ]


-- | Construct a value of type 'QrsResponses' (by applying it's required fields, if any)
mkQrsResponses
  :: QrsResponses
mkQrsResponses =
  QrsResponses
  { qrsResponsesOrdinal = Nothing
  , qrsResponsesLinks = Nothing
  }

-- ** RootCdashClassField
-- | RootCdashClassField
data RootCdashClassField = RootCdashClassField
  { rootCdashClassFieldLinks :: !(Maybe RootCdashClassFieldLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCdashClassField
instance A.FromJSON RootCdashClassField where
  parseJSON = A.withObject "RootCdashClassField" $ \o ->
    RootCdashClassField
      <$> (o .:? "_links")

-- | ToJSON RootCdashClassField
instance A.ToJSON RootCdashClassField where
  toJSON RootCdashClassField {..} =
   _omitNulls
      [ "_links" .= rootCdashClassFieldLinks
      ]


-- | Construct a value of type 'RootCdashClassField' (by applying it's required fields, if any)
mkRootCdashClassField
  :: RootCdashClassField
mkRootCdashClassField =
  RootCdashClassField
  { rootCdashClassFieldLinks = Nothing
  }

-- ** RootCdashClassFieldLinks
-- | RootCdashClassFieldLinks
data RootCdashClassFieldLinks = RootCdashClassFieldLinks
  { rootCdashClassFieldLinksSelf :: !(Maybe RootCdashClassFieldRef) -- ^ "self"
  , rootCdashClassFieldLinksVersions :: !(Maybe [CdashClassFieldRefVersion]) -- ^ "versions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCdashClassFieldLinks
instance A.FromJSON RootCdashClassFieldLinks where
  parseJSON = A.withObject "RootCdashClassFieldLinks" $ \o ->
    RootCdashClassFieldLinks
      <$> (o .:? "self")
      <*> (o .:? "versions")

-- | ToJSON RootCdashClassFieldLinks
instance A.ToJSON RootCdashClassFieldLinks where
  toJSON RootCdashClassFieldLinks {..} =
   _omitNulls
      [ "self" .= rootCdashClassFieldLinksSelf
      , "versions" .= rootCdashClassFieldLinksVersions
      ]


-- | Construct a value of type 'RootCdashClassFieldLinks' (by applying it's required fields, if any)
mkRootCdashClassFieldLinks
  :: RootCdashClassFieldLinks
mkRootCdashClassFieldLinks =
  RootCdashClassFieldLinks
  { rootCdashClassFieldLinksSelf = Nothing
  , rootCdashClassFieldLinksVersions = Nothing
  }

-- ** RootCdashClassFieldRef
-- | RootCdashClassFieldRef
data RootCdashClassFieldRef = RootCdashClassFieldRef
  { rootCdashClassFieldRefHref :: !(Maybe Text) -- ^ "href"
  , rootCdashClassFieldRefTitle :: !(Maybe Text) -- ^ "title"
  , rootCdashClassFieldRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCdashClassFieldRef
instance A.FromJSON RootCdashClassFieldRef where
  parseJSON = A.withObject "RootCdashClassFieldRef" $ \o ->
    RootCdashClassFieldRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON RootCdashClassFieldRef
instance A.ToJSON RootCdashClassFieldRef where
  toJSON RootCdashClassFieldRef {..} =
   _omitNulls
      [ "href" .= rootCdashClassFieldRefHref
      , "title" .= rootCdashClassFieldRefTitle
      , "type" .= rootCdashClassFieldRefType
      ]


-- | Construct a value of type 'RootCdashClassFieldRef' (by applying it's required fields, if any)
mkRootCdashClassFieldRef
  :: RootCdashClassFieldRef
mkRootCdashClassFieldRef =
  RootCdashClassFieldRef
  { rootCdashClassFieldRefHref = Nothing
  , rootCdashClassFieldRefTitle = Nothing
  , rootCdashClassFieldRefType = Nothing
  }

-- ** RootCdashDomainField
-- | RootCdashDomainField
data RootCdashDomainField = RootCdashDomainField
  { rootCdashDomainFieldLinks :: !(Maybe RootCdashDomainFieldLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCdashDomainField
instance A.FromJSON RootCdashDomainField where
  parseJSON = A.withObject "RootCdashDomainField" $ \o ->
    RootCdashDomainField
      <$> (o .:? "_links")

-- | ToJSON RootCdashDomainField
instance A.ToJSON RootCdashDomainField where
  toJSON RootCdashDomainField {..} =
   _omitNulls
      [ "_links" .= rootCdashDomainFieldLinks
      ]


-- | Construct a value of type 'RootCdashDomainField' (by applying it's required fields, if any)
mkRootCdashDomainField
  :: RootCdashDomainField
mkRootCdashDomainField =
  RootCdashDomainField
  { rootCdashDomainFieldLinks = Nothing
  }

-- ** RootCdashDomainFieldLinks
-- | RootCdashDomainFieldLinks
data RootCdashDomainFieldLinks = RootCdashDomainFieldLinks
  { rootCdashDomainFieldLinksSelf :: !(Maybe RootCdashDomainFieldRef) -- ^ "self"
  , rootCdashDomainFieldLinksVersions :: !(Maybe [CdashDomainFieldRefVersion]) -- ^ "versions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCdashDomainFieldLinks
instance A.FromJSON RootCdashDomainFieldLinks where
  parseJSON = A.withObject "RootCdashDomainFieldLinks" $ \o ->
    RootCdashDomainFieldLinks
      <$> (o .:? "self")
      <*> (o .:? "versions")

-- | ToJSON RootCdashDomainFieldLinks
instance A.ToJSON RootCdashDomainFieldLinks where
  toJSON RootCdashDomainFieldLinks {..} =
   _omitNulls
      [ "self" .= rootCdashDomainFieldLinksSelf
      , "versions" .= rootCdashDomainFieldLinksVersions
      ]


-- | Construct a value of type 'RootCdashDomainFieldLinks' (by applying it's required fields, if any)
mkRootCdashDomainFieldLinks
  :: RootCdashDomainFieldLinks
mkRootCdashDomainFieldLinks =
  RootCdashDomainFieldLinks
  { rootCdashDomainFieldLinksSelf = Nothing
  , rootCdashDomainFieldLinksVersions = Nothing
  }

-- ** RootCdashDomainFieldRef
-- | RootCdashDomainFieldRef
data RootCdashDomainFieldRef = RootCdashDomainFieldRef
  { rootCdashDomainFieldRefHref :: !(Maybe Text) -- ^ "href"
  , rootCdashDomainFieldRefTitle :: !(Maybe Text) -- ^ "title"
  , rootCdashDomainFieldRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCdashDomainFieldRef
instance A.FromJSON RootCdashDomainFieldRef where
  parseJSON = A.withObject "RootCdashDomainFieldRef" $ \o ->
    RootCdashDomainFieldRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON RootCdashDomainFieldRef
instance A.ToJSON RootCdashDomainFieldRef where
  toJSON RootCdashDomainFieldRef {..} =
   _omitNulls
      [ "href" .= rootCdashDomainFieldRefHref
      , "title" .= rootCdashDomainFieldRefTitle
      , "type" .= rootCdashDomainFieldRefType
      ]


-- | Construct a value of type 'RootCdashDomainFieldRef' (by applying it's required fields, if any)
mkRootCdashDomainFieldRef
  :: RootCdashDomainFieldRef
mkRootCdashDomainFieldRef =
  RootCdashDomainFieldRef
  { rootCdashDomainFieldRefHref = Nothing
  , rootCdashDomainFieldRefTitle = Nothing
  , rootCdashDomainFieldRefType = Nothing
  }

-- ** RootCdashigDomainField
-- | RootCdashigDomainField
data RootCdashigDomainField = RootCdashigDomainField
  { rootCdashigDomainFieldLinks :: !(Maybe RootCdashigDomainFieldLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCdashigDomainField
instance A.FromJSON RootCdashigDomainField where
  parseJSON = A.withObject "RootCdashigDomainField" $ \o ->
    RootCdashigDomainField
      <$> (o .:? "_links")

-- | ToJSON RootCdashigDomainField
instance A.ToJSON RootCdashigDomainField where
  toJSON RootCdashigDomainField {..} =
   _omitNulls
      [ "_links" .= rootCdashigDomainFieldLinks
      ]


-- | Construct a value of type 'RootCdashigDomainField' (by applying it's required fields, if any)
mkRootCdashigDomainField
  :: RootCdashigDomainField
mkRootCdashigDomainField =
  RootCdashigDomainField
  { rootCdashigDomainFieldLinks = Nothing
  }

-- ** RootCdashigDomainFieldLinks
-- | RootCdashigDomainFieldLinks
data RootCdashigDomainFieldLinks = RootCdashigDomainFieldLinks
  { rootCdashigDomainFieldLinksSelf :: !(Maybe RootCdashigDomainFieldRef) -- ^ "self"
  , rootCdashigDomainFieldLinksVersions :: !(Maybe [CdashigDomainFieldRefVersion]) -- ^ "versions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCdashigDomainFieldLinks
instance A.FromJSON RootCdashigDomainFieldLinks where
  parseJSON = A.withObject "RootCdashigDomainFieldLinks" $ \o ->
    RootCdashigDomainFieldLinks
      <$> (o .:? "self")
      <*> (o .:? "versions")

-- | ToJSON RootCdashigDomainFieldLinks
instance A.ToJSON RootCdashigDomainFieldLinks where
  toJSON RootCdashigDomainFieldLinks {..} =
   _omitNulls
      [ "self" .= rootCdashigDomainFieldLinksSelf
      , "versions" .= rootCdashigDomainFieldLinksVersions
      ]


-- | Construct a value of type 'RootCdashigDomainFieldLinks' (by applying it's required fields, if any)
mkRootCdashigDomainFieldLinks
  :: RootCdashigDomainFieldLinks
mkRootCdashigDomainFieldLinks =
  RootCdashigDomainFieldLinks
  { rootCdashigDomainFieldLinksSelf = Nothing
  , rootCdashigDomainFieldLinksVersions = Nothing
  }

-- ** RootCdashigDomainFieldRef
-- | RootCdashigDomainFieldRef
data RootCdashigDomainFieldRef = RootCdashigDomainFieldRef
  { rootCdashigDomainFieldRefHref :: !(Maybe Text) -- ^ "href"
  , rootCdashigDomainFieldRefTitle :: !(Maybe Text) -- ^ "title"
  , rootCdashigDomainFieldRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCdashigDomainFieldRef
instance A.FromJSON RootCdashigDomainFieldRef where
  parseJSON = A.withObject "RootCdashigDomainFieldRef" $ \o ->
    RootCdashigDomainFieldRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON RootCdashigDomainFieldRef
instance A.ToJSON RootCdashigDomainFieldRef where
  toJSON RootCdashigDomainFieldRef {..} =
   _omitNulls
      [ "href" .= rootCdashigDomainFieldRefHref
      , "title" .= rootCdashigDomainFieldRefTitle
      , "type" .= rootCdashigDomainFieldRefType
      ]


-- | Construct a value of type 'RootCdashigDomainFieldRef' (by applying it's required fields, if any)
mkRootCdashigDomainFieldRef
  :: RootCdashigDomainFieldRef
mkRootCdashigDomainFieldRef =
  RootCdashigDomainFieldRef
  { rootCdashigDomainFieldRefHref = Nothing
  , rootCdashigDomainFieldRefTitle = Nothing
  , rootCdashigDomainFieldRefType = Nothing
  }

-- ** RootCdashigScenarioField
-- | RootCdashigScenarioField
data RootCdashigScenarioField = RootCdashigScenarioField
  { rootCdashigScenarioFieldLinks :: !(Maybe RootCdashigScenarioFieldLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCdashigScenarioField
instance A.FromJSON RootCdashigScenarioField where
  parseJSON = A.withObject "RootCdashigScenarioField" $ \o ->
    RootCdashigScenarioField
      <$> (o .:? "_links")

-- | ToJSON RootCdashigScenarioField
instance A.ToJSON RootCdashigScenarioField where
  toJSON RootCdashigScenarioField {..} =
   _omitNulls
      [ "_links" .= rootCdashigScenarioFieldLinks
      ]


-- | Construct a value of type 'RootCdashigScenarioField' (by applying it's required fields, if any)
mkRootCdashigScenarioField
  :: RootCdashigScenarioField
mkRootCdashigScenarioField =
  RootCdashigScenarioField
  { rootCdashigScenarioFieldLinks = Nothing
  }

-- ** RootCdashigScenarioFieldLinks
-- | RootCdashigScenarioFieldLinks
data RootCdashigScenarioFieldLinks = RootCdashigScenarioFieldLinks
  { rootCdashigScenarioFieldLinksSelf :: !(Maybe RootCdashigScenarioFieldRef) -- ^ "self"
  , rootCdashigScenarioFieldLinksVersions :: !(Maybe [CdashigScenarioFieldRefVersion]) -- ^ "versions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCdashigScenarioFieldLinks
instance A.FromJSON RootCdashigScenarioFieldLinks where
  parseJSON = A.withObject "RootCdashigScenarioFieldLinks" $ \o ->
    RootCdashigScenarioFieldLinks
      <$> (o .:? "self")
      <*> (o .:? "versions")

-- | ToJSON RootCdashigScenarioFieldLinks
instance A.ToJSON RootCdashigScenarioFieldLinks where
  toJSON RootCdashigScenarioFieldLinks {..} =
   _omitNulls
      [ "self" .= rootCdashigScenarioFieldLinksSelf
      , "versions" .= rootCdashigScenarioFieldLinksVersions
      ]


-- | Construct a value of type 'RootCdashigScenarioFieldLinks' (by applying it's required fields, if any)
mkRootCdashigScenarioFieldLinks
  :: RootCdashigScenarioFieldLinks
mkRootCdashigScenarioFieldLinks =
  RootCdashigScenarioFieldLinks
  { rootCdashigScenarioFieldLinksSelf = Nothing
  , rootCdashigScenarioFieldLinksVersions = Nothing
  }

-- ** RootCdashigScenarioFieldRef
-- | RootCdashigScenarioFieldRef
data RootCdashigScenarioFieldRef = RootCdashigScenarioFieldRef
  { rootCdashigScenarioFieldRefHref :: !(Maybe Text) -- ^ "href"
  , rootCdashigScenarioFieldRefTitle :: !(Maybe Text) -- ^ "title"
  , rootCdashigScenarioFieldRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCdashigScenarioFieldRef
instance A.FromJSON RootCdashigScenarioFieldRef where
  parseJSON = A.withObject "RootCdashigScenarioFieldRef" $ \o ->
    RootCdashigScenarioFieldRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON RootCdashigScenarioFieldRef
instance A.ToJSON RootCdashigScenarioFieldRef where
  toJSON RootCdashigScenarioFieldRef {..} =
   _omitNulls
      [ "href" .= rootCdashigScenarioFieldRefHref
      , "title" .= rootCdashigScenarioFieldRefTitle
      , "type" .= rootCdashigScenarioFieldRefType
      ]


-- | Construct a value of type 'RootCdashigScenarioFieldRef' (by applying it's required fields, if any)
mkRootCdashigScenarioFieldRef
  :: RootCdashigScenarioFieldRef
mkRootCdashigScenarioFieldRef =
  RootCdashigScenarioFieldRef
  { rootCdashigScenarioFieldRefHref = Nothing
  , rootCdashigScenarioFieldRefTitle = Nothing
  , rootCdashigScenarioFieldRefType = Nothing
  }

-- ** RootCtCodelist
-- | RootCtCodelist
data RootCtCodelist = RootCtCodelist
  { rootCtCodelistLinks :: !(Maybe RootCtCodelistLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCtCodelist
instance A.FromJSON RootCtCodelist where
  parseJSON = A.withObject "RootCtCodelist" $ \o ->
    RootCtCodelist
      <$> (o .:? "_links")

-- | ToJSON RootCtCodelist
instance A.ToJSON RootCtCodelist where
  toJSON RootCtCodelist {..} =
   _omitNulls
      [ "_links" .= rootCtCodelistLinks
      ]


-- | Construct a value of type 'RootCtCodelist' (by applying it's required fields, if any)
mkRootCtCodelist
  :: RootCtCodelist
mkRootCtCodelist =
  RootCtCodelist
  { rootCtCodelistLinks = Nothing
  }

-- ** RootCtCodelistLinks
-- | RootCtCodelistLinks
data RootCtCodelistLinks = RootCtCodelistLinks
  { rootCtCodelistLinksSelf :: !(Maybe RootCtCodelistRef) -- ^ "self"
  , rootCtCodelistLinksVersions :: !(Maybe [CtCodelistRefVersion]) -- ^ "versions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCtCodelistLinks
instance A.FromJSON RootCtCodelistLinks where
  parseJSON = A.withObject "RootCtCodelistLinks" $ \o ->
    RootCtCodelistLinks
      <$> (o .:? "self")
      <*> (o .:? "versions")

-- | ToJSON RootCtCodelistLinks
instance A.ToJSON RootCtCodelistLinks where
  toJSON RootCtCodelistLinks {..} =
   _omitNulls
      [ "self" .= rootCtCodelistLinksSelf
      , "versions" .= rootCtCodelistLinksVersions
      ]


-- | Construct a value of type 'RootCtCodelistLinks' (by applying it's required fields, if any)
mkRootCtCodelistLinks
  :: RootCtCodelistLinks
mkRootCtCodelistLinks =
  RootCtCodelistLinks
  { rootCtCodelistLinksSelf = Nothing
  , rootCtCodelistLinksVersions = Nothing
  }

-- ** RootCtCodelistRef
-- | RootCtCodelistRef
data RootCtCodelistRef = RootCtCodelistRef
  { rootCtCodelistRefHref :: !(Maybe Text) -- ^ "href"
  , rootCtCodelistRefTitle :: !(Maybe Text) -- ^ "title"
  , rootCtCodelistRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCtCodelistRef
instance A.FromJSON RootCtCodelistRef where
  parseJSON = A.withObject "RootCtCodelistRef" $ \o ->
    RootCtCodelistRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON RootCtCodelistRef
instance A.ToJSON RootCtCodelistRef where
  toJSON RootCtCodelistRef {..} =
   _omitNulls
      [ "href" .= rootCtCodelistRefHref
      , "title" .= rootCtCodelistRefTitle
      , "type" .= rootCtCodelistRefType
      ]


-- | Construct a value of type 'RootCtCodelistRef' (by applying it's required fields, if any)
mkRootCtCodelistRef
  :: RootCtCodelistRef
mkRootCtCodelistRef =
  RootCtCodelistRef
  { rootCtCodelistRefHref = Nothing
  , rootCtCodelistRefTitle = Nothing
  , rootCtCodelistRefType = Nothing
  }

-- ** RootCtCodelistRefElement
-- | RootCtCodelistRefElement
data RootCtCodelistRefElement = RootCtCodelistRefElement
  { rootCtCodelistRefElementHref :: !(Maybe Text) -- ^ "href"
  , rootCtCodelistRefElementTitle :: !(Maybe Text) -- ^ "title"
  , rootCtCodelistRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCtCodelistRefElement
instance A.FromJSON RootCtCodelistRefElement where
  parseJSON = A.withObject "RootCtCodelistRefElement" $ \o ->
    RootCtCodelistRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON RootCtCodelistRefElement
instance A.ToJSON RootCtCodelistRefElement where
  toJSON RootCtCodelistRefElement {..} =
   _omitNulls
      [ "href" .= rootCtCodelistRefElementHref
      , "title" .= rootCtCodelistRefElementTitle
      , "type" .= rootCtCodelistRefElementType
      ]


-- | Construct a value of type 'RootCtCodelistRefElement' (by applying it's required fields, if any)
mkRootCtCodelistRefElement
  :: RootCtCodelistRefElement
mkRootCtCodelistRefElement =
  RootCtCodelistRefElement
  { rootCtCodelistRefElementHref = Nothing
  , rootCtCodelistRefElementTitle = Nothing
  , rootCtCodelistRefElementType = Nothing
  }

-- ** RootCtTerm
-- | RootCtTerm
data RootCtTerm = RootCtTerm
  { rootCtTermLinks :: !(Maybe RootCtTermLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCtTerm
instance A.FromJSON RootCtTerm where
  parseJSON = A.withObject "RootCtTerm" $ \o ->
    RootCtTerm
      <$> (o .:? "_links")

-- | ToJSON RootCtTerm
instance A.ToJSON RootCtTerm where
  toJSON RootCtTerm {..} =
   _omitNulls
      [ "_links" .= rootCtTermLinks
      ]


-- | Construct a value of type 'RootCtTerm' (by applying it's required fields, if any)
mkRootCtTerm
  :: RootCtTerm
mkRootCtTerm =
  RootCtTerm
  { rootCtTermLinks = Nothing
  }

-- ** RootCtTermLinks
-- | RootCtTermLinks
data RootCtTermLinks = RootCtTermLinks
  { rootCtTermLinksSelf :: !(Maybe RootCtTermRef) -- ^ "self"
  , rootCtTermLinksVersions :: !(Maybe [CtTermRefVersion]) -- ^ "versions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCtTermLinks
instance A.FromJSON RootCtTermLinks where
  parseJSON = A.withObject "RootCtTermLinks" $ \o ->
    RootCtTermLinks
      <$> (o .:? "self")
      <*> (o .:? "versions")

-- | ToJSON RootCtTermLinks
instance A.ToJSON RootCtTermLinks where
  toJSON RootCtTermLinks {..} =
   _omitNulls
      [ "self" .= rootCtTermLinksSelf
      , "versions" .= rootCtTermLinksVersions
      ]


-- | Construct a value of type 'RootCtTermLinks' (by applying it's required fields, if any)
mkRootCtTermLinks
  :: RootCtTermLinks
mkRootCtTermLinks =
  RootCtTermLinks
  { rootCtTermLinksSelf = Nothing
  , rootCtTermLinksVersions = Nothing
  }

-- ** RootCtTermRef
-- | RootCtTermRef
data RootCtTermRef = RootCtTermRef
  { rootCtTermRefHref :: !(Maybe Text) -- ^ "href"
  , rootCtTermRefTitle :: !(Maybe Text) -- ^ "title"
  , rootCtTermRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootCtTermRef
instance A.FromJSON RootCtTermRef where
  parseJSON = A.withObject "RootCtTermRef" $ \o ->
    RootCtTermRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON RootCtTermRef
instance A.ToJSON RootCtTermRef where
  toJSON RootCtTermRef {..} =
   _omitNulls
      [ "href" .= rootCtTermRefHref
      , "title" .= rootCtTermRefTitle
      , "type" .= rootCtTermRefType
      ]


-- | Construct a value of type 'RootCtTermRef' (by applying it's required fields, if any)
mkRootCtTermRef
  :: RootCtTermRef
mkRootCtTermRef =
  RootCtTermRef
  { rootCtTermRefHref = Nothing
  , rootCtTermRefTitle = Nothing
  , rootCtTermRefType = Nothing
  }

-- ** RootSdtmClassVariable
-- | RootSdtmClassVariable
data RootSdtmClassVariable = RootSdtmClassVariable
  { rootSdtmClassVariableLinks :: !(Maybe RootSdtmClassVariableLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootSdtmClassVariable
instance A.FromJSON RootSdtmClassVariable where
  parseJSON = A.withObject "RootSdtmClassVariable" $ \o ->
    RootSdtmClassVariable
      <$> (o .:? "_links")

-- | ToJSON RootSdtmClassVariable
instance A.ToJSON RootSdtmClassVariable where
  toJSON RootSdtmClassVariable {..} =
   _omitNulls
      [ "_links" .= rootSdtmClassVariableLinks
      ]


-- | Construct a value of type 'RootSdtmClassVariable' (by applying it's required fields, if any)
mkRootSdtmClassVariable
  :: RootSdtmClassVariable
mkRootSdtmClassVariable =
  RootSdtmClassVariable
  { rootSdtmClassVariableLinks = Nothing
  }

-- ** RootSdtmClassVariableLinks
-- | RootSdtmClassVariableLinks
data RootSdtmClassVariableLinks = RootSdtmClassVariableLinks
  { rootSdtmClassVariableLinksSelf :: !(Maybe RootSdtmClassVariableRef) -- ^ "self"
  , rootSdtmClassVariableLinksVersions :: !(Maybe [SdtmClassVariableRefVersion]) -- ^ "versions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootSdtmClassVariableLinks
instance A.FromJSON RootSdtmClassVariableLinks where
  parseJSON = A.withObject "RootSdtmClassVariableLinks" $ \o ->
    RootSdtmClassVariableLinks
      <$> (o .:? "self")
      <*> (o .:? "versions")

-- | ToJSON RootSdtmClassVariableLinks
instance A.ToJSON RootSdtmClassVariableLinks where
  toJSON RootSdtmClassVariableLinks {..} =
   _omitNulls
      [ "self" .= rootSdtmClassVariableLinksSelf
      , "versions" .= rootSdtmClassVariableLinksVersions
      ]


-- | Construct a value of type 'RootSdtmClassVariableLinks' (by applying it's required fields, if any)
mkRootSdtmClassVariableLinks
  :: RootSdtmClassVariableLinks
mkRootSdtmClassVariableLinks =
  RootSdtmClassVariableLinks
  { rootSdtmClassVariableLinksSelf = Nothing
  , rootSdtmClassVariableLinksVersions = Nothing
  }

-- ** RootSdtmClassVariableRef
-- | RootSdtmClassVariableRef
data RootSdtmClassVariableRef = RootSdtmClassVariableRef
  { rootSdtmClassVariableRefHref :: !(Maybe Text) -- ^ "href"
  , rootSdtmClassVariableRefTitle :: !(Maybe Text) -- ^ "title"
  , rootSdtmClassVariableRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootSdtmClassVariableRef
instance A.FromJSON RootSdtmClassVariableRef where
  parseJSON = A.withObject "RootSdtmClassVariableRef" $ \o ->
    RootSdtmClassVariableRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON RootSdtmClassVariableRef
instance A.ToJSON RootSdtmClassVariableRef where
  toJSON RootSdtmClassVariableRef {..} =
   _omitNulls
      [ "href" .= rootSdtmClassVariableRefHref
      , "title" .= rootSdtmClassVariableRefTitle
      , "type" .= rootSdtmClassVariableRefType
      ]


-- | Construct a value of type 'RootSdtmClassVariableRef' (by applying it's required fields, if any)
mkRootSdtmClassVariableRef
  :: RootSdtmClassVariableRef
mkRootSdtmClassVariableRef =
  RootSdtmClassVariableRef
  { rootSdtmClassVariableRefHref = Nothing
  , rootSdtmClassVariableRefTitle = Nothing
  , rootSdtmClassVariableRefType = Nothing
  }

-- ** RootSdtmDatasetVariable
-- | RootSdtmDatasetVariable
data RootSdtmDatasetVariable = RootSdtmDatasetVariable
  { rootSdtmDatasetVariableLinks :: !(Maybe RootSdtmDatasetVariableLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootSdtmDatasetVariable
instance A.FromJSON RootSdtmDatasetVariable where
  parseJSON = A.withObject "RootSdtmDatasetVariable" $ \o ->
    RootSdtmDatasetVariable
      <$> (o .:? "_links")

-- | ToJSON RootSdtmDatasetVariable
instance A.ToJSON RootSdtmDatasetVariable where
  toJSON RootSdtmDatasetVariable {..} =
   _omitNulls
      [ "_links" .= rootSdtmDatasetVariableLinks
      ]


-- | Construct a value of type 'RootSdtmDatasetVariable' (by applying it's required fields, if any)
mkRootSdtmDatasetVariable
  :: RootSdtmDatasetVariable
mkRootSdtmDatasetVariable =
  RootSdtmDatasetVariable
  { rootSdtmDatasetVariableLinks = Nothing
  }

-- ** RootSdtmDatasetVariableLinks
-- | RootSdtmDatasetVariableLinks
data RootSdtmDatasetVariableLinks = RootSdtmDatasetVariableLinks
  { rootSdtmDatasetVariableLinksSelf :: !(Maybe RootSdtmDatasetVariableRef) -- ^ "self"
  , rootSdtmDatasetVariableLinksVersions :: !(Maybe [SdtmDatasetVariableRefVersion]) -- ^ "versions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootSdtmDatasetVariableLinks
instance A.FromJSON RootSdtmDatasetVariableLinks where
  parseJSON = A.withObject "RootSdtmDatasetVariableLinks" $ \o ->
    RootSdtmDatasetVariableLinks
      <$> (o .:? "self")
      <*> (o .:? "versions")

-- | ToJSON RootSdtmDatasetVariableLinks
instance A.ToJSON RootSdtmDatasetVariableLinks where
  toJSON RootSdtmDatasetVariableLinks {..} =
   _omitNulls
      [ "self" .= rootSdtmDatasetVariableLinksSelf
      , "versions" .= rootSdtmDatasetVariableLinksVersions
      ]


-- | Construct a value of type 'RootSdtmDatasetVariableLinks' (by applying it's required fields, if any)
mkRootSdtmDatasetVariableLinks
  :: RootSdtmDatasetVariableLinks
mkRootSdtmDatasetVariableLinks =
  RootSdtmDatasetVariableLinks
  { rootSdtmDatasetVariableLinksSelf = Nothing
  , rootSdtmDatasetVariableLinksVersions = Nothing
  }

-- ** RootSdtmDatasetVariableRef
-- | RootSdtmDatasetVariableRef
data RootSdtmDatasetVariableRef = RootSdtmDatasetVariableRef
  { rootSdtmDatasetVariableRefHref :: !(Maybe Text) -- ^ "href"
  , rootSdtmDatasetVariableRefTitle :: !(Maybe Text) -- ^ "title"
  , rootSdtmDatasetVariableRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootSdtmDatasetVariableRef
instance A.FromJSON RootSdtmDatasetVariableRef where
  parseJSON = A.withObject "RootSdtmDatasetVariableRef" $ \o ->
    RootSdtmDatasetVariableRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON RootSdtmDatasetVariableRef
instance A.ToJSON RootSdtmDatasetVariableRef where
  toJSON RootSdtmDatasetVariableRef {..} =
   _omitNulls
      [ "href" .= rootSdtmDatasetVariableRefHref
      , "title" .= rootSdtmDatasetVariableRefTitle
      , "type" .= rootSdtmDatasetVariableRefType
      ]


-- | Construct a value of type 'RootSdtmDatasetVariableRef' (by applying it's required fields, if any)
mkRootSdtmDatasetVariableRef
  :: RootSdtmDatasetVariableRef
mkRootSdtmDatasetVariableRef =
  RootSdtmDatasetVariableRef
  { rootSdtmDatasetVariableRefHref = Nothing
  , rootSdtmDatasetVariableRefTitle = Nothing
  , rootSdtmDatasetVariableRefType = Nothing
  }

-- ** RootSdtmigDatasetVariable
-- | RootSdtmigDatasetVariable
data RootSdtmigDatasetVariable = RootSdtmigDatasetVariable
  { rootSdtmigDatasetVariableLinks :: !(Maybe RootSdtmigDatasetVariableLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootSdtmigDatasetVariable
instance A.FromJSON RootSdtmigDatasetVariable where
  parseJSON = A.withObject "RootSdtmigDatasetVariable" $ \o ->
    RootSdtmigDatasetVariable
      <$> (o .:? "_links")

-- | ToJSON RootSdtmigDatasetVariable
instance A.ToJSON RootSdtmigDatasetVariable where
  toJSON RootSdtmigDatasetVariable {..} =
   _omitNulls
      [ "_links" .= rootSdtmigDatasetVariableLinks
      ]


-- | Construct a value of type 'RootSdtmigDatasetVariable' (by applying it's required fields, if any)
mkRootSdtmigDatasetVariable
  :: RootSdtmigDatasetVariable
mkRootSdtmigDatasetVariable =
  RootSdtmigDatasetVariable
  { rootSdtmigDatasetVariableLinks = Nothing
  }

-- ** RootSdtmigDatasetVariableLinks
-- | RootSdtmigDatasetVariableLinks
data RootSdtmigDatasetVariableLinks = RootSdtmigDatasetVariableLinks
  { rootSdtmigDatasetVariableLinksSelf :: !(Maybe RootSdtmigDatasetVariableRef) -- ^ "self"
  , rootSdtmigDatasetVariableLinksVersions :: !(Maybe [SdtmigDatasetVariableRefVersion]) -- ^ "versions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootSdtmigDatasetVariableLinks
instance A.FromJSON RootSdtmigDatasetVariableLinks where
  parseJSON = A.withObject "RootSdtmigDatasetVariableLinks" $ \o ->
    RootSdtmigDatasetVariableLinks
      <$> (o .:? "self")
      <*> (o .:? "versions")

-- | ToJSON RootSdtmigDatasetVariableLinks
instance A.ToJSON RootSdtmigDatasetVariableLinks where
  toJSON RootSdtmigDatasetVariableLinks {..} =
   _omitNulls
      [ "self" .= rootSdtmigDatasetVariableLinksSelf
      , "versions" .= rootSdtmigDatasetVariableLinksVersions
      ]


-- | Construct a value of type 'RootSdtmigDatasetVariableLinks' (by applying it's required fields, if any)
mkRootSdtmigDatasetVariableLinks
  :: RootSdtmigDatasetVariableLinks
mkRootSdtmigDatasetVariableLinks =
  RootSdtmigDatasetVariableLinks
  { rootSdtmigDatasetVariableLinksSelf = Nothing
  , rootSdtmigDatasetVariableLinksVersions = Nothing
  }

-- ** RootSdtmigDatasetVariableRef
-- | RootSdtmigDatasetVariableRef
data RootSdtmigDatasetVariableRef = RootSdtmigDatasetVariableRef
  { rootSdtmigDatasetVariableRefHref :: !(Maybe Text) -- ^ "href"
  , rootSdtmigDatasetVariableRefTitle :: !(Maybe Text) -- ^ "title"
  , rootSdtmigDatasetVariableRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootSdtmigDatasetVariableRef
instance A.FromJSON RootSdtmigDatasetVariableRef where
  parseJSON = A.withObject "RootSdtmigDatasetVariableRef" $ \o ->
    RootSdtmigDatasetVariableRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON RootSdtmigDatasetVariableRef
instance A.ToJSON RootSdtmigDatasetVariableRef where
  toJSON RootSdtmigDatasetVariableRef {..} =
   _omitNulls
      [ "href" .= rootSdtmigDatasetVariableRefHref
      , "title" .= rootSdtmigDatasetVariableRefTitle
      , "type" .= rootSdtmigDatasetVariableRefType
      ]


-- | Construct a value of type 'RootSdtmigDatasetVariableRef' (by applying it's required fields, if any)
mkRootSdtmigDatasetVariableRef
  :: RootSdtmigDatasetVariableRef
mkRootSdtmigDatasetVariableRef =
  RootSdtmigDatasetVariableRef
  { rootSdtmigDatasetVariableRefHref = Nothing
  , rootSdtmigDatasetVariableRefTitle = Nothing
  , rootSdtmigDatasetVariableRefType = Nothing
  }

-- ** RootSendigDatasetVariable
-- | RootSendigDatasetVariable
data RootSendigDatasetVariable = RootSendigDatasetVariable
  { rootSendigDatasetVariableLinks :: !(Maybe RootSendigDatasetVariableLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootSendigDatasetVariable
instance A.FromJSON RootSendigDatasetVariable where
  parseJSON = A.withObject "RootSendigDatasetVariable" $ \o ->
    RootSendigDatasetVariable
      <$> (o .:? "_links")

-- | ToJSON RootSendigDatasetVariable
instance A.ToJSON RootSendigDatasetVariable where
  toJSON RootSendigDatasetVariable {..} =
   _omitNulls
      [ "_links" .= rootSendigDatasetVariableLinks
      ]


-- | Construct a value of type 'RootSendigDatasetVariable' (by applying it's required fields, if any)
mkRootSendigDatasetVariable
  :: RootSendigDatasetVariable
mkRootSendigDatasetVariable =
  RootSendigDatasetVariable
  { rootSendigDatasetVariableLinks = Nothing
  }

-- ** RootSendigDatasetVariableLinks
-- | RootSendigDatasetVariableLinks
data RootSendigDatasetVariableLinks = RootSendigDatasetVariableLinks
  { rootSendigDatasetVariableLinksSelf :: !(Maybe RootSendigDatasetVariableRef) -- ^ "self"
  , rootSendigDatasetVariableLinksVersions :: !(Maybe [SendigDatasetVariableRefVersion]) -- ^ "versions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootSendigDatasetVariableLinks
instance A.FromJSON RootSendigDatasetVariableLinks where
  parseJSON = A.withObject "RootSendigDatasetVariableLinks" $ \o ->
    RootSendigDatasetVariableLinks
      <$> (o .:? "self")
      <*> (o .:? "versions")

-- | ToJSON RootSendigDatasetVariableLinks
instance A.ToJSON RootSendigDatasetVariableLinks where
  toJSON RootSendigDatasetVariableLinks {..} =
   _omitNulls
      [ "self" .= rootSendigDatasetVariableLinksSelf
      , "versions" .= rootSendigDatasetVariableLinksVersions
      ]


-- | Construct a value of type 'RootSendigDatasetVariableLinks' (by applying it's required fields, if any)
mkRootSendigDatasetVariableLinks
  :: RootSendigDatasetVariableLinks
mkRootSendigDatasetVariableLinks =
  RootSendigDatasetVariableLinks
  { rootSendigDatasetVariableLinksSelf = Nothing
  , rootSendigDatasetVariableLinksVersions = Nothing
  }

-- ** RootSendigDatasetVariableRef
-- | RootSendigDatasetVariableRef
data RootSendigDatasetVariableRef = RootSendigDatasetVariableRef
  { rootSendigDatasetVariableRefHref :: !(Maybe Text) -- ^ "href"
  , rootSendigDatasetVariableRefTitle :: !(Maybe Text) -- ^ "title"
  , rootSendigDatasetVariableRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RootSendigDatasetVariableRef
instance A.FromJSON RootSendigDatasetVariableRef where
  parseJSON = A.withObject "RootSendigDatasetVariableRef" $ \o ->
    RootSendigDatasetVariableRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON RootSendigDatasetVariableRef
instance A.ToJSON RootSendigDatasetVariableRef where
  toJSON RootSendigDatasetVariableRef {..} =
   _omitNulls
      [ "href" .= rootSendigDatasetVariableRefHref
      , "title" .= rootSendigDatasetVariableRefTitle
      , "type" .= rootSendigDatasetVariableRefType
      ]


-- | Construct a value of type 'RootSendigDatasetVariableRef' (by applying it's required fields, if any)
mkRootSendigDatasetVariableRef
  :: RootSendigDatasetVariableRef
mkRootSendigDatasetVariableRef =
  RootSendigDatasetVariableRef
  { rootSendigDatasetVariableRefHref = Nothing
  , rootSendigDatasetVariableRefTitle = Nothing
  , rootSendigDatasetVariableRefType = Nothing
  }

-- ** ScopeValues
-- | ScopeValues
data ScopeValues = ScopeValues
  { scopeValuesTotal :: !(Maybe Double) -- ^ "total"
  , scopeValuesHasMore :: !(Maybe Bool) -- ^ "hasMore"
  , scopeValuesValues :: !(Maybe [Text]) -- ^ "values"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScopeValues
instance A.FromJSON ScopeValues where
  parseJSON = A.withObject "ScopeValues" $ \o ->
    ScopeValues
      <$> (o .:? "total")
      <*> (o .:? "hasMore")
      <*> (o .:? "values")

-- | ToJSON ScopeValues
instance A.ToJSON ScopeValues where
  toJSON ScopeValues {..} =
   _omitNulls
      [ "total" .= scopeValuesTotal
      , "hasMore" .= scopeValuesHasMore
      , "values" .= scopeValuesValues
      ]


-- | Construct a value of type 'ScopeValues' (by applying it's required fields, if any)
mkScopeValues
  :: ScopeValues
mkScopeValues =
  ScopeValues
  { scopeValuesTotal = Nothing
  , scopeValuesHasMore = Nothing
  , scopeValuesValues = Nothing
  }

-- ** SdtmClass
-- | SdtmClass
data SdtmClass = SdtmClass
  { sdtmClassOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sdtmClassName :: !(Maybe Text) -- ^ "name"
  , sdtmClassLabel :: !(Maybe Text) -- ^ "label"
  , sdtmClassDescription :: !(Maybe Text) -- ^ "description"
  , sdtmClassLinks :: !(Maybe SdtmClassLinks) -- ^ "_links"
  , sdtmClassClassVariables :: !(Maybe [SdtmClassVariable]) -- ^ "classVariables"
  , sdtmClassDatasets :: !(Maybe [SdtmDataset]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClass
instance A.FromJSON SdtmClass where
  parseJSON = A.withObject "SdtmClass" $ \o ->
    SdtmClass
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "_links")
      <*> (o .:? "classVariables")
      <*> (o .:? "datasets")

-- | ToJSON SdtmClass
instance A.ToJSON SdtmClass where
  toJSON SdtmClass {..} =
   _omitNulls
      [ "ordinal" .= sdtmClassOrdinal
      , "name" .= sdtmClassName
      , "label" .= sdtmClassLabel
      , "description" .= sdtmClassDescription
      , "_links" .= sdtmClassLinks
      , "classVariables" .= sdtmClassClassVariables
      , "datasets" .= sdtmClassDatasets
      ]


-- | Construct a value of type 'SdtmClass' (by applying it's required fields, if any)
mkSdtmClass
  :: SdtmClass
mkSdtmClass =
  SdtmClass
  { sdtmClassOrdinal = Nothing
  , sdtmClassName = Nothing
  , sdtmClassLabel = Nothing
  , sdtmClassDescription = Nothing
  , sdtmClassLinks = Nothing
  , sdtmClassClassVariables = Nothing
  , sdtmClassDatasets = Nothing
  }

-- ** SdtmClassDatasets
-- | SdtmClassDatasets
data SdtmClassDatasets = SdtmClassDatasets
  { sdtmClassDatasetsOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sdtmClassDatasetsName :: !(Maybe Text) -- ^ "name"
  , sdtmClassDatasetsLabel :: !(Maybe Text) -- ^ "label"
  , sdtmClassDatasetsDescription :: !(Maybe Text) -- ^ "description"
  , sdtmClassDatasetsLinks :: !(Maybe SdtmClassDatasetsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassDatasets
instance A.FromJSON SdtmClassDatasets where
  parseJSON = A.withObject "SdtmClassDatasets" $ \o ->
    SdtmClassDatasets
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "_links")

-- | ToJSON SdtmClassDatasets
instance A.ToJSON SdtmClassDatasets where
  toJSON SdtmClassDatasets {..} =
   _omitNulls
      [ "ordinal" .= sdtmClassDatasetsOrdinal
      , "name" .= sdtmClassDatasetsName
      , "label" .= sdtmClassDatasetsLabel
      , "description" .= sdtmClassDatasetsDescription
      , "_links" .= sdtmClassDatasetsLinks
      ]


-- | Construct a value of type 'SdtmClassDatasets' (by applying it's required fields, if any)
mkSdtmClassDatasets
  :: SdtmClassDatasets
mkSdtmClassDatasets =
  SdtmClassDatasets
  { sdtmClassDatasetsOrdinal = Nothing
  , sdtmClassDatasetsName = Nothing
  , sdtmClassDatasetsLabel = Nothing
  , sdtmClassDatasetsDescription = Nothing
  , sdtmClassDatasetsLinks = Nothing
  }

-- ** SdtmClassDatasetsLinks
-- | SdtmClassDatasetsLinks
data SdtmClassDatasetsLinks = SdtmClassDatasetsLinks
  { sdtmClassDatasetsLinksSelf :: !(Maybe SdtmClassDatasetsRef) -- ^ "self"
  , sdtmClassDatasetsLinksParentProduct :: !(Maybe SdtmProductRef) -- ^ "parentProduct"
  , sdtmClassDatasetsLinksPriorVersion :: !(Maybe SdtmClassDatasetsRef) -- ^ "priorVersion"
  , sdtmClassDatasetsLinksDatasets :: !(Maybe [SdtmDatasetRefElement]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassDatasetsLinks
instance A.FromJSON SdtmClassDatasetsLinks where
  parseJSON = A.withObject "SdtmClassDatasetsLinks" $ \o ->
    SdtmClassDatasetsLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "priorVersion")
      <*> (o .:? "datasets")

-- | ToJSON SdtmClassDatasetsLinks
instance A.ToJSON SdtmClassDatasetsLinks where
  toJSON SdtmClassDatasetsLinks {..} =
   _omitNulls
      [ "self" .= sdtmClassDatasetsLinksSelf
      , "parentProduct" .= sdtmClassDatasetsLinksParentProduct
      , "priorVersion" .= sdtmClassDatasetsLinksPriorVersion
      , "datasets" .= sdtmClassDatasetsLinksDatasets
      ]


-- | Construct a value of type 'SdtmClassDatasetsLinks' (by applying it's required fields, if any)
mkSdtmClassDatasetsLinks
  :: SdtmClassDatasetsLinks
mkSdtmClassDatasetsLinks =
  SdtmClassDatasetsLinks
  { sdtmClassDatasetsLinksSelf = Nothing
  , sdtmClassDatasetsLinksParentProduct = Nothing
  , sdtmClassDatasetsLinksPriorVersion = Nothing
  , sdtmClassDatasetsLinksDatasets = Nothing
  }

-- ** SdtmClassDatasetsRef
-- | SdtmClassDatasetsRef
data SdtmClassDatasetsRef = SdtmClassDatasetsRef
  { sdtmClassDatasetsRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmClassDatasetsRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmClassDatasetsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassDatasetsRef
instance A.FromJSON SdtmClassDatasetsRef where
  parseJSON = A.withObject "SdtmClassDatasetsRef" $ \o ->
    SdtmClassDatasetsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmClassDatasetsRef
instance A.ToJSON SdtmClassDatasetsRef where
  toJSON SdtmClassDatasetsRef {..} =
   _omitNulls
      [ "href" .= sdtmClassDatasetsRefHref
      , "title" .= sdtmClassDatasetsRefTitle
      , "type" .= sdtmClassDatasetsRefType
      ]


-- | Construct a value of type 'SdtmClassDatasetsRef' (by applying it's required fields, if any)
mkSdtmClassDatasetsRef
  :: SdtmClassDatasetsRef
mkSdtmClassDatasetsRef =
  SdtmClassDatasetsRef
  { sdtmClassDatasetsRefHref = Nothing
  , sdtmClassDatasetsRefTitle = Nothing
  , sdtmClassDatasetsRefType = Nothing
  }

-- ** SdtmClassLinks
-- | SdtmClassLinks
data SdtmClassLinks = SdtmClassLinks
  { sdtmClassLinksSelf :: !(Maybe SdtmClassRef) -- ^ "self"
  , sdtmClassLinksParentProduct :: !(Maybe SdtmProductRef) -- ^ "parentProduct"
  , sdtmClassLinksParentClass :: !(Maybe SdtmClassRef) -- ^ "parentClass"
  , sdtmClassLinksSubclasses :: !(Maybe [SdtmClassRefSubclass]) -- ^ "subclasses"
  , sdtmClassLinksPriorVersion :: !(Maybe SdtmClassRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassLinks
instance A.FromJSON SdtmClassLinks where
  parseJSON = A.withObject "SdtmClassLinks" $ \o ->
    SdtmClassLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "subclasses")
      <*> (o .:? "priorVersion")

-- | ToJSON SdtmClassLinks
instance A.ToJSON SdtmClassLinks where
  toJSON SdtmClassLinks {..} =
   _omitNulls
      [ "self" .= sdtmClassLinksSelf
      , "parentProduct" .= sdtmClassLinksParentProduct
      , "parentClass" .= sdtmClassLinksParentClass
      , "subclasses" .= sdtmClassLinksSubclasses
      , "priorVersion" .= sdtmClassLinksPriorVersion
      ]


-- | Construct a value of type 'SdtmClassLinks' (by applying it's required fields, if any)
mkSdtmClassLinks
  :: SdtmClassLinks
mkSdtmClassLinks =
  SdtmClassLinks
  { sdtmClassLinksSelf = Nothing
  , sdtmClassLinksParentProduct = Nothing
  , sdtmClassLinksParentClass = Nothing
  , sdtmClassLinksSubclasses = Nothing
  , sdtmClassLinksPriorVersion = Nothing
  }

-- ** SdtmClassRef
-- | SdtmClassRef
data SdtmClassRef = SdtmClassRef
  { sdtmClassRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmClassRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmClassRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassRef
instance A.FromJSON SdtmClassRef where
  parseJSON = A.withObject "SdtmClassRef" $ \o ->
    SdtmClassRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmClassRef
instance A.ToJSON SdtmClassRef where
  toJSON SdtmClassRef {..} =
   _omitNulls
      [ "href" .= sdtmClassRefHref
      , "title" .= sdtmClassRefTitle
      , "type" .= sdtmClassRefType
      ]


-- | Construct a value of type 'SdtmClassRef' (by applying it's required fields, if any)
mkSdtmClassRef
  :: SdtmClassRef
mkSdtmClassRef =
  SdtmClassRef
  { sdtmClassRefHref = Nothing
  , sdtmClassRefTitle = Nothing
  , sdtmClassRefType = Nothing
  }

-- ** SdtmClassRefElement
-- | SdtmClassRefElement
data SdtmClassRefElement = SdtmClassRefElement
  { sdtmClassRefElementHref :: !(Maybe Text) -- ^ "href"
  , sdtmClassRefElementTitle :: !(Maybe Text) -- ^ "title"
  , sdtmClassRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassRefElement
instance A.FromJSON SdtmClassRefElement where
  parseJSON = A.withObject "SdtmClassRefElement" $ \o ->
    SdtmClassRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmClassRefElement
instance A.ToJSON SdtmClassRefElement where
  toJSON SdtmClassRefElement {..} =
   _omitNulls
      [ "href" .= sdtmClassRefElementHref
      , "title" .= sdtmClassRefElementTitle
      , "type" .= sdtmClassRefElementType
      ]


-- | Construct a value of type 'SdtmClassRefElement' (by applying it's required fields, if any)
mkSdtmClassRefElement
  :: SdtmClassRefElement
mkSdtmClassRefElement =
  SdtmClassRefElement
  { sdtmClassRefElementHref = Nothing
  , sdtmClassRefElementTitle = Nothing
  , sdtmClassRefElementType = Nothing
  }

-- ** SdtmClassRefSubclass
-- | SdtmClassRefSubclass
data SdtmClassRefSubclass = SdtmClassRefSubclass
  { sdtmClassRefSubclassHref :: !(Maybe Text) -- ^ "href"
  , sdtmClassRefSubclassTitle :: !(Maybe Text) -- ^ "title"
  , sdtmClassRefSubclassType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassRefSubclass
instance A.FromJSON SdtmClassRefSubclass where
  parseJSON = A.withObject "SdtmClassRefSubclass" $ \o ->
    SdtmClassRefSubclass
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmClassRefSubclass
instance A.ToJSON SdtmClassRefSubclass where
  toJSON SdtmClassRefSubclass {..} =
   _omitNulls
      [ "href" .= sdtmClassRefSubclassHref
      , "title" .= sdtmClassRefSubclassTitle
      , "type" .= sdtmClassRefSubclassType
      ]


-- | Construct a value of type 'SdtmClassRefSubclass' (by applying it's required fields, if any)
mkSdtmClassRefSubclass
  :: SdtmClassRefSubclass
mkSdtmClassRefSubclass =
  SdtmClassRefSubclass
  { sdtmClassRefSubclassHref = Nothing
  , sdtmClassRefSubclassTitle = Nothing
  , sdtmClassRefSubclassType = Nothing
  }

-- ** SdtmClassVariable
-- | SdtmClassVariable
data SdtmClassVariable = SdtmClassVariable
  { sdtmClassVariableOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sdtmClassVariableName :: !(Maybe Text) -- ^ "name"
  , sdtmClassVariableLabel :: !(Maybe Text) -- ^ "label"
  , sdtmClassVariableDescription :: !(Maybe Text) -- ^ "description"
  , sdtmClassVariableRole :: !(Maybe Text) -- ^ "role"
  , sdtmClassVariableRoleDescription :: !(Maybe Text) -- ^ "roleDescription"
  , sdtmClassVariableSimpleDatatype :: !(Maybe Text) -- ^ "simpleDatatype"
  , sdtmClassVariableDescribedValueDomain :: !(Maybe Text) -- ^ "describedValueDomain"
  , sdtmClassVariableLinks :: !(Maybe SdtmClassVariableLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassVariable
instance A.FromJSON SdtmClassVariable where
  parseJSON = A.withObject "SdtmClassVariable" $ \o ->
    SdtmClassVariable
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "role")
      <*> (o .:? "roleDescription")
      <*> (o .:? "simpleDatatype")
      <*> (o .:? "describedValueDomain")
      <*> (o .:? "_links")

-- | ToJSON SdtmClassVariable
instance A.ToJSON SdtmClassVariable where
  toJSON SdtmClassVariable {..} =
   _omitNulls
      [ "ordinal" .= sdtmClassVariableOrdinal
      , "name" .= sdtmClassVariableName
      , "label" .= sdtmClassVariableLabel
      , "description" .= sdtmClassVariableDescription
      , "role" .= sdtmClassVariableRole
      , "roleDescription" .= sdtmClassVariableRoleDescription
      , "simpleDatatype" .= sdtmClassVariableSimpleDatatype
      , "describedValueDomain" .= sdtmClassVariableDescribedValueDomain
      , "_links" .= sdtmClassVariableLinks
      ]


-- | Construct a value of type 'SdtmClassVariable' (by applying it's required fields, if any)
mkSdtmClassVariable
  :: SdtmClassVariable
mkSdtmClassVariable =
  SdtmClassVariable
  { sdtmClassVariableOrdinal = Nothing
  , sdtmClassVariableName = Nothing
  , sdtmClassVariableLabel = Nothing
  , sdtmClassVariableDescription = Nothing
  , sdtmClassVariableRole = Nothing
  , sdtmClassVariableRoleDescription = Nothing
  , sdtmClassVariableSimpleDatatype = Nothing
  , sdtmClassVariableDescribedValueDomain = Nothing
  , sdtmClassVariableLinks = Nothing
  }

-- ** SdtmClassVariableLinks
-- | SdtmClassVariableLinks
data SdtmClassVariableLinks = SdtmClassVariableLinks
  { sdtmClassVariableLinksSelf :: !(Maybe SdtmClassVariableRef) -- ^ "self"
  , sdtmClassVariableLinksParentProduct :: !(Maybe SdtmProductRef) -- ^ "parentProduct"
  , sdtmClassVariableLinksParentClass :: !(Maybe SdtmClassRef) -- ^ "parentClass"
  , sdtmClassVariableLinksQualifiesVariables :: !(Maybe [SdtmClassVariableRefQualifies]) -- ^ "qualifiesVariables"
  , sdtmClassVariableLinksRootItem :: !(Maybe RootSdtmClassVariableRef) -- ^ "rootItem"
  , sdtmClassVariableLinksPriorVersion :: !(Maybe SdtmClassVariableRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassVariableLinks
instance A.FromJSON SdtmClassVariableLinks where
  parseJSON = A.withObject "SdtmClassVariableLinks" $ \o ->
    SdtmClassVariableLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "qualifiesVariables")
      <*> (o .:? "rootItem")
      <*> (o .:? "priorVersion")

-- | ToJSON SdtmClassVariableLinks
instance A.ToJSON SdtmClassVariableLinks where
  toJSON SdtmClassVariableLinks {..} =
   _omitNulls
      [ "self" .= sdtmClassVariableLinksSelf
      , "parentProduct" .= sdtmClassVariableLinksParentProduct
      , "parentClass" .= sdtmClassVariableLinksParentClass
      , "qualifiesVariables" .= sdtmClassVariableLinksQualifiesVariables
      , "rootItem" .= sdtmClassVariableLinksRootItem
      , "priorVersion" .= sdtmClassVariableLinksPriorVersion
      ]


-- | Construct a value of type 'SdtmClassVariableLinks' (by applying it's required fields, if any)
mkSdtmClassVariableLinks
  :: SdtmClassVariableLinks
mkSdtmClassVariableLinks =
  SdtmClassVariableLinks
  { sdtmClassVariableLinksSelf = Nothing
  , sdtmClassVariableLinksParentProduct = Nothing
  , sdtmClassVariableLinksParentClass = Nothing
  , sdtmClassVariableLinksQualifiesVariables = Nothing
  , sdtmClassVariableLinksRootItem = Nothing
  , sdtmClassVariableLinksPriorVersion = Nothing
  }

-- ** SdtmClassVariableRef
-- | SdtmClassVariableRef
data SdtmClassVariableRef = SdtmClassVariableRef
  { sdtmClassVariableRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmClassVariableRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmClassVariableRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassVariableRef
instance A.FromJSON SdtmClassVariableRef where
  parseJSON = A.withObject "SdtmClassVariableRef" $ \o ->
    SdtmClassVariableRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmClassVariableRef
instance A.ToJSON SdtmClassVariableRef where
  toJSON SdtmClassVariableRef {..} =
   _omitNulls
      [ "href" .= sdtmClassVariableRefHref
      , "title" .= sdtmClassVariableRefTitle
      , "type" .= sdtmClassVariableRefType
      ]


-- | Construct a value of type 'SdtmClassVariableRef' (by applying it's required fields, if any)
mkSdtmClassVariableRef
  :: SdtmClassVariableRef
mkSdtmClassVariableRef =
  SdtmClassVariableRef
  { sdtmClassVariableRefHref = Nothing
  , sdtmClassVariableRefTitle = Nothing
  , sdtmClassVariableRefType = Nothing
  }

-- ** SdtmClassVariableRefElement
-- | SdtmClassVariableRefElement
data SdtmClassVariableRefElement = SdtmClassVariableRefElement
  { sdtmClassVariableRefElementHref :: !(Maybe Text) -- ^ "href"
  , sdtmClassVariableRefElementTitle :: !(Maybe Text) -- ^ "title"
  , sdtmClassVariableRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassVariableRefElement
instance A.FromJSON SdtmClassVariableRefElement where
  parseJSON = A.withObject "SdtmClassVariableRefElement" $ \o ->
    SdtmClassVariableRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmClassVariableRefElement
instance A.ToJSON SdtmClassVariableRefElement where
  toJSON SdtmClassVariableRefElement {..} =
   _omitNulls
      [ "href" .= sdtmClassVariableRefElementHref
      , "title" .= sdtmClassVariableRefElementTitle
      , "type" .= sdtmClassVariableRefElementType
      ]


-- | Construct a value of type 'SdtmClassVariableRefElement' (by applying it's required fields, if any)
mkSdtmClassVariableRefElement
  :: SdtmClassVariableRefElement
mkSdtmClassVariableRefElement =
  SdtmClassVariableRefElement
  { sdtmClassVariableRefElementHref = Nothing
  , sdtmClassVariableRefElementTitle = Nothing
  , sdtmClassVariableRefElementType = Nothing
  }

-- ** SdtmClassVariableRefQualifies
-- | SdtmClassVariableRefQualifies
data SdtmClassVariableRefQualifies = SdtmClassVariableRefQualifies
  { sdtmClassVariableRefQualifiesHref :: !(Maybe Text) -- ^ "href"
  , sdtmClassVariableRefQualifiesTitle :: !(Maybe Text) -- ^ "title"
  , sdtmClassVariableRefQualifiesType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassVariableRefQualifies
instance A.FromJSON SdtmClassVariableRefQualifies where
  parseJSON = A.withObject "SdtmClassVariableRefQualifies" $ \o ->
    SdtmClassVariableRefQualifies
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmClassVariableRefQualifies
instance A.ToJSON SdtmClassVariableRefQualifies where
  toJSON SdtmClassVariableRefQualifies {..} =
   _omitNulls
      [ "href" .= sdtmClassVariableRefQualifiesHref
      , "title" .= sdtmClassVariableRefQualifiesTitle
      , "type" .= sdtmClassVariableRefQualifiesType
      ]


-- | Construct a value of type 'SdtmClassVariableRefQualifies' (by applying it's required fields, if any)
mkSdtmClassVariableRefQualifies
  :: SdtmClassVariableRefQualifies
mkSdtmClassVariableRefQualifies =
  SdtmClassVariableRefQualifies
  { sdtmClassVariableRefQualifiesHref = Nothing
  , sdtmClassVariableRefQualifiesTitle = Nothing
  , sdtmClassVariableRefQualifiesType = Nothing
  }

-- ** SdtmClassVariableRefTarget
-- | SdtmClassVariableRefTarget
data SdtmClassVariableRefTarget = SdtmClassVariableRefTarget
  { sdtmClassVariableRefTargetHref :: !(Maybe Text) -- ^ "href"
  , sdtmClassVariableRefTargetTitle :: !(Maybe Text) -- ^ "title"
  , sdtmClassVariableRefTargetType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassVariableRefTarget
instance A.FromJSON SdtmClassVariableRefTarget where
  parseJSON = A.withObject "SdtmClassVariableRefTarget" $ \o ->
    SdtmClassVariableRefTarget
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmClassVariableRefTarget
instance A.ToJSON SdtmClassVariableRefTarget where
  toJSON SdtmClassVariableRefTarget {..} =
   _omitNulls
      [ "href" .= sdtmClassVariableRefTargetHref
      , "title" .= sdtmClassVariableRefTargetTitle
      , "type" .= sdtmClassVariableRefTargetType
      ]


-- | Construct a value of type 'SdtmClassVariableRefTarget' (by applying it's required fields, if any)
mkSdtmClassVariableRefTarget
  :: SdtmClassVariableRefTarget
mkSdtmClassVariableRefTarget =
  SdtmClassVariableRefTarget
  { sdtmClassVariableRefTargetHref = Nothing
  , sdtmClassVariableRefTargetTitle = Nothing
  , sdtmClassVariableRefTargetType = Nothing
  }

-- ** SdtmClassVariableRefVersion
-- | SdtmClassVariableRefVersion
data SdtmClassVariableRefVersion = SdtmClassVariableRefVersion
  { sdtmClassVariableRefVersionHref :: !(Maybe Text) -- ^ "href"
  , sdtmClassVariableRefVersionTitle :: !(Maybe Text) -- ^ "title"
  , sdtmClassVariableRefVersionType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassVariableRefVersion
instance A.FromJSON SdtmClassVariableRefVersion where
  parseJSON = A.withObject "SdtmClassVariableRefVersion" $ \o ->
    SdtmClassVariableRefVersion
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmClassVariableRefVersion
instance A.ToJSON SdtmClassVariableRefVersion where
  toJSON SdtmClassVariableRefVersion {..} =
   _omitNulls
      [ "href" .= sdtmClassVariableRefVersionHref
      , "title" .= sdtmClassVariableRefVersionTitle
      , "type" .= sdtmClassVariableRefVersionType
      ]


-- | Construct a value of type 'SdtmClassVariableRefVersion' (by applying it's required fields, if any)
mkSdtmClassVariableRefVersion
  :: SdtmClassVariableRefVersion
mkSdtmClassVariableRefVersion =
  SdtmClassVariableRefVersion
  { sdtmClassVariableRefVersionHref = Nothing
  , sdtmClassVariableRefVersionTitle = Nothing
  , sdtmClassVariableRefVersionType = Nothing
  }

-- ** SdtmClassVariables
-- | SdtmClassVariables
data SdtmClassVariables = SdtmClassVariables
  { sdtmClassVariablesOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sdtmClassVariablesName :: !(Maybe Text) -- ^ "name"
  , sdtmClassVariablesLabel :: !(Maybe Text) -- ^ "label"
  , sdtmClassVariablesDescription :: !(Maybe Text) -- ^ "description"
  , sdtmClassVariablesLinks :: !(Maybe SdtmClassVariablesLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassVariables
instance A.FromJSON SdtmClassVariables where
  parseJSON = A.withObject "SdtmClassVariables" $ \o ->
    SdtmClassVariables
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "_links")

-- | ToJSON SdtmClassVariables
instance A.ToJSON SdtmClassVariables where
  toJSON SdtmClassVariables {..} =
   _omitNulls
      [ "ordinal" .= sdtmClassVariablesOrdinal
      , "name" .= sdtmClassVariablesName
      , "label" .= sdtmClassVariablesLabel
      , "description" .= sdtmClassVariablesDescription
      , "_links" .= sdtmClassVariablesLinks
      ]


-- | Construct a value of type 'SdtmClassVariables' (by applying it's required fields, if any)
mkSdtmClassVariables
  :: SdtmClassVariables
mkSdtmClassVariables =
  SdtmClassVariables
  { sdtmClassVariablesOrdinal = Nothing
  , sdtmClassVariablesName = Nothing
  , sdtmClassVariablesLabel = Nothing
  , sdtmClassVariablesDescription = Nothing
  , sdtmClassVariablesLinks = Nothing
  }

-- ** SdtmClassVariablesLinks
-- | SdtmClassVariablesLinks
data SdtmClassVariablesLinks = SdtmClassVariablesLinks
  { sdtmClassVariablesLinksSelf :: !(Maybe SdtmClassVariablesRef) -- ^ "self"
  , sdtmClassVariablesLinksParentProduct :: !(Maybe SdtmProductRef) -- ^ "parentProduct"
  , sdtmClassVariablesLinksPriorVersion :: !(Maybe SdtmClassVariablesRef) -- ^ "priorVersion"
  , sdtmClassVariablesLinksClassVariables :: !(Maybe [SdtmClassVariableRefElement]) -- ^ "classVariables"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassVariablesLinks
instance A.FromJSON SdtmClassVariablesLinks where
  parseJSON = A.withObject "SdtmClassVariablesLinks" $ \o ->
    SdtmClassVariablesLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "priorVersion")
      <*> (o .:? "classVariables")

-- | ToJSON SdtmClassVariablesLinks
instance A.ToJSON SdtmClassVariablesLinks where
  toJSON SdtmClassVariablesLinks {..} =
   _omitNulls
      [ "self" .= sdtmClassVariablesLinksSelf
      , "parentProduct" .= sdtmClassVariablesLinksParentProduct
      , "priorVersion" .= sdtmClassVariablesLinksPriorVersion
      , "classVariables" .= sdtmClassVariablesLinksClassVariables
      ]


-- | Construct a value of type 'SdtmClassVariablesLinks' (by applying it's required fields, if any)
mkSdtmClassVariablesLinks
  :: SdtmClassVariablesLinks
mkSdtmClassVariablesLinks =
  SdtmClassVariablesLinks
  { sdtmClassVariablesLinksSelf = Nothing
  , sdtmClassVariablesLinksParentProduct = Nothing
  , sdtmClassVariablesLinksPriorVersion = Nothing
  , sdtmClassVariablesLinksClassVariables = Nothing
  }

-- ** SdtmClassVariablesRef
-- | SdtmClassVariablesRef
data SdtmClassVariablesRef = SdtmClassVariablesRef
  { sdtmClassVariablesRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmClassVariablesRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmClassVariablesRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassVariablesRef
instance A.FromJSON SdtmClassVariablesRef where
  parseJSON = A.withObject "SdtmClassVariablesRef" $ \o ->
    SdtmClassVariablesRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmClassVariablesRef
instance A.ToJSON SdtmClassVariablesRef where
  toJSON SdtmClassVariablesRef {..} =
   _omitNulls
      [ "href" .= sdtmClassVariablesRefHref
      , "title" .= sdtmClassVariablesRefTitle
      , "type" .= sdtmClassVariablesRefType
      ]


-- | Construct a value of type 'SdtmClassVariablesRef' (by applying it's required fields, if any)
mkSdtmClassVariablesRef
  :: SdtmClassVariablesRef
mkSdtmClassVariablesRef =
  SdtmClassVariablesRef
  { sdtmClassVariablesRefHref = Nothing
  , sdtmClassVariablesRefTitle = Nothing
  , sdtmClassVariablesRefType = Nothing
  }

-- ** SdtmClasses
-- | SdtmClasses
data SdtmClasses = SdtmClasses
  { sdtmClassesName :: !(Maybe Text) -- ^ "name"
  , sdtmClassesLabel :: !(Maybe Text) -- ^ "label"
  , sdtmClassesDescription :: !(Maybe Text) -- ^ "description"
  , sdtmClassesSource :: !(Maybe Text) -- ^ "source"
  , sdtmClassesEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , sdtmClassesRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , sdtmClassesVersion :: !(Maybe Text) -- ^ "version"
  , sdtmClassesLinks :: !(Maybe SdtmClassesLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClasses
instance A.FromJSON SdtmClasses where
  parseJSON = A.withObject "SdtmClasses" $ \o ->
    SdtmClasses
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")

-- | ToJSON SdtmClasses
instance A.ToJSON SdtmClasses where
  toJSON SdtmClasses {..} =
   _omitNulls
      [ "name" .= sdtmClassesName
      , "label" .= sdtmClassesLabel
      , "description" .= sdtmClassesDescription
      , "source" .= sdtmClassesSource
      , "effectiveDate" .= sdtmClassesEffectiveDate
      , "registrationStatus" .= sdtmClassesRegistrationStatus
      , "version" .= sdtmClassesVersion
      , "_links" .= sdtmClassesLinks
      ]


-- | Construct a value of type 'SdtmClasses' (by applying it's required fields, if any)
mkSdtmClasses
  :: SdtmClasses
mkSdtmClasses =
  SdtmClasses
  { sdtmClassesName = Nothing
  , sdtmClassesLabel = Nothing
  , sdtmClassesDescription = Nothing
  , sdtmClassesSource = Nothing
  , sdtmClassesEffectiveDate = Nothing
  , sdtmClassesRegistrationStatus = Nothing
  , sdtmClassesVersion = Nothing
  , sdtmClassesLinks = Nothing
  }

-- ** SdtmClassesLinks
-- | SdtmClassesLinks
data SdtmClassesLinks = SdtmClassesLinks
  { sdtmClassesLinksSelf :: !(Maybe SdtmClassesRef) -- ^ "self"
  , sdtmClassesLinksPriorVersion :: !(Maybe SdtmClassesRef) -- ^ "priorVersion"
  , sdtmClassesLinksClasses :: !(Maybe [SdtmClassRefElement]) -- ^ "classes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassesLinks
instance A.FromJSON SdtmClassesLinks where
  parseJSON = A.withObject "SdtmClassesLinks" $ \o ->
    SdtmClassesLinks
      <$> (o .:? "self")
      <*> (o .:? "priorVersion")
      <*> (o .:? "classes")

-- | ToJSON SdtmClassesLinks
instance A.ToJSON SdtmClassesLinks where
  toJSON SdtmClassesLinks {..} =
   _omitNulls
      [ "self" .= sdtmClassesLinksSelf
      , "priorVersion" .= sdtmClassesLinksPriorVersion
      , "classes" .= sdtmClassesLinksClasses
      ]


-- | Construct a value of type 'SdtmClassesLinks' (by applying it's required fields, if any)
mkSdtmClassesLinks
  :: SdtmClassesLinks
mkSdtmClassesLinks =
  SdtmClassesLinks
  { sdtmClassesLinksSelf = Nothing
  , sdtmClassesLinksPriorVersion = Nothing
  , sdtmClassesLinksClasses = Nothing
  }

-- ** SdtmClassesRef
-- | SdtmClassesRef
data SdtmClassesRef = SdtmClassesRef
  { sdtmClassesRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmClassesRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmClassesRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmClassesRef
instance A.FromJSON SdtmClassesRef where
  parseJSON = A.withObject "SdtmClassesRef" $ \o ->
    SdtmClassesRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmClassesRef
instance A.ToJSON SdtmClassesRef where
  toJSON SdtmClassesRef {..} =
   _omitNulls
      [ "href" .= sdtmClassesRefHref
      , "title" .= sdtmClassesRefTitle
      , "type" .= sdtmClassesRefType
      ]


-- | Construct a value of type 'SdtmClassesRef' (by applying it's required fields, if any)
mkSdtmClassesRef
  :: SdtmClassesRef
mkSdtmClassesRef =
  SdtmClassesRef
  { sdtmClassesRefHref = Nothing
  , sdtmClassesRefTitle = Nothing
  , sdtmClassesRefType = Nothing
  }

-- ** SdtmDataset
-- | SdtmDataset
data SdtmDataset = SdtmDataset
  { sdtmDatasetOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sdtmDatasetName :: !(Maybe Text) -- ^ "name"
  , sdtmDatasetLabel :: !(Maybe Text) -- ^ "label"
  , sdtmDatasetDescription :: !(Maybe Text) -- ^ "description"
  , sdtmDatasetDatasetStructure :: !(Maybe Text) -- ^ "datasetStructure"
  , sdtmDatasetLinks :: !(Maybe SdtmDatasetLinks) -- ^ "_links"
  , sdtmDatasetDatasetVariables :: !(Maybe [SdtmDatasetVariable]) -- ^ "datasetVariables"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDataset
instance A.FromJSON SdtmDataset where
  parseJSON = A.withObject "SdtmDataset" $ \o ->
    SdtmDataset
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "datasetStructure")
      <*> (o .:? "_links")
      <*> (o .:? "datasetVariables")

-- | ToJSON SdtmDataset
instance A.ToJSON SdtmDataset where
  toJSON SdtmDataset {..} =
   _omitNulls
      [ "ordinal" .= sdtmDatasetOrdinal
      , "name" .= sdtmDatasetName
      , "label" .= sdtmDatasetLabel
      , "description" .= sdtmDatasetDescription
      , "datasetStructure" .= sdtmDatasetDatasetStructure
      , "_links" .= sdtmDatasetLinks
      , "datasetVariables" .= sdtmDatasetDatasetVariables
      ]


-- | Construct a value of type 'SdtmDataset' (by applying it's required fields, if any)
mkSdtmDataset
  :: SdtmDataset
mkSdtmDataset =
  SdtmDataset
  { sdtmDatasetOrdinal = Nothing
  , sdtmDatasetName = Nothing
  , sdtmDatasetLabel = Nothing
  , sdtmDatasetDescription = Nothing
  , sdtmDatasetDatasetStructure = Nothing
  , sdtmDatasetLinks = Nothing
  , sdtmDatasetDatasetVariables = Nothing
  }

-- ** SdtmDatasetLinks
-- | SdtmDatasetLinks
data SdtmDatasetLinks = SdtmDatasetLinks
  { sdtmDatasetLinksSelf :: !(Maybe SdtmDatasetRef) -- ^ "self"
  , sdtmDatasetLinksParentProduct :: !(Maybe SdtmProductRef) -- ^ "parentProduct"
  , sdtmDatasetLinksParentClass :: !(Maybe SdtmClassRef) -- ^ "parentClass"
  , sdtmDatasetLinksPriorVersion :: !(Maybe SdtmDatasetRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDatasetLinks
instance A.FromJSON SdtmDatasetLinks where
  parseJSON = A.withObject "SdtmDatasetLinks" $ \o ->
    SdtmDatasetLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "priorVersion")

-- | ToJSON SdtmDatasetLinks
instance A.ToJSON SdtmDatasetLinks where
  toJSON SdtmDatasetLinks {..} =
   _omitNulls
      [ "self" .= sdtmDatasetLinksSelf
      , "parentProduct" .= sdtmDatasetLinksParentProduct
      , "parentClass" .= sdtmDatasetLinksParentClass
      , "priorVersion" .= sdtmDatasetLinksPriorVersion
      ]


-- | Construct a value of type 'SdtmDatasetLinks' (by applying it's required fields, if any)
mkSdtmDatasetLinks
  :: SdtmDatasetLinks
mkSdtmDatasetLinks =
  SdtmDatasetLinks
  { sdtmDatasetLinksSelf = Nothing
  , sdtmDatasetLinksParentProduct = Nothing
  , sdtmDatasetLinksParentClass = Nothing
  , sdtmDatasetLinksPriorVersion = Nothing
  }

-- ** SdtmDatasetRef
-- | SdtmDatasetRef
data SdtmDatasetRef = SdtmDatasetRef
  { sdtmDatasetRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmDatasetRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmDatasetRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDatasetRef
instance A.FromJSON SdtmDatasetRef where
  parseJSON = A.withObject "SdtmDatasetRef" $ \o ->
    SdtmDatasetRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmDatasetRef
instance A.ToJSON SdtmDatasetRef where
  toJSON SdtmDatasetRef {..} =
   _omitNulls
      [ "href" .= sdtmDatasetRefHref
      , "title" .= sdtmDatasetRefTitle
      , "type" .= sdtmDatasetRefType
      ]


-- | Construct a value of type 'SdtmDatasetRef' (by applying it's required fields, if any)
mkSdtmDatasetRef
  :: SdtmDatasetRef
mkSdtmDatasetRef =
  SdtmDatasetRef
  { sdtmDatasetRefHref = Nothing
  , sdtmDatasetRefTitle = Nothing
  , sdtmDatasetRefType = Nothing
  }

-- ** SdtmDatasetRefElement
-- | SdtmDatasetRefElement
data SdtmDatasetRefElement = SdtmDatasetRefElement
  { sdtmDatasetRefElementHref :: !(Maybe Text) -- ^ "href"
  , sdtmDatasetRefElementTitle :: !(Maybe Text) -- ^ "title"
  , sdtmDatasetRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDatasetRefElement
instance A.FromJSON SdtmDatasetRefElement where
  parseJSON = A.withObject "SdtmDatasetRefElement" $ \o ->
    SdtmDatasetRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmDatasetRefElement
instance A.ToJSON SdtmDatasetRefElement where
  toJSON SdtmDatasetRefElement {..} =
   _omitNulls
      [ "href" .= sdtmDatasetRefElementHref
      , "title" .= sdtmDatasetRefElementTitle
      , "type" .= sdtmDatasetRefElementType
      ]


-- | Construct a value of type 'SdtmDatasetRefElement' (by applying it's required fields, if any)
mkSdtmDatasetRefElement
  :: SdtmDatasetRefElement
mkSdtmDatasetRefElement =
  SdtmDatasetRefElement
  { sdtmDatasetRefElementHref = Nothing
  , sdtmDatasetRefElementTitle = Nothing
  , sdtmDatasetRefElementType = Nothing
  }

-- ** SdtmDatasetVariable
-- | SdtmDatasetVariable
data SdtmDatasetVariable = SdtmDatasetVariable
  { sdtmDatasetVariableOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sdtmDatasetVariableName :: !(Maybe Text) -- ^ "name"
  , sdtmDatasetVariableLabel :: !(Maybe Text) -- ^ "label"
  , sdtmDatasetVariableDescription :: !(Maybe Text) -- ^ "description"
  , sdtmDatasetVariableRole :: !(Maybe Text) -- ^ "role"
  , sdtmDatasetVariableRoleDescription :: !(Maybe Text) -- ^ "roleDescription"
  , sdtmDatasetVariableSimpleDatatype :: !(Maybe Text) -- ^ "simpleDatatype"
  , sdtmDatasetVariableDescribedValueDomain :: !(Maybe Text) -- ^ "describedValueDomain"
  , sdtmDatasetVariableLinks :: !(Maybe SdtmDatasetVariableLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDatasetVariable
instance A.FromJSON SdtmDatasetVariable where
  parseJSON = A.withObject "SdtmDatasetVariable" $ \o ->
    SdtmDatasetVariable
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "role")
      <*> (o .:? "roleDescription")
      <*> (o .:? "simpleDatatype")
      <*> (o .:? "describedValueDomain")
      <*> (o .:? "_links")

-- | ToJSON SdtmDatasetVariable
instance A.ToJSON SdtmDatasetVariable where
  toJSON SdtmDatasetVariable {..} =
   _omitNulls
      [ "ordinal" .= sdtmDatasetVariableOrdinal
      , "name" .= sdtmDatasetVariableName
      , "label" .= sdtmDatasetVariableLabel
      , "description" .= sdtmDatasetVariableDescription
      , "role" .= sdtmDatasetVariableRole
      , "roleDescription" .= sdtmDatasetVariableRoleDescription
      , "simpleDatatype" .= sdtmDatasetVariableSimpleDatatype
      , "describedValueDomain" .= sdtmDatasetVariableDescribedValueDomain
      , "_links" .= sdtmDatasetVariableLinks
      ]


-- | Construct a value of type 'SdtmDatasetVariable' (by applying it's required fields, if any)
mkSdtmDatasetVariable
  :: SdtmDatasetVariable
mkSdtmDatasetVariable =
  SdtmDatasetVariable
  { sdtmDatasetVariableOrdinal = Nothing
  , sdtmDatasetVariableName = Nothing
  , sdtmDatasetVariableLabel = Nothing
  , sdtmDatasetVariableDescription = Nothing
  , sdtmDatasetVariableRole = Nothing
  , sdtmDatasetVariableRoleDescription = Nothing
  , sdtmDatasetVariableSimpleDatatype = Nothing
  , sdtmDatasetVariableDescribedValueDomain = Nothing
  , sdtmDatasetVariableLinks = Nothing
  }

-- ** SdtmDatasetVariableLinks
-- | SdtmDatasetVariableLinks
data SdtmDatasetVariableLinks = SdtmDatasetVariableLinks
  { sdtmDatasetVariableLinksSelf :: !(Maybe SdtmDatasetVariableRef) -- ^ "self"
  , sdtmDatasetVariableLinksParentProduct :: !(Maybe SdtmProductRef) -- ^ "parentProduct"
  , sdtmDatasetVariableLinksParentDataset :: !(Maybe SdtmDatasetRef) -- ^ "parentDataset"
  , sdtmDatasetVariableLinksRootItem :: !(Maybe RootSdtmDatasetVariableRef) -- ^ "rootItem"
  , sdtmDatasetVariableLinksPriorVersion :: !(Maybe SdtmDatasetVariableRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDatasetVariableLinks
instance A.FromJSON SdtmDatasetVariableLinks where
  parseJSON = A.withObject "SdtmDatasetVariableLinks" $ \o ->
    SdtmDatasetVariableLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentDataset")
      <*> (o .:? "rootItem")
      <*> (o .:? "priorVersion")

-- | ToJSON SdtmDatasetVariableLinks
instance A.ToJSON SdtmDatasetVariableLinks where
  toJSON SdtmDatasetVariableLinks {..} =
   _omitNulls
      [ "self" .= sdtmDatasetVariableLinksSelf
      , "parentProduct" .= sdtmDatasetVariableLinksParentProduct
      , "parentDataset" .= sdtmDatasetVariableLinksParentDataset
      , "rootItem" .= sdtmDatasetVariableLinksRootItem
      , "priorVersion" .= sdtmDatasetVariableLinksPriorVersion
      ]


-- | Construct a value of type 'SdtmDatasetVariableLinks' (by applying it's required fields, if any)
mkSdtmDatasetVariableLinks
  :: SdtmDatasetVariableLinks
mkSdtmDatasetVariableLinks =
  SdtmDatasetVariableLinks
  { sdtmDatasetVariableLinksSelf = Nothing
  , sdtmDatasetVariableLinksParentProduct = Nothing
  , sdtmDatasetVariableLinksParentDataset = Nothing
  , sdtmDatasetVariableLinksRootItem = Nothing
  , sdtmDatasetVariableLinksPriorVersion = Nothing
  }

-- ** SdtmDatasetVariableRef
-- | SdtmDatasetVariableRef
data SdtmDatasetVariableRef = SdtmDatasetVariableRef
  { sdtmDatasetVariableRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmDatasetVariableRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmDatasetVariableRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDatasetVariableRef
instance A.FromJSON SdtmDatasetVariableRef where
  parseJSON = A.withObject "SdtmDatasetVariableRef" $ \o ->
    SdtmDatasetVariableRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmDatasetVariableRef
instance A.ToJSON SdtmDatasetVariableRef where
  toJSON SdtmDatasetVariableRef {..} =
   _omitNulls
      [ "href" .= sdtmDatasetVariableRefHref
      , "title" .= sdtmDatasetVariableRefTitle
      , "type" .= sdtmDatasetVariableRefType
      ]


-- | Construct a value of type 'SdtmDatasetVariableRef' (by applying it's required fields, if any)
mkSdtmDatasetVariableRef
  :: SdtmDatasetVariableRef
mkSdtmDatasetVariableRef =
  SdtmDatasetVariableRef
  { sdtmDatasetVariableRefHref = Nothing
  , sdtmDatasetVariableRefTitle = Nothing
  , sdtmDatasetVariableRefType = Nothing
  }

-- ** SdtmDatasetVariableRefElement
-- | SdtmDatasetVariableRefElement
data SdtmDatasetVariableRefElement = SdtmDatasetVariableRefElement
  { sdtmDatasetVariableRefElementHref :: !(Maybe Text) -- ^ "href"
  , sdtmDatasetVariableRefElementTitle :: !(Maybe Text) -- ^ "title"
  , sdtmDatasetVariableRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDatasetVariableRefElement
instance A.FromJSON SdtmDatasetVariableRefElement where
  parseJSON = A.withObject "SdtmDatasetVariableRefElement" $ \o ->
    SdtmDatasetVariableRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmDatasetVariableRefElement
instance A.ToJSON SdtmDatasetVariableRefElement where
  toJSON SdtmDatasetVariableRefElement {..} =
   _omitNulls
      [ "href" .= sdtmDatasetVariableRefElementHref
      , "title" .= sdtmDatasetVariableRefElementTitle
      , "type" .= sdtmDatasetVariableRefElementType
      ]


-- | Construct a value of type 'SdtmDatasetVariableRefElement' (by applying it's required fields, if any)
mkSdtmDatasetVariableRefElement
  :: SdtmDatasetVariableRefElement
mkSdtmDatasetVariableRefElement =
  SdtmDatasetVariableRefElement
  { sdtmDatasetVariableRefElementHref = Nothing
  , sdtmDatasetVariableRefElementTitle = Nothing
  , sdtmDatasetVariableRefElementType = Nothing
  }

-- ** SdtmDatasetVariableRefTarget
-- | SdtmDatasetVariableRefTarget
data SdtmDatasetVariableRefTarget = SdtmDatasetVariableRefTarget
  { sdtmDatasetVariableRefTargetHref :: !(Maybe Text) -- ^ "href"
  , sdtmDatasetVariableRefTargetTitle :: !(Maybe Text) -- ^ "title"
  , sdtmDatasetVariableRefTargetType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDatasetVariableRefTarget
instance A.FromJSON SdtmDatasetVariableRefTarget where
  parseJSON = A.withObject "SdtmDatasetVariableRefTarget" $ \o ->
    SdtmDatasetVariableRefTarget
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmDatasetVariableRefTarget
instance A.ToJSON SdtmDatasetVariableRefTarget where
  toJSON SdtmDatasetVariableRefTarget {..} =
   _omitNulls
      [ "href" .= sdtmDatasetVariableRefTargetHref
      , "title" .= sdtmDatasetVariableRefTargetTitle
      , "type" .= sdtmDatasetVariableRefTargetType
      ]


-- | Construct a value of type 'SdtmDatasetVariableRefTarget' (by applying it's required fields, if any)
mkSdtmDatasetVariableRefTarget
  :: SdtmDatasetVariableRefTarget
mkSdtmDatasetVariableRefTarget =
  SdtmDatasetVariableRefTarget
  { sdtmDatasetVariableRefTargetHref = Nothing
  , sdtmDatasetVariableRefTargetTitle = Nothing
  , sdtmDatasetVariableRefTargetType = Nothing
  }

-- ** SdtmDatasetVariableRefVersion
-- | SdtmDatasetVariableRefVersion
data SdtmDatasetVariableRefVersion = SdtmDatasetVariableRefVersion
  { sdtmDatasetVariableRefVersionHref :: !(Maybe Text) -- ^ "href"
  , sdtmDatasetVariableRefVersionTitle :: !(Maybe Text) -- ^ "title"
  , sdtmDatasetVariableRefVersionType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDatasetVariableRefVersion
instance A.FromJSON SdtmDatasetVariableRefVersion where
  parseJSON = A.withObject "SdtmDatasetVariableRefVersion" $ \o ->
    SdtmDatasetVariableRefVersion
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmDatasetVariableRefVersion
instance A.ToJSON SdtmDatasetVariableRefVersion where
  toJSON SdtmDatasetVariableRefVersion {..} =
   _omitNulls
      [ "href" .= sdtmDatasetVariableRefVersionHref
      , "title" .= sdtmDatasetVariableRefVersionTitle
      , "type" .= sdtmDatasetVariableRefVersionType
      ]


-- | Construct a value of type 'SdtmDatasetVariableRefVersion' (by applying it's required fields, if any)
mkSdtmDatasetVariableRefVersion
  :: SdtmDatasetVariableRefVersion
mkSdtmDatasetVariableRefVersion =
  SdtmDatasetVariableRefVersion
  { sdtmDatasetVariableRefVersionHref = Nothing
  , sdtmDatasetVariableRefVersionTitle = Nothing
  , sdtmDatasetVariableRefVersionType = Nothing
  }

-- ** SdtmDatasetVariables
-- | SdtmDatasetVariables
data SdtmDatasetVariables = SdtmDatasetVariables
  { sdtmDatasetVariablesOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sdtmDatasetVariablesName :: !(Maybe Text) -- ^ "name"
  , sdtmDatasetVariablesLabel :: !(Maybe Text) -- ^ "label"
  , sdtmDatasetVariablesDescription :: !(Maybe Text) -- ^ "description"
  , sdtmDatasetVariablesDatasetStructure :: !(Maybe Text) -- ^ "datasetStructure"
  , sdtmDatasetVariablesLinks :: !(Maybe SdtmDatasetVariablesLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDatasetVariables
instance A.FromJSON SdtmDatasetVariables where
  parseJSON = A.withObject "SdtmDatasetVariables" $ \o ->
    SdtmDatasetVariables
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "datasetStructure")
      <*> (o .:? "_links")

-- | ToJSON SdtmDatasetVariables
instance A.ToJSON SdtmDatasetVariables where
  toJSON SdtmDatasetVariables {..} =
   _omitNulls
      [ "ordinal" .= sdtmDatasetVariablesOrdinal
      , "name" .= sdtmDatasetVariablesName
      , "label" .= sdtmDatasetVariablesLabel
      , "description" .= sdtmDatasetVariablesDescription
      , "datasetStructure" .= sdtmDatasetVariablesDatasetStructure
      , "_links" .= sdtmDatasetVariablesLinks
      ]


-- | Construct a value of type 'SdtmDatasetVariables' (by applying it's required fields, if any)
mkSdtmDatasetVariables
  :: SdtmDatasetVariables
mkSdtmDatasetVariables =
  SdtmDatasetVariables
  { sdtmDatasetVariablesOrdinal = Nothing
  , sdtmDatasetVariablesName = Nothing
  , sdtmDatasetVariablesLabel = Nothing
  , sdtmDatasetVariablesDescription = Nothing
  , sdtmDatasetVariablesDatasetStructure = Nothing
  , sdtmDatasetVariablesLinks = Nothing
  }

-- ** SdtmDatasetVariablesLinks
-- | SdtmDatasetVariablesLinks
data SdtmDatasetVariablesLinks = SdtmDatasetVariablesLinks
  { sdtmDatasetVariablesLinksSelf :: !(Maybe SdtmDatasetVariablesRef) -- ^ "self"
  , sdtmDatasetVariablesLinksParentProduct :: !(Maybe SdtmProductRef) -- ^ "parentProduct"
  , sdtmDatasetVariablesLinksParentClass :: !(Maybe SdtmClassRef) -- ^ "parentClass"
  , sdtmDatasetVariablesLinksPriorVersion :: !(Maybe SdtmDatasetVariablesRef) -- ^ "priorVersion"
  , sdtmDatasetVariablesLinksDatasetVariables :: !(Maybe [SdtmDatasetVariableRefElement]) -- ^ "datasetVariables"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDatasetVariablesLinks
instance A.FromJSON SdtmDatasetVariablesLinks where
  parseJSON = A.withObject "SdtmDatasetVariablesLinks" $ \o ->
    SdtmDatasetVariablesLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "priorVersion")
      <*> (o .:? "datasetVariables")

-- | ToJSON SdtmDatasetVariablesLinks
instance A.ToJSON SdtmDatasetVariablesLinks where
  toJSON SdtmDatasetVariablesLinks {..} =
   _omitNulls
      [ "self" .= sdtmDatasetVariablesLinksSelf
      , "parentProduct" .= sdtmDatasetVariablesLinksParentProduct
      , "parentClass" .= sdtmDatasetVariablesLinksParentClass
      , "priorVersion" .= sdtmDatasetVariablesLinksPriorVersion
      , "datasetVariables" .= sdtmDatasetVariablesLinksDatasetVariables
      ]


-- | Construct a value of type 'SdtmDatasetVariablesLinks' (by applying it's required fields, if any)
mkSdtmDatasetVariablesLinks
  :: SdtmDatasetVariablesLinks
mkSdtmDatasetVariablesLinks =
  SdtmDatasetVariablesLinks
  { sdtmDatasetVariablesLinksSelf = Nothing
  , sdtmDatasetVariablesLinksParentProduct = Nothing
  , sdtmDatasetVariablesLinksParentClass = Nothing
  , sdtmDatasetVariablesLinksPriorVersion = Nothing
  , sdtmDatasetVariablesLinksDatasetVariables = Nothing
  }

-- ** SdtmDatasetVariablesRef
-- | SdtmDatasetVariablesRef
data SdtmDatasetVariablesRef = SdtmDatasetVariablesRef
  { sdtmDatasetVariablesRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmDatasetVariablesRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmDatasetVariablesRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDatasetVariablesRef
instance A.FromJSON SdtmDatasetVariablesRef where
  parseJSON = A.withObject "SdtmDatasetVariablesRef" $ \o ->
    SdtmDatasetVariablesRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmDatasetVariablesRef
instance A.ToJSON SdtmDatasetVariablesRef where
  toJSON SdtmDatasetVariablesRef {..} =
   _omitNulls
      [ "href" .= sdtmDatasetVariablesRefHref
      , "title" .= sdtmDatasetVariablesRefTitle
      , "type" .= sdtmDatasetVariablesRefType
      ]


-- | Construct a value of type 'SdtmDatasetVariablesRef' (by applying it's required fields, if any)
mkSdtmDatasetVariablesRef
  :: SdtmDatasetVariablesRef
mkSdtmDatasetVariablesRef =
  SdtmDatasetVariablesRef
  { sdtmDatasetVariablesRefHref = Nothing
  , sdtmDatasetVariablesRefTitle = Nothing
  , sdtmDatasetVariablesRefType = Nothing
  }

-- ** SdtmDatasets
-- | SdtmDatasets
data SdtmDatasets = SdtmDatasets
  { sdtmDatasetsName :: !(Maybe Text) -- ^ "name"
  , sdtmDatasetsLabel :: !(Maybe Text) -- ^ "label"
  , sdtmDatasetsDescription :: !(Maybe Text) -- ^ "description"
  , sdtmDatasetsSource :: !(Maybe Text) -- ^ "source"
  , sdtmDatasetsEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , sdtmDatasetsRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , sdtmDatasetsVersion :: !(Maybe Text) -- ^ "version"
  , sdtmDatasetsLinks :: !(Maybe SdtmDatasetsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDatasets
instance A.FromJSON SdtmDatasets where
  parseJSON = A.withObject "SdtmDatasets" $ \o ->
    SdtmDatasets
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")

-- | ToJSON SdtmDatasets
instance A.ToJSON SdtmDatasets where
  toJSON SdtmDatasets {..} =
   _omitNulls
      [ "name" .= sdtmDatasetsName
      , "label" .= sdtmDatasetsLabel
      , "description" .= sdtmDatasetsDescription
      , "source" .= sdtmDatasetsSource
      , "effectiveDate" .= sdtmDatasetsEffectiveDate
      , "registrationStatus" .= sdtmDatasetsRegistrationStatus
      , "version" .= sdtmDatasetsVersion
      , "_links" .= sdtmDatasetsLinks
      ]


-- | Construct a value of type 'SdtmDatasets' (by applying it's required fields, if any)
mkSdtmDatasets
  :: SdtmDatasets
mkSdtmDatasets =
  SdtmDatasets
  { sdtmDatasetsName = Nothing
  , sdtmDatasetsLabel = Nothing
  , sdtmDatasetsDescription = Nothing
  , sdtmDatasetsSource = Nothing
  , sdtmDatasetsEffectiveDate = Nothing
  , sdtmDatasetsRegistrationStatus = Nothing
  , sdtmDatasetsVersion = Nothing
  , sdtmDatasetsLinks = Nothing
  }

-- ** SdtmDatasetsLinks
-- | SdtmDatasetsLinks
data SdtmDatasetsLinks = SdtmDatasetsLinks
  { sdtmDatasetsLinksSelf :: !(Maybe SdtmDatasetsRef) -- ^ "self"
  , sdtmDatasetsLinksParentProduct :: !(Maybe SdtmProductRef) -- ^ "parentProduct"
  , sdtmDatasetsLinksPriorVersion :: !(Maybe SdtmDatasetsRef) -- ^ "priorVersion"
  , sdtmDatasetsLinksDatasets :: !(Maybe [SdtmDatasetRefElement]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDatasetsLinks
instance A.FromJSON SdtmDatasetsLinks where
  parseJSON = A.withObject "SdtmDatasetsLinks" $ \o ->
    SdtmDatasetsLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "priorVersion")
      <*> (o .:? "datasets")

-- | ToJSON SdtmDatasetsLinks
instance A.ToJSON SdtmDatasetsLinks where
  toJSON SdtmDatasetsLinks {..} =
   _omitNulls
      [ "self" .= sdtmDatasetsLinksSelf
      , "parentProduct" .= sdtmDatasetsLinksParentProduct
      , "priorVersion" .= sdtmDatasetsLinksPriorVersion
      , "datasets" .= sdtmDatasetsLinksDatasets
      ]


-- | Construct a value of type 'SdtmDatasetsLinks' (by applying it's required fields, if any)
mkSdtmDatasetsLinks
  :: SdtmDatasetsLinks
mkSdtmDatasetsLinks =
  SdtmDatasetsLinks
  { sdtmDatasetsLinksSelf = Nothing
  , sdtmDatasetsLinksParentProduct = Nothing
  , sdtmDatasetsLinksPriorVersion = Nothing
  , sdtmDatasetsLinksDatasets = Nothing
  }

-- ** SdtmDatasetsRef
-- | SdtmDatasetsRef
data SdtmDatasetsRef = SdtmDatasetsRef
  { sdtmDatasetsRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmDatasetsRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmDatasetsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmDatasetsRef
instance A.FromJSON SdtmDatasetsRef where
  parseJSON = A.withObject "SdtmDatasetsRef" $ \o ->
    SdtmDatasetsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmDatasetsRef
instance A.ToJSON SdtmDatasetsRef where
  toJSON SdtmDatasetsRef {..} =
   _omitNulls
      [ "href" .= sdtmDatasetsRefHref
      , "title" .= sdtmDatasetsRefTitle
      , "type" .= sdtmDatasetsRefType
      ]


-- | Construct a value of type 'SdtmDatasetsRef' (by applying it's required fields, if any)
mkSdtmDatasetsRef
  :: SdtmDatasetsRef
mkSdtmDatasetsRef =
  SdtmDatasetsRef
  { sdtmDatasetsRefHref = Nothing
  , sdtmDatasetsRefTitle = Nothing
  , sdtmDatasetsRefType = Nothing
  }

-- ** SdtmProduct
-- | SdtmProduct
data SdtmProduct = SdtmProduct
  { sdtmProductName :: !(Maybe Text) -- ^ "name"
  , sdtmProductLabel :: !(Maybe Text) -- ^ "label"
  , sdtmProductDescription :: !(Maybe Text) -- ^ "description"
  , sdtmProductSource :: !(Maybe Text) -- ^ "source"
  , sdtmProductEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , sdtmProductRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , sdtmProductVersion :: !(Maybe Text) -- ^ "version"
  , sdtmProductLinks :: !(Maybe SdtmProductLinks) -- ^ "_links"
  , sdtmProductClasses :: !(Maybe [SdtmClass]) -- ^ "classes"
  , sdtmProductDatasets :: !(Maybe [SdtmDataset]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmProduct
instance A.FromJSON SdtmProduct where
  parseJSON = A.withObject "SdtmProduct" $ \o ->
    SdtmProduct
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")
      <*> (o .:? "classes")
      <*> (o .:? "datasets")

-- | ToJSON SdtmProduct
instance A.ToJSON SdtmProduct where
  toJSON SdtmProduct {..} =
   _omitNulls
      [ "name" .= sdtmProductName
      , "label" .= sdtmProductLabel
      , "description" .= sdtmProductDescription
      , "source" .= sdtmProductSource
      , "effectiveDate" .= sdtmProductEffectiveDate
      , "registrationStatus" .= sdtmProductRegistrationStatus
      , "version" .= sdtmProductVersion
      , "_links" .= sdtmProductLinks
      , "classes" .= sdtmProductClasses
      , "datasets" .= sdtmProductDatasets
      ]


-- | Construct a value of type 'SdtmProduct' (by applying it's required fields, if any)
mkSdtmProduct
  :: SdtmProduct
mkSdtmProduct =
  SdtmProduct
  { sdtmProductName = Nothing
  , sdtmProductLabel = Nothing
  , sdtmProductDescription = Nothing
  , sdtmProductSource = Nothing
  , sdtmProductEffectiveDate = Nothing
  , sdtmProductRegistrationStatus = Nothing
  , sdtmProductVersion = Nothing
  , sdtmProductLinks = Nothing
  , sdtmProductClasses = Nothing
  , sdtmProductDatasets = Nothing
  }

-- ** SdtmProductLinks
-- | SdtmProductLinks
data SdtmProductLinks = SdtmProductLinks
  { sdtmProductLinksSelf :: !(Maybe SdtmProductRef) -- ^ "self"
  , sdtmProductLinksPriorVersion :: !(Maybe SdtmProductRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmProductLinks
instance A.FromJSON SdtmProductLinks where
  parseJSON = A.withObject "SdtmProductLinks" $ \o ->
    SdtmProductLinks
      <$> (o .:? "self")
      <*> (o .:? "priorVersion")

-- | ToJSON SdtmProductLinks
instance A.ToJSON SdtmProductLinks where
  toJSON SdtmProductLinks {..} =
   _omitNulls
      [ "self" .= sdtmProductLinksSelf
      , "priorVersion" .= sdtmProductLinksPriorVersion
      ]


-- | Construct a value of type 'SdtmProductLinks' (by applying it's required fields, if any)
mkSdtmProductLinks
  :: SdtmProductLinks
mkSdtmProductLinks =
  SdtmProductLinks
  { sdtmProductLinksSelf = Nothing
  , sdtmProductLinksPriorVersion = Nothing
  }

-- ** SdtmProductRef
-- | SdtmProductRef
data SdtmProductRef = SdtmProductRef
  { sdtmProductRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmProductRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmProductRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmProductRef
instance A.FromJSON SdtmProductRef where
  parseJSON = A.withObject "SdtmProductRef" $ \o ->
    SdtmProductRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmProductRef
instance A.ToJSON SdtmProductRef where
  toJSON SdtmProductRef {..} =
   _omitNulls
      [ "href" .= sdtmProductRefHref
      , "title" .= sdtmProductRefTitle
      , "type" .= sdtmProductRefType
      ]


-- | Construct a value of type 'SdtmProductRef' (by applying it's required fields, if any)
mkSdtmProductRef
  :: SdtmProductRef
mkSdtmProductRef =
  SdtmProductRef
  { sdtmProductRefHref = Nothing
  , sdtmProductRefTitle = Nothing
  , sdtmProductRefType = Nothing
  }

-- ** SdtmProductRefElement
-- | SdtmProductRefElement
data SdtmProductRefElement = SdtmProductRefElement
  { sdtmProductRefElementHref :: !(Maybe Text) -- ^ "href"
  , sdtmProductRefElementTitle :: !(Maybe Text) -- ^ "title"
  , sdtmProductRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmProductRefElement
instance A.FromJSON SdtmProductRefElement where
  parseJSON = A.withObject "SdtmProductRefElement" $ \o ->
    SdtmProductRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmProductRefElement
instance A.ToJSON SdtmProductRefElement where
  toJSON SdtmProductRefElement {..} =
   _omitNulls
      [ "href" .= sdtmProductRefElementHref
      , "title" .= sdtmProductRefElementTitle
      , "type" .= sdtmProductRefElementType
      ]


-- | Construct a value of type 'SdtmProductRefElement' (by applying it's required fields, if any)
mkSdtmProductRefElement
  :: SdtmProductRefElement
mkSdtmProductRefElement =
  SdtmProductRefElement
  { sdtmProductRefElementHref = Nothing
  , sdtmProductRefElementTitle = Nothing
  , sdtmProductRefElementType = Nothing
  }

-- ** SdtmigClass
-- | SdtmigClass
data SdtmigClass = SdtmigClass
  { sdtmigClassOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sdtmigClassName :: !(Maybe Text) -- ^ "name"
  , sdtmigClassLabel :: !(Maybe Text) -- ^ "label"
  , sdtmigClassDescription :: !(Maybe Text) -- ^ "description"
  , sdtmigClassLinks :: !(Maybe SdtmigClassLinks) -- ^ "_links"
  , sdtmigClassDatasets :: !(Maybe [SdtmigDataset]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigClass
instance A.FromJSON SdtmigClass where
  parseJSON = A.withObject "SdtmigClass" $ \o ->
    SdtmigClass
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "_links")
      <*> (o .:? "datasets")

-- | ToJSON SdtmigClass
instance A.ToJSON SdtmigClass where
  toJSON SdtmigClass {..} =
   _omitNulls
      [ "ordinal" .= sdtmigClassOrdinal
      , "name" .= sdtmigClassName
      , "label" .= sdtmigClassLabel
      , "description" .= sdtmigClassDescription
      , "_links" .= sdtmigClassLinks
      , "datasets" .= sdtmigClassDatasets
      ]


-- | Construct a value of type 'SdtmigClass' (by applying it's required fields, if any)
mkSdtmigClass
  :: SdtmigClass
mkSdtmigClass =
  SdtmigClass
  { sdtmigClassOrdinal = Nothing
  , sdtmigClassName = Nothing
  , sdtmigClassLabel = Nothing
  , sdtmigClassDescription = Nothing
  , sdtmigClassLinks = Nothing
  , sdtmigClassDatasets = Nothing
  }

-- ** SdtmigClassDatasets
-- | SdtmigClassDatasets
data SdtmigClassDatasets = SdtmigClassDatasets
  { sdtmigClassDatasetsOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sdtmigClassDatasetsName :: !(Maybe Text) -- ^ "name"
  , sdtmigClassDatasetsLabel :: !(Maybe Text) -- ^ "label"
  , sdtmigClassDatasetsDescription :: !(Maybe Text) -- ^ "description"
  , sdtmigClassDatasetsLinks :: !(Maybe SdtmigClassDatasetsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigClassDatasets
instance A.FromJSON SdtmigClassDatasets where
  parseJSON = A.withObject "SdtmigClassDatasets" $ \o ->
    SdtmigClassDatasets
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "_links")

-- | ToJSON SdtmigClassDatasets
instance A.ToJSON SdtmigClassDatasets where
  toJSON SdtmigClassDatasets {..} =
   _omitNulls
      [ "ordinal" .= sdtmigClassDatasetsOrdinal
      , "name" .= sdtmigClassDatasetsName
      , "label" .= sdtmigClassDatasetsLabel
      , "description" .= sdtmigClassDatasetsDescription
      , "_links" .= sdtmigClassDatasetsLinks
      ]


-- | Construct a value of type 'SdtmigClassDatasets' (by applying it's required fields, if any)
mkSdtmigClassDatasets
  :: SdtmigClassDatasets
mkSdtmigClassDatasets =
  SdtmigClassDatasets
  { sdtmigClassDatasetsOrdinal = Nothing
  , sdtmigClassDatasetsName = Nothing
  , sdtmigClassDatasetsLabel = Nothing
  , sdtmigClassDatasetsDescription = Nothing
  , sdtmigClassDatasetsLinks = Nothing
  }

-- ** SdtmigClassDatasetsLinks
-- | SdtmigClassDatasetsLinks
data SdtmigClassDatasetsLinks = SdtmigClassDatasetsLinks
  { sdtmigClassDatasetsLinksSelf :: !(Maybe SdtmigClassDatasetsRef) -- ^ "self"
  , sdtmigClassDatasetsLinksParentProduct :: !(Maybe SdtmigProductRef) -- ^ "parentProduct"
  , sdtmigClassDatasetsLinksPriorVersion :: !(Maybe SdtmigClassDatasetsRef) -- ^ "priorVersion"
  , sdtmigClassDatasetsLinksDatasets :: !(Maybe [SdtmigDatasetRefElement]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigClassDatasetsLinks
instance A.FromJSON SdtmigClassDatasetsLinks where
  parseJSON = A.withObject "SdtmigClassDatasetsLinks" $ \o ->
    SdtmigClassDatasetsLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "priorVersion")
      <*> (o .:? "datasets")

-- | ToJSON SdtmigClassDatasetsLinks
instance A.ToJSON SdtmigClassDatasetsLinks where
  toJSON SdtmigClassDatasetsLinks {..} =
   _omitNulls
      [ "self" .= sdtmigClassDatasetsLinksSelf
      , "parentProduct" .= sdtmigClassDatasetsLinksParentProduct
      , "priorVersion" .= sdtmigClassDatasetsLinksPriorVersion
      , "datasets" .= sdtmigClassDatasetsLinksDatasets
      ]


-- | Construct a value of type 'SdtmigClassDatasetsLinks' (by applying it's required fields, if any)
mkSdtmigClassDatasetsLinks
  :: SdtmigClassDatasetsLinks
mkSdtmigClassDatasetsLinks =
  SdtmigClassDatasetsLinks
  { sdtmigClassDatasetsLinksSelf = Nothing
  , sdtmigClassDatasetsLinksParentProduct = Nothing
  , sdtmigClassDatasetsLinksPriorVersion = Nothing
  , sdtmigClassDatasetsLinksDatasets = Nothing
  }

-- ** SdtmigClassDatasetsRef
-- | SdtmigClassDatasetsRef
data SdtmigClassDatasetsRef = SdtmigClassDatasetsRef
  { sdtmigClassDatasetsRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmigClassDatasetsRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmigClassDatasetsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigClassDatasetsRef
instance A.FromJSON SdtmigClassDatasetsRef where
  parseJSON = A.withObject "SdtmigClassDatasetsRef" $ \o ->
    SdtmigClassDatasetsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmigClassDatasetsRef
instance A.ToJSON SdtmigClassDatasetsRef where
  toJSON SdtmigClassDatasetsRef {..} =
   _omitNulls
      [ "href" .= sdtmigClassDatasetsRefHref
      , "title" .= sdtmigClassDatasetsRefTitle
      , "type" .= sdtmigClassDatasetsRefType
      ]


-- | Construct a value of type 'SdtmigClassDatasetsRef' (by applying it's required fields, if any)
mkSdtmigClassDatasetsRef
  :: SdtmigClassDatasetsRef
mkSdtmigClassDatasetsRef =
  SdtmigClassDatasetsRef
  { sdtmigClassDatasetsRefHref = Nothing
  , sdtmigClassDatasetsRefTitle = Nothing
  , sdtmigClassDatasetsRefType = Nothing
  }

-- ** SdtmigClassLinks
-- | SdtmigClassLinks
data SdtmigClassLinks = SdtmigClassLinks
  { sdtmigClassLinksSelf :: !(Maybe SdtmigClassRef) -- ^ "self"
  , sdtmigClassLinksModelClass :: !(Maybe SdtmClassRef) -- ^ "modelClass"
  , sdtmigClassLinksParentProduct :: !(Maybe SdtmigProductRef) -- ^ "parentProduct"
  , sdtmigClassLinksParentClass :: !(Maybe SdtmigClassRef) -- ^ "parentClass"
  , sdtmigClassLinksSubclasses :: !(Maybe [SdtmigClassRefSubclass]) -- ^ "subclasses"
  , sdtmigClassLinksPriorVersion :: !(Maybe SdtmigClassRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigClassLinks
instance A.FromJSON SdtmigClassLinks where
  parseJSON = A.withObject "SdtmigClassLinks" $ \o ->
    SdtmigClassLinks
      <$> (o .:? "self")
      <*> (o .:? "modelClass")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "subclasses")
      <*> (o .:? "priorVersion")

-- | ToJSON SdtmigClassLinks
instance A.ToJSON SdtmigClassLinks where
  toJSON SdtmigClassLinks {..} =
   _omitNulls
      [ "self" .= sdtmigClassLinksSelf
      , "modelClass" .= sdtmigClassLinksModelClass
      , "parentProduct" .= sdtmigClassLinksParentProduct
      , "parentClass" .= sdtmigClassLinksParentClass
      , "subclasses" .= sdtmigClassLinksSubclasses
      , "priorVersion" .= sdtmigClassLinksPriorVersion
      ]


-- | Construct a value of type 'SdtmigClassLinks' (by applying it's required fields, if any)
mkSdtmigClassLinks
  :: SdtmigClassLinks
mkSdtmigClassLinks =
  SdtmigClassLinks
  { sdtmigClassLinksSelf = Nothing
  , sdtmigClassLinksModelClass = Nothing
  , sdtmigClassLinksParentProduct = Nothing
  , sdtmigClassLinksParentClass = Nothing
  , sdtmigClassLinksSubclasses = Nothing
  , sdtmigClassLinksPriorVersion = Nothing
  }

-- ** SdtmigClassRef
-- | SdtmigClassRef
data SdtmigClassRef = SdtmigClassRef
  { sdtmigClassRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmigClassRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmigClassRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigClassRef
instance A.FromJSON SdtmigClassRef where
  parseJSON = A.withObject "SdtmigClassRef" $ \o ->
    SdtmigClassRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmigClassRef
instance A.ToJSON SdtmigClassRef where
  toJSON SdtmigClassRef {..} =
   _omitNulls
      [ "href" .= sdtmigClassRefHref
      , "title" .= sdtmigClassRefTitle
      , "type" .= sdtmigClassRefType
      ]


-- | Construct a value of type 'SdtmigClassRef' (by applying it's required fields, if any)
mkSdtmigClassRef
  :: SdtmigClassRef
mkSdtmigClassRef =
  SdtmigClassRef
  { sdtmigClassRefHref = Nothing
  , sdtmigClassRefTitle = Nothing
  , sdtmigClassRefType = Nothing
  }

-- ** SdtmigClassRefElement
-- | SdtmigClassRefElement
data SdtmigClassRefElement = SdtmigClassRefElement
  { sdtmigClassRefElementHref :: !(Maybe Text) -- ^ "href"
  , sdtmigClassRefElementTitle :: !(Maybe Text) -- ^ "title"
  , sdtmigClassRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigClassRefElement
instance A.FromJSON SdtmigClassRefElement where
  parseJSON = A.withObject "SdtmigClassRefElement" $ \o ->
    SdtmigClassRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmigClassRefElement
instance A.ToJSON SdtmigClassRefElement where
  toJSON SdtmigClassRefElement {..} =
   _omitNulls
      [ "href" .= sdtmigClassRefElementHref
      , "title" .= sdtmigClassRefElementTitle
      , "type" .= sdtmigClassRefElementType
      ]


-- | Construct a value of type 'SdtmigClassRefElement' (by applying it's required fields, if any)
mkSdtmigClassRefElement
  :: SdtmigClassRefElement
mkSdtmigClassRefElement =
  SdtmigClassRefElement
  { sdtmigClassRefElementHref = Nothing
  , sdtmigClassRefElementTitle = Nothing
  , sdtmigClassRefElementType = Nothing
  }

-- ** SdtmigClassRefSubclass
-- | SdtmigClassRefSubclass
data SdtmigClassRefSubclass = SdtmigClassRefSubclass
  { sdtmigClassRefSubclassHref :: !(Maybe Text) -- ^ "href"
  , sdtmigClassRefSubclassTitle :: !(Maybe Text) -- ^ "title"
  , sdtmigClassRefSubclassType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigClassRefSubclass
instance A.FromJSON SdtmigClassRefSubclass where
  parseJSON = A.withObject "SdtmigClassRefSubclass" $ \o ->
    SdtmigClassRefSubclass
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmigClassRefSubclass
instance A.ToJSON SdtmigClassRefSubclass where
  toJSON SdtmigClassRefSubclass {..} =
   _omitNulls
      [ "href" .= sdtmigClassRefSubclassHref
      , "title" .= sdtmigClassRefSubclassTitle
      , "type" .= sdtmigClassRefSubclassType
      ]


-- | Construct a value of type 'SdtmigClassRefSubclass' (by applying it's required fields, if any)
mkSdtmigClassRefSubclass
  :: SdtmigClassRefSubclass
mkSdtmigClassRefSubclass =
  SdtmigClassRefSubclass
  { sdtmigClassRefSubclassHref = Nothing
  , sdtmigClassRefSubclassTitle = Nothing
  , sdtmigClassRefSubclassType = Nothing
  }

-- ** SdtmigClasses
-- | SdtmigClasses
data SdtmigClasses = SdtmigClasses
  { sdtmigClassesName :: !(Maybe Text) -- ^ "name"
  , sdtmigClassesLabel :: !(Maybe Text) -- ^ "label"
  , sdtmigClassesDescription :: !(Maybe Text) -- ^ "description"
  , sdtmigClassesSource :: !(Maybe Text) -- ^ "source"
  , sdtmigClassesEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , sdtmigClassesRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , sdtmigClassesVersion :: !(Maybe Text) -- ^ "version"
  , sdtmigClassesLinks :: !(Maybe SdtmigClassesLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigClasses
instance A.FromJSON SdtmigClasses where
  parseJSON = A.withObject "SdtmigClasses" $ \o ->
    SdtmigClasses
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")

-- | ToJSON SdtmigClasses
instance A.ToJSON SdtmigClasses where
  toJSON SdtmigClasses {..} =
   _omitNulls
      [ "name" .= sdtmigClassesName
      , "label" .= sdtmigClassesLabel
      , "description" .= sdtmigClassesDescription
      , "source" .= sdtmigClassesSource
      , "effectiveDate" .= sdtmigClassesEffectiveDate
      , "registrationStatus" .= sdtmigClassesRegistrationStatus
      , "version" .= sdtmigClassesVersion
      , "_links" .= sdtmigClassesLinks
      ]


-- | Construct a value of type 'SdtmigClasses' (by applying it's required fields, if any)
mkSdtmigClasses
  :: SdtmigClasses
mkSdtmigClasses =
  SdtmigClasses
  { sdtmigClassesName = Nothing
  , sdtmigClassesLabel = Nothing
  , sdtmigClassesDescription = Nothing
  , sdtmigClassesSource = Nothing
  , sdtmigClassesEffectiveDate = Nothing
  , sdtmigClassesRegistrationStatus = Nothing
  , sdtmigClassesVersion = Nothing
  , sdtmigClassesLinks = Nothing
  }

-- ** SdtmigClassesLinks
-- | SdtmigClassesLinks
data SdtmigClassesLinks = SdtmigClassesLinks
  { sdtmigClassesLinksSelf :: !(Maybe SdtmigClassesRef) -- ^ "self"
  , sdtmigClassesLinksPriorVersion :: !(Maybe SdtmigClassesRef) -- ^ "priorVersion"
  , sdtmigClassesLinksClasses :: !(Maybe [SdtmigClassRefElement]) -- ^ "classes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigClassesLinks
instance A.FromJSON SdtmigClassesLinks where
  parseJSON = A.withObject "SdtmigClassesLinks" $ \o ->
    SdtmigClassesLinks
      <$> (o .:? "self")
      <*> (o .:? "priorVersion")
      <*> (o .:? "classes")

-- | ToJSON SdtmigClassesLinks
instance A.ToJSON SdtmigClassesLinks where
  toJSON SdtmigClassesLinks {..} =
   _omitNulls
      [ "self" .= sdtmigClassesLinksSelf
      , "priorVersion" .= sdtmigClassesLinksPriorVersion
      , "classes" .= sdtmigClassesLinksClasses
      ]


-- | Construct a value of type 'SdtmigClassesLinks' (by applying it's required fields, if any)
mkSdtmigClassesLinks
  :: SdtmigClassesLinks
mkSdtmigClassesLinks =
  SdtmigClassesLinks
  { sdtmigClassesLinksSelf = Nothing
  , sdtmigClassesLinksPriorVersion = Nothing
  , sdtmigClassesLinksClasses = Nothing
  }

-- ** SdtmigClassesRef
-- | SdtmigClassesRef
data SdtmigClassesRef = SdtmigClassesRef
  { sdtmigClassesRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmigClassesRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmigClassesRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigClassesRef
instance A.FromJSON SdtmigClassesRef where
  parseJSON = A.withObject "SdtmigClassesRef" $ \o ->
    SdtmigClassesRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmigClassesRef
instance A.ToJSON SdtmigClassesRef where
  toJSON SdtmigClassesRef {..} =
   _omitNulls
      [ "href" .= sdtmigClassesRefHref
      , "title" .= sdtmigClassesRefTitle
      , "type" .= sdtmigClassesRefType
      ]


-- | Construct a value of type 'SdtmigClassesRef' (by applying it's required fields, if any)
mkSdtmigClassesRef
  :: SdtmigClassesRef
mkSdtmigClassesRef =
  SdtmigClassesRef
  { sdtmigClassesRefHref = Nothing
  , sdtmigClassesRefTitle = Nothing
  , sdtmigClassesRefType = Nothing
  }

-- ** SdtmigDataset
-- | SdtmigDataset
data SdtmigDataset = SdtmigDataset
  { sdtmigDatasetOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sdtmigDatasetName :: !(Maybe Text) -- ^ "name"
  , sdtmigDatasetLabel :: !(Maybe Text) -- ^ "label"
  , sdtmigDatasetDescription :: !(Maybe Text) -- ^ "description"
  , sdtmigDatasetDatasetStructure :: !(Maybe Text) -- ^ "datasetStructure"
  , sdtmigDatasetLinks :: !(Maybe SdtmigDatasetLinks) -- ^ "_links"
  , sdtmigDatasetDatasetVariables :: !(Maybe [SdtmigDatasetVariable]) -- ^ "datasetVariables"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDataset
instance A.FromJSON SdtmigDataset where
  parseJSON = A.withObject "SdtmigDataset" $ \o ->
    SdtmigDataset
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "datasetStructure")
      <*> (o .:? "_links")
      <*> (o .:? "datasetVariables")

-- | ToJSON SdtmigDataset
instance A.ToJSON SdtmigDataset where
  toJSON SdtmigDataset {..} =
   _omitNulls
      [ "ordinal" .= sdtmigDatasetOrdinal
      , "name" .= sdtmigDatasetName
      , "label" .= sdtmigDatasetLabel
      , "description" .= sdtmigDatasetDescription
      , "datasetStructure" .= sdtmigDatasetDatasetStructure
      , "_links" .= sdtmigDatasetLinks
      , "datasetVariables" .= sdtmigDatasetDatasetVariables
      ]


-- | Construct a value of type 'SdtmigDataset' (by applying it's required fields, if any)
mkSdtmigDataset
  :: SdtmigDataset
mkSdtmigDataset =
  SdtmigDataset
  { sdtmigDatasetOrdinal = Nothing
  , sdtmigDatasetName = Nothing
  , sdtmigDatasetLabel = Nothing
  , sdtmigDatasetDescription = Nothing
  , sdtmigDatasetDatasetStructure = Nothing
  , sdtmigDatasetLinks = Nothing
  , sdtmigDatasetDatasetVariables = Nothing
  }

-- ** SdtmigDatasetLinks
-- | SdtmigDatasetLinks
data SdtmigDatasetLinks = SdtmigDatasetLinks
  { sdtmigDatasetLinksSelf :: !(Maybe SdtmigDatasetRef) -- ^ "self"
  , sdtmigDatasetLinksModelDataset :: !(Maybe SdtmDatasetRef) -- ^ "modelDataset"
  , sdtmigDatasetLinksParentProduct :: !(Maybe SdtmigProductRef) -- ^ "parentProduct"
  , sdtmigDatasetLinksParentClass :: !(Maybe SdtmigClassRef) -- ^ "parentClass"
  , sdtmigDatasetLinksPriorVersion :: !(Maybe SdtmigDatasetRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDatasetLinks
instance A.FromJSON SdtmigDatasetLinks where
  parseJSON = A.withObject "SdtmigDatasetLinks" $ \o ->
    SdtmigDatasetLinks
      <$> (o .:? "self")
      <*> (o .:? "modelDataset")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "priorVersion")

-- | ToJSON SdtmigDatasetLinks
instance A.ToJSON SdtmigDatasetLinks where
  toJSON SdtmigDatasetLinks {..} =
   _omitNulls
      [ "self" .= sdtmigDatasetLinksSelf
      , "modelDataset" .= sdtmigDatasetLinksModelDataset
      , "parentProduct" .= sdtmigDatasetLinksParentProduct
      , "parentClass" .= sdtmigDatasetLinksParentClass
      , "priorVersion" .= sdtmigDatasetLinksPriorVersion
      ]


-- | Construct a value of type 'SdtmigDatasetLinks' (by applying it's required fields, if any)
mkSdtmigDatasetLinks
  :: SdtmigDatasetLinks
mkSdtmigDatasetLinks =
  SdtmigDatasetLinks
  { sdtmigDatasetLinksSelf = Nothing
  , sdtmigDatasetLinksModelDataset = Nothing
  , sdtmigDatasetLinksParentProduct = Nothing
  , sdtmigDatasetLinksParentClass = Nothing
  , sdtmigDatasetLinksPriorVersion = Nothing
  }

-- ** SdtmigDatasetRef
-- | SdtmigDatasetRef
data SdtmigDatasetRef = SdtmigDatasetRef
  { sdtmigDatasetRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmigDatasetRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmigDatasetRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDatasetRef
instance A.FromJSON SdtmigDatasetRef where
  parseJSON = A.withObject "SdtmigDatasetRef" $ \o ->
    SdtmigDatasetRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmigDatasetRef
instance A.ToJSON SdtmigDatasetRef where
  toJSON SdtmigDatasetRef {..} =
   _omitNulls
      [ "href" .= sdtmigDatasetRefHref
      , "title" .= sdtmigDatasetRefTitle
      , "type" .= sdtmigDatasetRefType
      ]


-- | Construct a value of type 'SdtmigDatasetRef' (by applying it's required fields, if any)
mkSdtmigDatasetRef
  :: SdtmigDatasetRef
mkSdtmigDatasetRef =
  SdtmigDatasetRef
  { sdtmigDatasetRefHref = Nothing
  , sdtmigDatasetRefTitle = Nothing
  , sdtmigDatasetRefType = Nothing
  }

-- ** SdtmigDatasetRefElement
-- | SdtmigDatasetRefElement
data SdtmigDatasetRefElement = SdtmigDatasetRefElement
  { sdtmigDatasetRefElementHref :: !(Maybe Text) -- ^ "href"
  , sdtmigDatasetRefElementTitle :: !(Maybe Text) -- ^ "title"
  , sdtmigDatasetRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDatasetRefElement
instance A.FromJSON SdtmigDatasetRefElement where
  parseJSON = A.withObject "SdtmigDatasetRefElement" $ \o ->
    SdtmigDatasetRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmigDatasetRefElement
instance A.ToJSON SdtmigDatasetRefElement where
  toJSON SdtmigDatasetRefElement {..} =
   _omitNulls
      [ "href" .= sdtmigDatasetRefElementHref
      , "title" .= sdtmigDatasetRefElementTitle
      , "type" .= sdtmigDatasetRefElementType
      ]


-- | Construct a value of type 'SdtmigDatasetRefElement' (by applying it's required fields, if any)
mkSdtmigDatasetRefElement
  :: SdtmigDatasetRefElement
mkSdtmigDatasetRefElement =
  SdtmigDatasetRefElement
  { sdtmigDatasetRefElementHref = Nothing
  , sdtmigDatasetRefElementTitle = Nothing
  , sdtmigDatasetRefElementType = Nothing
  }

-- ** SdtmigDatasetVariable
-- | SdtmigDatasetVariable
data SdtmigDatasetVariable = SdtmigDatasetVariable
  { sdtmigDatasetVariableOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sdtmigDatasetVariableName :: !(Maybe Text) -- ^ "name"
  , sdtmigDatasetVariableLabel :: !(Maybe Text) -- ^ "label"
  , sdtmigDatasetVariableDescription :: !(Maybe Text) -- ^ "description"
  , sdtmigDatasetVariableRole :: !(Maybe Text) -- ^ "role"
  , sdtmigDatasetVariableSimpleDatatype :: !(Maybe Text) -- ^ "simpleDatatype"
  , sdtmigDatasetVariableCore :: !(Maybe Text) -- ^ "core"
  , sdtmigDatasetVariableDescribedValueDomain :: !(Maybe Text) -- ^ "describedValueDomain"
  , sdtmigDatasetVariableValueList :: !(Maybe [Text]) -- ^ "valueList"
  , sdtmigDatasetVariableLinks :: !(Maybe SdtmigDatasetVariableLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDatasetVariable
instance A.FromJSON SdtmigDatasetVariable where
  parseJSON = A.withObject "SdtmigDatasetVariable" $ \o ->
    SdtmigDatasetVariable
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "role")
      <*> (o .:? "simpleDatatype")
      <*> (o .:? "core")
      <*> (o .:? "describedValueDomain")
      <*> (o .:? "valueList")
      <*> (o .:? "_links")

-- | ToJSON SdtmigDatasetVariable
instance A.ToJSON SdtmigDatasetVariable where
  toJSON SdtmigDatasetVariable {..} =
   _omitNulls
      [ "ordinal" .= sdtmigDatasetVariableOrdinal
      , "name" .= sdtmigDatasetVariableName
      , "label" .= sdtmigDatasetVariableLabel
      , "description" .= sdtmigDatasetVariableDescription
      , "role" .= sdtmigDatasetVariableRole
      , "simpleDatatype" .= sdtmigDatasetVariableSimpleDatatype
      , "core" .= sdtmigDatasetVariableCore
      , "describedValueDomain" .= sdtmigDatasetVariableDescribedValueDomain
      , "valueList" .= sdtmigDatasetVariableValueList
      , "_links" .= sdtmigDatasetVariableLinks
      ]


-- | Construct a value of type 'SdtmigDatasetVariable' (by applying it's required fields, if any)
mkSdtmigDatasetVariable
  :: SdtmigDatasetVariable
mkSdtmigDatasetVariable =
  SdtmigDatasetVariable
  { sdtmigDatasetVariableOrdinal = Nothing
  , sdtmigDatasetVariableName = Nothing
  , sdtmigDatasetVariableLabel = Nothing
  , sdtmigDatasetVariableDescription = Nothing
  , sdtmigDatasetVariableRole = Nothing
  , sdtmigDatasetVariableSimpleDatatype = Nothing
  , sdtmigDatasetVariableCore = Nothing
  , sdtmigDatasetVariableDescribedValueDomain = Nothing
  , sdtmigDatasetVariableValueList = Nothing
  , sdtmigDatasetVariableLinks = Nothing
  }

-- ** SdtmigDatasetVariableLinks
-- | SdtmigDatasetVariableLinks
data SdtmigDatasetVariableLinks = SdtmigDatasetVariableLinks
  { sdtmigDatasetVariableLinksSelf :: !(Maybe SdtmigDatasetVariableRef) -- ^ "self"
  , sdtmigDatasetVariableLinksCodelist :: !(Maybe [RootCtCodelistRefElement]) -- ^ "codelist"
  , sdtmigDatasetVariableLinksModelClassVariable :: !(Maybe SdtmClassVariableRef) -- ^ "modelClassVariable"
  , sdtmigDatasetVariableLinksModelDatasetVariable :: !(Maybe SdtmDatasetVariableRef) -- ^ "modelDatasetVariable"
  , sdtmigDatasetVariableLinksParentProduct :: !(Maybe SdtmigProductRef) -- ^ "parentProduct"
  , sdtmigDatasetVariableLinksParentDataset :: !(Maybe SdtmigDatasetRef) -- ^ "parentDataset"
  , sdtmigDatasetVariableLinksRootItem :: !(Maybe RootSdtmigDatasetVariableRef) -- ^ "rootItem"
  , sdtmigDatasetVariableLinksPriorVersion :: !(Maybe SdtmigDatasetVariableRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDatasetVariableLinks
instance A.FromJSON SdtmigDatasetVariableLinks where
  parseJSON = A.withObject "SdtmigDatasetVariableLinks" $ \o ->
    SdtmigDatasetVariableLinks
      <$> (o .:? "self")
      <*> (o .:? "codelist")
      <*> (o .:? "modelClassVariable")
      <*> (o .:? "modelDatasetVariable")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentDataset")
      <*> (o .:? "rootItem")
      <*> (o .:? "priorVersion")

-- | ToJSON SdtmigDatasetVariableLinks
instance A.ToJSON SdtmigDatasetVariableLinks where
  toJSON SdtmigDatasetVariableLinks {..} =
   _omitNulls
      [ "self" .= sdtmigDatasetVariableLinksSelf
      , "codelist" .= sdtmigDatasetVariableLinksCodelist
      , "modelClassVariable" .= sdtmigDatasetVariableLinksModelClassVariable
      , "modelDatasetVariable" .= sdtmigDatasetVariableLinksModelDatasetVariable
      , "parentProduct" .= sdtmigDatasetVariableLinksParentProduct
      , "parentDataset" .= sdtmigDatasetVariableLinksParentDataset
      , "rootItem" .= sdtmigDatasetVariableLinksRootItem
      , "priorVersion" .= sdtmigDatasetVariableLinksPriorVersion
      ]


-- | Construct a value of type 'SdtmigDatasetVariableLinks' (by applying it's required fields, if any)
mkSdtmigDatasetVariableLinks
  :: SdtmigDatasetVariableLinks
mkSdtmigDatasetVariableLinks =
  SdtmigDatasetVariableLinks
  { sdtmigDatasetVariableLinksSelf = Nothing
  , sdtmigDatasetVariableLinksCodelist = Nothing
  , sdtmigDatasetVariableLinksModelClassVariable = Nothing
  , sdtmigDatasetVariableLinksModelDatasetVariable = Nothing
  , sdtmigDatasetVariableLinksParentProduct = Nothing
  , sdtmigDatasetVariableLinksParentDataset = Nothing
  , sdtmigDatasetVariableLinksRootItem = Nothing
  , sdtmigDatasetVariableLinksPriorVersion = Nothing
  }

-- ** SdtmigDatasetVariableRef
-- | SdtmigDatasetVariableRef
data SdtmigDatasetVariableRef = SdtmigDatasetVariableRef
  { sdtmigDatasetVariableRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmigDatasetVariableRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmigDatasetVariableRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDatasetVariableRef
instance A.FromJSON SdtmigDatasetVariableRef where
  parseJSON = A.withObject "SdtmigDatasetVariableRef" $ \o ->
    SdtmigDatasetVariableRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmigDatasetVariableRef
instance A.ToJSON SdtmigDatasetVariableRef where
  toJSON SdtmigDatasetVariableRef {..} =
   _omitNulls
      [ "href" .= sdtmigDatasetVariableRefHref
      , "title" .= sdtmigDatasetVariableRefTitle
      , "type" .= sdtmigDatasetVariableRefType
      ]


-- | Construct a value of type 'SdtmigDatasetVariableRef' (by applying it's required fields, if any)
mkSdtmigDatasetVariableRef
  :: SdtmigDatasetVariableRef
mkSdtmigDatasetVariableRef =
  SdtmigDatasetVariableRef
  { sdtmigDatasetVariableRefHref = Nothing
  , sdtmigDatasetVariableRefTitle = Nothing
  , sdtmigDatasetVariableRefType = Nothing
  }

-- ** SdtmigDatasetVariableRefElement
-- | SdtmigDatasetVariableRefElement
data SdtmigDatasetVariableRefElement = SdtmigDatasetVariableRefElement
  { sdtmigDatasetVariableRefElementHref :: !(Maybe Text) -- ^ "href"
  , sdtmigDatasetVariableRefElementTitle :: !(Maybe Text) -- ^ "title"
  , sdtmigDatasetVariableRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDatasetVariableRefElement
instance A.FromJSON SdtmigDatasetVariableRefElement where
  parseJSON = A.withObject "SdtmigDatasetVariableRefElement" $ \o ->
    SdtmigDatasetVariableRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmigDatasetVariableRefElement
instance A.ToJSON SdtmigDatasetVariableRefElement where
  toJSON SdtmigDatasetVariableRefElement {..} =
   _omitNulls
      [ "href" .= sdtmigDatasetVariableRefElementHref
      , "title" .= sdtmigDatasetVariableRefElementTitle
      , "type" .= sdtmigDatasetVariableRefElementType
      ]


-- | Construct a value of type 'SdtmigDatasetVariableRefElement' (by applying it's required fields, if any)
mkSdtmigDatasetVariableRefElement
  :: SdtmigDatasetVariableRefElement
mkSdtmigDatasetVariableRefElement =
  SdtmigDatasetVariableRefElement
  { sdtmigDatasetVariableRefElementHref = Nothing
  , sdtmigDatasetVariableRefElementTitle = Nothing
  , sdtmigDatasetVariableRefElementType = Nothing
  }

-- ** SdtmigDatasetVariableRefTarget
-- | SdtmigDatasetVariableRefTarget
data SdtmigDatasetVariableRefTarget = SdtmigDatasetVariableRefTarget
  { sdtmigDatasetVariableRefTargetHref :: !(Maybe Text) -- ^ "href"
  , sdtmigDatasetVariableRefTargetTitle :: !(Maybe Text) -- ^ "title"
  , sdtmigDatasetVariableRefTargetType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDatasetVariableRefTarget
instance A.FromJSON SdtmigDatasetVariableRefTarget where
  parseJSON = A.withObject "SdtmigDatasetVariableRefTarget" $ \o ->
    SdtmigDatasetVariableRefTarget
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmigDatasetVariableRefTarget
instance A.ToJSON SdtmigDatasetVariableRefTarget where
  toJSON SdtmigDatasetVariableRefTarget {..} =
   _omitNulls
      [ "href" .= sdtmigDatasetVariableRefTargetHref
      , "title" .= sdtmigDatasetVariableRefTargetTitle
      , "type" .= sdtmigDatasetVariableRefTargetType
      ]


-- | Construct a value of type 'SdtmigDatasetVariableRefTarget' (by applying it's required fields, if any)
mkSdtmigDatasetVariableRefTarget
  :: SdtmigDatasetVariableRefTarget
mkSdtmigDatasetVariableRefTarget =
  SdtmigDatasetVariableRefTarget
  { sdtmigDatasetVariableRefTargetHref = Nothing
  , sdtmigDatasetVariableRefTargetTitle = Nothing
  , sdtmigDatasetVariableRefTargetType = Nothing
  }

-- ** SdtmigDatasetVariableRefVersion
-- | SdtmigDatasetVariableRefVersion
data SdtmigDatasetVariableRefVersion = SdtmigDatasetVariableRefVersion
  { sdtmigDatasetVariableRefVersionHref :: !(Maybe Text) -- ^ "href"
  , sdtmigDatasetVariableRefVersionTitle :: !(Maybe Text) -- ^ "title"
  , sdtmigDatasetVariableRefVersionType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDatasetVariableRefVersion
instance A.FromJSON SdtmigDatasetVariableRefVersion where
  parseJSON = A.withObject "SdtmigDatasetVariableRefVersion" $ \o ->
    SdtmigDatasetVariableRefVersion
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmigDatasetVariableRefVersion
instance A.ToJSON SdtmigDatasetVariableRefVersion where
  toJSON SdtmigDatasetVariableRefVersion {..} =
   _omitNulls
      [ "href" .= sdtmigDatasetVariableRefVersionHref
      , "title" .= sdtmigDatasetVariableRefVersionTitle
      , "type" .= sdtmigDatasetVariableRefVersionType
      ]


-- | Construct a value of type 'SdtmigDatasetVariableRefVersion' (by applying it's required fields, if any)
mkSdtmigDatasetVariableRefVersion
  :: SdtmigDatasetVariableRefVersion
mkSdtmigDatasetVariableRefVersion =
  SdtmigDatasetVariableRefVersion
  { sdtmigDatasetVariableRefVersionHref = Nothing
  , sdtmigDatasetVariableRefVersionTitle = Nothing
  , sdtmigDatasetVariableRefVersionType = Nothing
  }

-- ** SdtmigDatasetVariables
-- | SdtmigDatasetVariables
data SdtmigDatasetVariables = SdtmigDatasetVariables
  { sdtmigDatasetVariablesOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sdtmigDatasetVariablesName :: !(Maybe Text) -- ^ "name"
  , sdtmigDatasetVariablesLabel :: !(Maybe Text) -- ^ "label"
  , sdtmigDatasetVariablesDescription :: !(Maybe Text) -- ^ "description"
  , sdtmigDatasetVariablesDatasetStructure :: !(Maybe Text) -- ^ "datasetStructure"
  , sdtmigDatasetVariablesLinks :: !(Maybe SdtmigDatasetVariablesLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDatasetVariables
instance A.FromJSON SdtmigDatasetVariables where
  parseJSON = A.withObject "SdtmigDatasetVariables" $ \o ->
    SdtmigDatasetVariables
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "datasetStructure")
      <*> (o .:? "_links")

-- | ToJSON SdtmigDatasetVariables
instance A.ToJSON SdtmigDatasetVariables where
  toJSON SdtmigDatasetVariables {..} =
   _omitNulls
      [ "ordinal" .= sdtmigDatasetVariablesOrdinal
      , "name" .= sdtmigDatasetVariablesName
      , "label" .= sdtmigDatasetVariablesLabel
      , "description" .= sdtmigDatasetVariablesDescription
      , "datasetStructure" .= sdtmigDatasetVariablesDatasetStructure
      , "_links" .= sdtmigDatasetVariablesLinks
      ]


-- | Construct a value of type 'SdtmigDatasetVariables' (by applying it's required fields, if any)
mkSdtmigDatasetVariables
  :: SdtmigDatasetVariables
mkSdtmigDatasetVariables =
  SdtmigDatasetVariables
  { sdtmigDatasetVariablesOrdinal = Nothing
  , sdtmigDatasetVariablesName = Nothing
  , sdtmigDatasetVariablesLabel = Nothing
  , sdtmigDatasetVariablesDescription = Nothing
  , sdtmigDatasetVariablesDatasetStructure = Nothing
  , sdtmigDatasetVariablesLinks = Nothing
  }

-- ** SdtmigDatasetVariablesLinks
-- | SdtmigDatasetVariablesLinks
data SdtmigDatasetVariablesLinks = SdtmigDatasetVariablesLinks
  { sdtmigDatasetVariablesLinksSelf :: !(Maybe SdtmigDatasetVariablesRef) -- ^ "self"
  , sdtmigDatasetVariablesLinksModelDataset :: !(Maybe SdtmDatasetRef) -- ^ "modelDataset"
  , sdtmigDatasetVariablesLinksParentProduct :: !(Maybe SdtmigProductRef) -- ^ "parentProduct"
  , sdtmigDatasetVariablesLinksParentClass :: !(Maybe SdtmigClassRef) -- ^ "parentClass"
  , sdtmigDatasetVariablesLinksPriorVersion :: !(Maybe SdtmigDatasetVariablesRef) -- ^ "priorVersion"
  , sdtmigDatasetVariablesLinksDatasetVariables :: !(Maybe [SdtmigDatasetVariableRefElement]) -- ^ "datasetVariables"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDatasetVariablesLinks
instance A.FromJSON SdtmigDatasetVariablesLinks where
  parseJSON = A.withObject "SdtmigDatasetVariablesLinks" $ \o ->
    SdtmigDatasetVariablesLinks
      <$> (o .:? "self")
      <*> (o .:? "modelDataset")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "priorVersion")
      <*> (o .:? "datasetVariables")

-- | ToJSON SdtmigDatasetVariablesLinks
instance A.ToJSON SdtmigDatasetVariablesLinks where
  toJSON SdtmigDatasetVariablesLinks {..} =
   _omitNulls
      [ "self" .= sdtmigDatasetVariablesLinksSelf
      , "modelDataset" .= sdtmigDatasetVariablesLinksModelDataset
      , "parentProduct" .= sdtmigDatasetVariablesLinksParentProduct
      , "parentClass" .= sdtmigDatasetVariablesLinksParentClass
      , "priorVersion" .= sdtmigDatasetVariablesLinksPriorVersion
      , "datasetVariables" .= sdtmigDatasetVariablesLinksDatasetVariables
      ]


-- | Construct a value of type 'SdtmigDatasetVariablesLinks' (by applying it's required fields, if any)
mkSdtmigDatasetVariablesLinks
  :: SdtmigDatasetVariablesLinks
mkSdtmigDatasetVariablesLinks =
  SdtmigDatasetVariablesLinks
  { sdtmigDatasetVariablesLinksSelf = Nothing
  , sdtmigDatasetVariablesLinksModelDataset = Nothing
  , sdtmigDatasetVariablesLinksParentProduct = Nothing
  , sdtmigDatasetVariablesLinksParentClass = Nothing
  , sdtmigDatasetVariablesLinksPriorVersion = Nothing
  , sdtmigDatasetVariablesLinksDatasetVariables = Nothing
  }

-- ** SdtmigDatasetVariablesRef
-- | SdtmigDatasetVariablesRef
data SdtmigDatasetVariablesRef = SdtmigDatasetVariablesRef
  { sdtmigDatasetVariablesRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmigDatasetVariablesRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmigDatasetVariablesRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDatasetVariablesRef
instance A.FromJSON SdtmigDatasetVariablesRef where
  parseJSON = A.withObject "SdtmigDatasetVariablesRef" $ \o ->
    SdtmigDatasetVariablesRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmigDatasetVariablesRef
instance A.ToJSON SdtmigDatasetVariablesRef where
  toJSON SdtmigDatasetVariablesRef {..} =
   _omitNulls
      [ "href" .= sdtmigDatasetVariablesRefHref
      , "title" .= sdtmigDatasetVariablesRefTitle
      , "type" .= sdtmigDatasetVariablesRefType
      ]


-- | Construct a value of type 'SdtmigDatasetVariablesRef' (by applying it's required fields, if any)
mkSdtmigDatasetVariablesRef
  :: SdtmigDatasetVariablesRef
mkSdtmigDatasetVariablesRef =
  SdtmigDatasetVariablesRef
  { sdtmigDatasetVariablesRefHref = Nothing
  , sdtmigDatasetVariablesRefTitle = Nothing
  , sdtmigDatasetVariablesRefType = Nothing
  }

-- ** SdtmigDatasets
-- | SdtmigDatasets
data SdtmigDatasets = SdtmigDatasets
  { sdtmigDatasetsName :: !(Maybe Text) -- ^ "name"
  , sdtmigDatasetsLabel :: !(Maybe Text) -- ^ "label"
  , sdtmigDatasetsDescription :: !(Maybe Text) -- ^ "description"
  , sdtmigDatasetsSource :: !(Maybe Text) -- ^ "source"
  , sdtmigDatasetsEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , sdtmigDatasetsRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , sdtmigDatasetsVersion :: !(Maybe Text) -- ^ "version"
  , sdtmigDatasetsLinks :: !(Maybe SdtmigDatasetsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDatasets
instance A.FromJSON SdtmigDatasets where
  parseJSON = A.withObject "SdtmigDatasets" $ \o ->
    SdtmigDatasets
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")

-- | ToJSON SdtmigDatasets
instance A.ToJSON SdtmigDatasets where
  toJSON SdtmigDatasets {..} =
   _omitNulls
      [ "name" .= sdtmigDatasetsName
      , "label" .= sdtmigDatasetsLabel
      , "description" .= sdtmigDatasetsDescription
      , "source" .= sdtmigDatasetsSource
      , "effectiveDate" .= sdtmigDatasetsEffectiveDate
      , "registrationStatus" .= sdtmigDatasetsRegistrationStatus
      , "version" .= sdtmigDatasetsVersion
      , "_links" .= sdtmigDatasetsLinks
      ]


-- | Construct a value of type 'SdtmigDatasets' (by applying it's required fields, if any)
mkSdtmigDatasets
  :: SdtmigDatasets
mkSdtmigDatasets =
  SdtmigDatasets
  { sdtmigDatasetsName = Nothing
  , sdtmigDatasetsLabel = Nothing
  , sdtmigDatasetsDescription = Nothing
  , sdtmigDatasetsSource = Nothing
  , sdtmigDatasetsEffectiveDate = Nothing
  , sdtmigDatasetsRegistrationStatus = Nothing
  , sdtmigDatasetsVersion = Nothing
  , sdtmigDatasetsLinks = Nothing
  }

-- ** SdtmigDatasetsLinks
-- | SdtmigDatasetsLinks
data SdtmigDatasetsLinks = SdtmigDatasetsLinks
  { sdtmigDatasetsLinksSelf :: !(Maybe SdtmigDatasetsRef) -- ^ "self"
  , sdtmigDatasetsLinksParentProduct :: !(Maybe SdtmigProductRef) -- ^ "parentProduct"
  , sdtmigDatasetsLinksPriorVersion :: !(Maybe SdtmigDatasetsRef) -- ^ "priorVersion"
  , sdtmigDatasetsLinksDatasets :: !(Maybe [SdtmigDatasetRefElement]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDatasetsLinks
instance A.FromJSON SdtmigDatasetsLinks where
  parseJSON = A.withObject "SdtmigDatasetsLinks" $ \o ->
    SdtmigDatasetsLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "priorVersion")
      <*> (o .:? "datasets")

-- | ToJSON SdtmigDatasetsLinks
instance A.ToJSON SdtmigDatasetsLinks where
  toJSON SdtmigDatasetsLinks {..} =
   _omitNulls
      [ "self" .= sdtmigDatasetsLinksSelf
      , "parentProduct" .= sdtmigDatasetsLinksParentProduct
      , "priorVersion" .= sdtmigDatasetsLinksPriorVersion
      , "datasets" .= sdtmigDatasetsLinksDatasets
      ]


-- | Construct a value of type 'SdtmigDatasetsLinks' (by applying it's required fields, if any)
mkSdtmigDatasetsLinks
  :: SdtmigDatasetsLinks
mkSdtmigDatasetsLinks =
  SdtmigDatasetsLinks
  { sdtmigDatasetsLinksSelf = Nothing
  , sdtmigDatasetsLinksParentProduct = Nothing
  , sdtmigDatasetsLinksPriorVersion = Nothing
  , sdtmigDatasetsLinksDatasets = Nothing
  }

-- ** SdtmigDatasetsRef
-- | SdtmigDatasetsRef
data SdtmigDatasetsRef = SdtmigDatasetsRef
  { sdtmigDatasetsRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmigDatasetsRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmigDatasetsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigDatasetsRef
instance A.FromJSON SdtmigDatasetsRef where
  parseJSON = A.withObject "SdtmigDatasetsRef" $ \o ->
    SdtmigDatasetsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmigDatasetsRef
instance A.ToJSON SdtmigDatasetsRef where
  toJSON SdtmigDatasetsRef {..} =
   _omitNulls
      [ "href" .= sdtmigDatasetsRefHref
      , "title" .= sdtmigDatasetsRefTitle
      , "type" .= sdtmigDatasetsRefType
      ]


-- | Construct a value of type 'SdtmigDatasetsRef' (by applying it's required fields, if any)
mkSdtmigDatasetsRef
  :: SdtmigDatasetsRef
mkSdtmigDatasetsRef =
  SdtmigDatasetsRef
  { sdtmigDatasetsRefHref = Nothing
  , sdtmigDatasetsRefTitle = Nothing
  , sdtmigDatasetsRefType = Nothing
  }

-- ** SdtmigProduct
-- | SdtmigProduct
data SdtmigProduct = SdtmigProduct
  { sdtmigProductName :: !(Maybe Text) -- ^ "name"
  , sdtmigProductLabel :: !(Maybe Text) -- ^ "label"
  , sdtmigProductDescription :: !(Maybe Text) -- ^ "description"
  , sdtmigProductSource :: !(Maybe Text) -- ^ "source"
  , sdtmigProductEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , sdtmigProductRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , sdtmigProductVersion :: !(Maybe Text) -- ^ "version"
  , sdtmigProductLinks :: !(Maybe SdtmigProductLinks) -- ^ "_links"
  , sdtmigProductClasses :: !(Maybe [SdtmigClass]) -- ^ "classes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigProduct
instance A.FromJSON SdtmigProduct where
  parseJSON = A.withObject "SdtmigProduct" $ \o ->
    SdtmigProduct
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")
      <*> (o .:? "classes")

-- | ToJSON SdtmigProduct
instance A.ToJSON SdtmigProduct where
  toJSON SdtmigProduct {..} =
   _omitNulls
      [ "name" .= sdtmigProductName
      , "label" .= sdtmigProductLabel
      , "description" .= sdtmigProductDescription
      , "source" .= sdtmigProductSource
      , "effectiveDate" .= sdtmigProductEffectiveDate
      , "registrationStatus" .= sdtmigProductRegistrationStatus
      , "version" .= sdtmigProductVersion
      , "_links" .= sdtmigProductLinks
      , "classes" .= sdtmigProductClasses
      ]


-- | Construct a value of type 'SdtmigProduct' (by applying it's required fields, if any)
mkSdtmigProduct
  :: SdtmigProduct
mkSdtmigProduct =
  SdtmigProduct
  { sdtmigProductName = Nothing
  , sdtmigProductLabel = Nothing
  , sdtmigProductDescription = Nothing
  , sdtmigProductSource = Nothing
  , sdtmigProductEffectiveDate = Nothing
  , sdtmigProductRegistrationStatus = Nothing
  , sdtmigProductVersion = Nothing
  , sdtmigProductLinks = Nothing
  , sdtmigProductClasses = Nothing
  }

-- ** SdtmigProductLinks
-- | SdtmigProductLinks
data SdtmigProductLinks = SdtmigProductLinks
  { sdtmigProductLinksSelf :: !(Maybe SdtmigProductRef) -- ^ "self"
  , sdtmigProductLinksModel :: !(Maybe SdtmProductRef) -- ^ "model"
  , sdtmigProductLinksPriorVersion :: !(Maybe SdtmigProductRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigProductLinks
instance A.FromJSON SdtmigProductLinks where
  parseJSON = A.withObject "SdtmigProductLinks" $ \o ->
    SdtmigProductLinks
      <$> (o .:? "self")
      <*> (o .:? "model")
      <*> (o .:? "priorVersion")

-- | ToJSON SdtmigProductLinks
instance A.ToJSON SdtmigProductLinks where
  toJSON SdtmigProductLinks {..} =
   _omitNulls
      [ "self" .= sdtmigProductLinksSelf
      , "model" .= sdtmigProductLinksModel
      , "priorVersion" .= sdtmigProductLinksPriorVersion
      ]


-- | Construct a value of type 'SdtmigProductLinks' (by applying it's required fields, if any)
mkSdtmigProductLinks
  :: SdtmigProductLinks
mkSdtmigProductLinks =
  SdtmigProductLinks
  { sdtmigProductLinksSelf = Nothing
  , sdtmigProductLinksModel = Nothing
  , sdtmigProductLinksPriorVersion = Nothing
  }

-- ** SdtmigProductRef
-- | SdtmigProductRef
data SdtmigProductRef = SdtmigProductRef
  { sdtmigProductRefHref :: !(Maybe Text) -- ^ "href"
  , sdtmigProductRefTitle :: !(Maybe Text) -- ^ "title"
  , sdtmigProductRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigProductRef
instance A.FromJSON SdtmigProductRef where
  parseJSON = A.withObject "SdtmigProductRef" $ \o ->
    SdtmigProductRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmigProductRef
instance A.ToJSON SdtmigProductRef where
  toJSON SdtmigProductRef {..} =
   _omitNulls
      [ "href" .= sdtmigProductRefHref
      , "title" .= sdtmigProductRefTitle
      , "type" .= sdtmigProductRefType
      ]


-- | Construct a value of type 'SdtmigProductRef' (by applying it's required fields, if any)
mkSdtmigProductRef
  :: SdtmigProductRef
mkSdtmigProductRef =
  SdtmigProductRef
  { sdtmigProductRefHref = Nothing
  , sdtmigProductRefTitle = Nothing
  , sdtmigProductRefType = Nothing
  }

-- ** SdtmigProductRefElement
-- | SdtmigProductRefElement
data SdtmigProductRefElement = SdtmigProductRefElement
  { sdtmigProductRefElementHref :: !(Maybe Text) -- ^ "href"
  , sdtmigProductRefElementTitle :: !(Maybe Text) -- ^ "title"
  , sdtmigProductRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SdtmigProductRefElement
instance A.FromJSON SdtmigProductRefElement where
  parseJSON = A.withObject "SdtmigProductRefElement" $ \o ->
    SdtmigProductRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SdtmigProductRefElement
instance A.ToJSON SdtmigProductRefElement where
  toJSON SdtmigProductRefElement {..} =
   _omitNulls
      [ "href" .= sdtmigProductRefElementHref
      , "title" .= sdtmigProductRefElementTitle
      , "type" .= sdtmigProductRefElementType
      ]


-- | Construct a value of type 'SdtmigProductRefElement' (by applying it's required fields, if any)
mkSdtmigProductRefElement
  :: SdtmigProductRefElement
mkSdtmigProductRefElement =
  SdtmigProductRefElement
  { sdtmigProductRefElementHref = Nothing
  , sdtmigProductRefElementTitle = Nothing
  , sdtmigProductRefElementType = Nothing
  }

-- ** SendigClass
-- | SendigClass
data SendigClass = SendigClass
  { sendigClassOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sendigClassName :: !(Maybe Text) -- ^ "name"
  , sendigClassLabel :: !(Maybe Text) -- ^ "label"
  , sendigClassDescription :: !(Maybe Text) -- ^ "description"
  , sendigClassLinks :: !(Maybe SendigClassLinks) -- ^ "_links"
  , sendigClassDatasets :: !(Maybe [SendigDataset]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigClass
instance A.FromJSON SendigClass where
  parseJSON = A.withObject "SendigClass" $ \o ->
    SendigClass
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "_links")
      <*> (o .:? "datasets")

-- | ToJSON SendigClass
instance A.ToJSON SendigClass where
  toJSON SendigClass {..} =
   _omitNulls
      [ "ordinal" .= sendigClassOrdinal
      , "name" .= sendigClassName
      , "label" .= sendigClassLabel
      , "description" .= sendigClassDescription
      , "_links" .= sendigClassLinks
      , "datasets" .= sendigClassDatasets
      ]


-- | Construct a value of type 'SendigClass' (by applying it's required fields, if any)
mkSendigClass
  :: SendigClass
mkSendigClass =
  SendigClass
  { sendigClassOrdinal = Nothing
  , sendigClassName = Nothing
  , sendigClassLabel = Nothing
  , sendigClassDescription = Nothing
  , sendigClassLinks = Nothing
  , sendigClassDatasets = Nothing
  }

-- ** SendigClassDatasets
-- | SendigClassDatasets
data SendigClassDatasets = SendigClassDatasets
  { sendigClassDatasetsOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sendigClassDatasetsName :: !(Maybe Text) -- ^ "name"
  , sendigClassDatasetsLabel :: !(Maybe Text) -- ^ "label"
  , sendigClassDatasetsDescription :: !(Maybe Text) -- ^ "description"
  , sendigClassDatasetsLinks :: !(Maybe SendigClassDatasetsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigClassDatasets
instance A.FromJSON SendigClassDatasets where
  parseJSON = A.withObject "SendigClassDatasets" $ \o ->
    SendigClassDatasets
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "_links")

-- | ToJSON SendigClassDatasets
instance A.ToJSON SendigClassDatasets where
  toJSON SendigClassDatasets {..} =
   _omitNulls
      [ "ordinal" .= sendigClassDatasetsOrdinal
      , "name" .= sendigClassDatasetsName
      , "label" .= sendigClassDatasetsLabel
      , "description" .= sendigClassDatasetsDescription
      , "_links" .= sendigClassDatasetsLinks
      ]


-- | Construct a value of type 'SendigClassDatasets' (by applying it's required fields, if any)
mkSendigClassDatasets
  :: SendigClassDatasets
mkSendigClassDatasets =
  SendigClassDatasets
  { sendigClassDatasetsOrdinal = Nothing
  , sendigClassDatasetsName = Nothing
  , sendigClassDatasetsLabel = Nothing
  , sendigClassDatasetsDescription = Nothing
  , sendigClassDatasetsLinks = Nothing
  }

-- ** SendigClassDatasetsLinks
-- | SendigClassDatasetsLinks
data SendigClassDatasetsLinks = SendigClassDatasetsLinks
  { sendigClassDatasetsLinksSelf :: !(Maybe SendigClassDatasetsRef) -- ^ "self"
  , sendigClassDatasetsLinksParentProduct :: !(Maybe SendigProductRef) -- ^ "parentProduct"
  , sendigClassDatasetsLinksDatasets :: !(Maybe [SendigDatasetRefElement]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigClassDatasetsLinks
instance A.FromJSON SendigClassDatasetsLinks where
  parseJSON = A.withObject "SendigClassDatasetsLinks" $ \o ->
    SendigClassDatasetsLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "datasets")

-- | ToJSON SendigClassDatasetsLinks
instance A.ToJSON SendigClassDatasetsLinks where
  toJSON SendigClassDatasetsLinks {..} =
   _omitNulls
      [ "self" .= sendigClassDatasetsLinksSelf
      , "parentProduct" .= sendigClassDatasetsLinksParentProduct
      , "datasets" .= sendigClassDatasetsLinksDatasets
      ]


-- | Construct a value of type 'SendigClassDatasetsLinks' (by applying it's required fields, if any)
mkSendigClassDatasetsLinks
  :: SendigClassDatasetsLinks
mkSendigClassDatasetsLinks =
  SendigClassDatasetsLinks
  { sendigClassDatasetsLinksSelf = Nothing
  , sendigClassDatasetsLinksParentProduct = Nothing
  , sendigClassDatasetsLinksDatasets = Nothing
  }

-- ** SendigClassDatasetsRef
-- | SendigClassDatasetsRef
data SendigClassDatasetsRef = SendigClassDatasetsRef
  { sendigClassDatasetsRefHref :: !(Maybe Text) -- ^ "href"
  , sendigClassDatasetsRefTitle :: !(Maybe Text) -- ^ "title"
  , sendigClassDatasetsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigClassDatasetsRef
instance A.FromJSON SendigClassDatasetsRef where
  parseJSON = A.withObject "SendigClassDatasetsRef" $ \o ->
    SendigClassDatasetsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SendigClassDatasetsRef
instance A.ToJSON SendigClassDatasetsRef where
  toJSON SendigClassDatasetsRef {..} =
   _omitNulls
      [ "href" .= sendigClassDatasetsRefHref
      , "title" .= sendigClassDatasetsRefTitle
      , "type" .= sendigClassDatasetsRefType
      ]


-- | Construct a value of type 'SendigClassDatasetsRef' (by applying it's required fields, if any)
mkSendigClassDatasetsRef
  :: SendigClassDatasetsRef
mkSendigClassDatasetsRef =
  SendigClassDatasetsRef
  { sendigClassDatasetsRefHref = Nothing
  , sendigClassDatasetsRefTitle = Nothing
  , sendigClassDatasetsRefType = Nothing
  }

-- ** SendigClassLinks
-- | SendigClassLinks
data SendigClassLinks = SendigClassLinks
  { sendigClassLinksSelf :: !(Maybe SendigClassRef) -- ^ "self"
  , sendigClassLinksModelClass :: !(Maybe SdtmClassRef) -- ^ "modelClass"
  , sendigClassLinksParentProduct :: !(Maybe SendigProductRef) -- ^ "parentProduct"
  , sendigClassLinksParentClass :: !(Maybe SendigClassRef) -- ^ "parentClass"
  , sendigClassLinksSubclasses :: !(Maybe [SendigClassRefSubclass]) -- ^ "subclasses"
  , sendigClassLinksPriorVersion :: !(Maybe SendigClassRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigClassLinks
instance A.FromJSON SendigClassLinks where
  parseJSON = A.withObject "SendigClassLinks" $ \o ->
    SendigClassLinks
      <$> (o .:? "self")
      <*> (o .:? "modelClass")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "subclasses")
      <*> (o .:? "priorVersion")

-- | ToJSON SendigClassLinks
instance A.ToJSON SendigClassLinks where
  toJSON SendigClassLinks {..} =
   _omitNulls
      [ "self" .= sendigClassLinksSelf
      , "modelClass" .= sendigClassLinksModelClass
      , "parentProduct" .= sendigClassLinksParentProduct
      , "parentClass" .= sendigClassLinksParentClass
      , "subclasses" .= sendigClassLinksSubclasses
      , "priorVersion" .= sendigClassLinksPriorVersion
      ]


-- | Construct a value of type 'SendigClassLinks' (by applying it's required fields, if any)
mkSendigClassLinks
  :: SendigClassLinks
mkSendigClassLinks =
  SendigClassLinks
  { sendigClassLinksSelf = Nothing
  , sendigClassLinksModelClass = Nothing
  , sendigClassLinksParentProduct = Nothing
  , sendigClassLinksParentClass = Nothing
  , sendigClassLinksSubclasses = Nothing
  , sendigClassLinksPriorVersion = Nothing
  }

-- ** SendigClassRef
-- | SendigClassRef
data SendigClassRef = SendigClassRef
  { sendigClassRefHref :: !(Maybe Text) -- ^ "href"
  , sendigClassRefTitle :: !(Maybe Text) -- ^ "title"
  , sendigClassRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigClassRef
instance A.FromJSON SendigClassRef where
  parseJSON = A.withObject "SendigClassRef" $ \o ->
    SendigClassRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SendigClassRef
instance A.ToJSON SendigClassRef where
  toJSON SendigClassRef {..} =
   _omitNulls
      [ "href" .= sendigClassRefHref
      , "title" .= sendigClassRefTitle
      , "type" .= sendigClassRefType
      ]


-- | Construct a value of type 'SendigClassRef' (by applying it's required fields, if any)
mkSendigClassRef
  :: SendigClassRef
mkSendigClassRef =
  SendigClassRef
  { sendigClassRefHref = Nothing
  , sendigClassRefTitle = Nothing
  , sendigClassRefType = Nothing
  }

-- ** SendigClassRefElement
-- | SendigClassRefElement
data SendigClassRefElement = SendigClassRefElement
  { sendigClassRefElementHref :: !(Maybe Text) -- ^ "href"
  , sendigClassRefElementTitle :: !(Maybe Text) -- ^ "title"
  , sendigClassRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigClassRefElement
instance A.FromJSON SendigClassRefElement where
  parseJSON = A.withObject "SendigClassRefElement" $ \o ->
    SendigClassRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SendigClassRefElement
instance A.ToJSON SendigClassRefElement where
  toJSON SendigClassRefElement {..} =
   _omitNulls
      [ "href" .= sendigClassRefElementHref
      , "title" .= sendigClassRefElementTitle
      , "type" .= sendigClassRefElementType
      ]


-- | Construct a value of type 'SendigClassRefElement' (by applying it's required fields, if any)
mkSendigClassRefElement
  :: SendigClassRefElement
mkSendigClassRefElement =
  SendigClassRefElement
  { sendigClassRefElementHref = Nothing
  , sendigClassRefElementTitle = Nothing
  , sendigClassRefElementType = Nothing
  }

-- ** SendigClassRefSubclass
-- | SendigClassRefSubclass
data SendigClassRefSubclass = SendigClassRefSubclass
  { sendigClassRefSubclassHref :: !(Maybe Text) -- ^ "href"
  , sendigClassRefSubclassTitle :: !(Maybe Text) -- ^ "title"
  , sendigClassRefSubclassType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigClassRefSubclass
instance A.FromJSON SendigClassRefSubclass where
  parseJSON = A.withObject "SendigClassRefSubclass" $ \o ->
    SendigClassRefSubclass
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SendigClassRefSubclass
instance A.ToJSON SendigClassRefSubclass where
  toJSON SendigClassRefSubclass {..} =
   _omitNulls
      [ "href" .= sendigClassRefSubclassHref
      , "title" .= sendigClassRefSubclassTitle
      , "type" .= sendigClassRefSubclassType
      ]


-- | Construct a value of type 'SendigClassRefSubclass' (by applying it's required fields, if any)
mkSendigClassRefSubclass
  :: SendigClassRefSubclass
mkSendigClassRefSubclass =
  SendigClassRefSubclass
  { sendigClassRefSubclassHref = Nothing
  , sendigClassRefSubclassTitle = Nothing
  , sendigClassRefSubclassType = Nothing
  }

-- ** SendigClasses
-- | SendigClasses
data SendigClasses = SendigClasses
  { sendigClassesName :: !(Maybe Text) -- ^ "name"
  , sendigClassesLabel :: !(Maybe Text) -- ^ "label"
  , sendigClassesDescription :: !(Maybe Text) -- ^ "description"
  , sendigClassesSource :: !(Maybe Text) -- ^ "source"
  , sendigClassesEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , sendigClassesRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , sendigClassesVersion :: !(Maybe Text) -- ^ "version"
  , sendigClassesLinks :: !(Maybe SendigClassesLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigClasses
instance A.FromJSON SendigClasses where
  parseJSON = A.withObject "SendigClasses" $ \o ->
    SendigClasses
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")

-- | ToJSON SendigClasses
instance A.ToJSON SendigClasses where
  toJSON SendigClasses {..} =
   _omitNulls
      [ "name" .= sendigClassesName
      , "label" .= sendigClassesLabel
      , "description" .= sendigClassesDescription
      , "source" .= sendigClassesSource
      , "effectiveDate" .= sendigClassesEffectiveDate
      , "registrationStatus" .= sendigClassesRegistrationStatus
      , "version" .= sendigClassesVersion
      , "_links" .= sendigClassesLinks
      ]


-- | Construct a value of type 'SendigClasses' (by applying it's required fields, if any)
mkSendigClasses
  :: SendigClasses
mkSendigClasses =
  SendigClasses
  { sendigClassesName = Nothing
  , sendigClassesLabel = Nothing
  , sendigClassesDescription = Nothing
  , sendigClassesSource = Nothing
  , sendigClassesEffectiveDate = Nothing
  , sendigClassesRegistrationStatus = Nothing
  , sendigClassesVersion = Nothing
  , sendigClassesLinks = Nothing
  }

-- ** SendigClassesLinks
-- | SendigClassesLinks
data SendigClassesLinks = SendigClassesLinks
  { sendigClassesLinksSelf :: !(Maybe SendigClassesRef) -- ^ "self"
  , sendigClassesLinksPriorVersion :: !(Maybe SendigClassesRef) -- ^ "priorVersion"
  , sendigClassesLinksClasses :: !(Maybe [SendigClassRefElement]) -- ^ "classes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigClassesLinks
instance A.FromJSON SendigClassesLinks where
  parseJSON = A.withObject "SendigClassesLinks" $ \o ->
    SendigClassesLinks
      <$> (o .:? "self")
      <*> (o .:? "priorVersion")
      <*> (o .:? "classes")

-- | ToJSON SendigClassesLinks
instance A.ToJSON SendigClassesLinks where
  toJSON SendigClassesLinks {..} =
   _omitNulls
      [ "self" .= sendigClassesLinksSelf
      , "priorVersion" .= sendigClassesLinksPriorVersion
      , "classes" .= sendigClassesLinksClasses
      ]


-- | Construct a value of type 'SendigClassesLinks' (by applying it's required fields, if any)
mkSendigClassesLinks
  :: SendigClassesLinks
mkSendigClassesLinks =
  SendigClassesLinks
  { sendigClassesLinksSelf = Nothing
  , sendigClassesLinksPriorVersion = Nothing
  , sendigClassesLinksClasses = Nothing
  }

-- ** SendigClassesRef
-- | SendigClassesRef
data SendigClassesRef = SendigClassesRef
  { sendigClassesRefHref :: !(Maybe Text) -- ^ "href"
  , sendigClassesRefTitle :: !(Maybe Text) -- ^ "title"
  , sendigClassesRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigClassesRef
instance A.FromJSON SendigClassesRef where
  parseJSON = A.withObject "SendigClassesRef" $ \o ->
    SendigClassesRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SendigClassesRef
instance A.ToJSON SendigClassesRef where
  toJSON SendigClassesRef {..} =
   _omitNulls
      [ "href" .= sendigClassesRefHref
      , "title" .= sendigClassesRefTitle
      , "type" .= sendigClassesRefType
      ]


-- | Construct a value of type 'SendigClassesRef' (by applying it's required fields, if any)
mkSendigClassesRef
  :: SendigClassesRef
mkSendigClassesRef =
  SendigClassesRef
  { sendigClassesRefHref = Nothing
  , sendigClassesRefTitle = Nothing
  , sendigClassesRefType = Nothing
  }

-- ** SendigDataset
-- | SendigDataset
data SendigDataset = SendigDataset
  { sendigDatasetOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sendigDatasetName :: !(Maybe Text) -- ^ "name"
  , sendigDatasetLabel :: !(Maybe Text) -- ^ "label"
  , sendigDatasetDescription :: !(Maybe Text) -- ^ "description"
  , sendigDatasetDatasetStructure :: !(Maybe Text) -- ^ "datasetStructure"
  , sendigDatasetLinks :: !(Maybe SendigDatasetLinks) -- ^ "_links"
  , sendigDatasetDatasetVariables :: !(Maybe [SendigDatasetVariable]) -- ^ "datasetVariables"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigDataset
instance A.FromJSON SendigDataset where
  parseJSON = A.withObject "SendigDataset" $ \o ->
    SendigDataset
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "datasetStructure")
      <*> (o .:? "_links")
      <*> (o .:? "datasetVariables")

-- | ToJSON SendigDataset
instance A.ToJSON SendigDataset where
  toJSON SendigDataset {..} =
   _omitNulls
      [ "ordinal" .= sendigDatasetOrdinal
      , "name" .= sendigDatasetName
      , "label" .= sendigDatasetLabel
      , "description" .= sendigDatasetDescription
      , "datasetStructure" .= sendigDatasetDatasetStructure
      , "_links" .= sendigDatasetLinks
      , "datasetVariables" .= sendigDatasetDatasetVariables
      ]


-- | Construct a value of type 'SendigDataset' (by applying it's required fields, if any)
mkSendigDataset
  :: SendigDataset
mkSendigDataset =
  SendigDataset
  { sendigDatasetOrdinal = Nothing
  , sendigDatasetName = Nothing
  , sendigDatasetLabel = Nothing
  , sendigDatasetDescription = Nothing
  , sendigDatasetDatasetStructure = Nothing
  , sendigDatasetLinks = Nothing
  , sendigDatasetDatasetVariables = Nothing
  }

-- ** SendigDatasetLinks
-- | SendigDatasetLinks
data SendigDatasetLinks = SendigDatasetLinks
  { sendigDatasetLinksSelf :: !(Maybe SendigDatasetRef) -- ^ "self"
  , sendigDatasetLinksModelDataset :: !(Maybe SdtmDatasetRef) -- ^ "modelDataset"
  , sendigDatasetLinksParentProduct :: !(Maybe SendigProductRef) -- ^ "parentProduct"
  , sendigDatasetLinksParentClass :: !(Maybe SendigClassRef) -- ^ "parentClass"
  , sendigDatasetLinksPriorVersion :: !(Maybe SendigDatasetRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigDatasetLinks
instance A.FromJSON SendigDatasetLinks where
  parseJSON = A.withObject "SendigDatasetLinks" $ \o ->
    SendigDatasetLinks
      <$> (o .:? "self")
      <*> (o .:? "modelDataset")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "priorVersion")

-- | ToJSON SendigDatasetLinks
instance A.ToJSON SendigDatasetLinks where
  toJSON SendigDatasetLinks {..} =
   _omitNulls
      [ "self" .= sendigDatasetLinksSelf
      , "modelDataset" .= sendigDatasetLinksModelDataset
      , "parentProduct" .= sendigDatasetLinksParentProduct
      , "parentClass" .= sendigDatasetLinksParentClass
      , "priorVersion" .= sendigDatasetLinksPriorVersion
      ]


-- | Construct a value of type 'SendigDatasetLinks' (by applying it's required fields, if any)
mkSendigDatasetLinks
  :: SendigDatasetLinks
mkSendigDatasetLinks =
  SendigDatasetLinks
  { sendigDatasetLinksSelf = Nothing
  , sendigDatasetLinksModelDataset = Nothing
  , sendigDatasetLinksParentProduct = Nothing
  , sendigDatasetLinksParentClass = Nothing
  , sendigDatasetLinksPriorVersion = Nothing
  }

-- ** SendigDatasetRef
-- | SendigDatasetRef
data SendigDatasetRef = SendigDatasetRef
  { sendigDatasetRefHref :: !(Maybe Text) -- ^ "href"
  , sendigDatasetRefTitle :: !(Maybe Text) -- ^ "title"
  , sendigDatasetRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigDatasetRef
instance A.FromJSON SendigDatasetRef where
  parseJSON = A.withObject "SendigDatasetRef" $ \o ->
    SendigDatasetRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SendigDatasetRef
instance A.ToJSON SendigDatasetRef where
  toJSON SendigDatasetRef {..} =
   _omitNulls
      [ "href" .= sendigDatasetRefHref
      , "title" .= sendigDatasetRefTitle
      , "type" .= sendigDatasetRefType
      ]


-- | Construct a value of type 'SendigDatasetRef' (by applying it's required fields, if any)
mkSendigDatasetRef
  :: SendigDatasetRef
mkSendigDatasetRef =
  SendigDatasetRef
  { sendigDatasetRefHref = Nothing
  , sendigDatasetRefTitle = Nothing
  , sendigDatasetRefType = Nothing
  }

-- ** SendigDatasetRefElement
-- | SendigDatasetRefElement
data SendigDatasetRefElement = SendigDatasetRefElement
  { sendigDatasetRefElementHref :: !(Maybe Text) -- ^ "href"
  , sendigDatasetRefElementTitle :: !(Maybe Text) -- ^ "title"
  , sendigDatasetRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigDatasetRefElement
instance A.FromJSON SendigDatasetRefElement where
  parseJSON = A.withObject "SendigDatasetRefElement" $ \o ->
    SendigDatasetRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SendigDatasetRefElement
instance A.ToJSON SendigDatasetRefElement where
  toJSON SendigDatasetRefElement {..} =
   _omitNulls
      [ "href" .= sendigDatasetRefElementHref
      , "title" .= sendigDatasetRefElementTitle
      , "type" .= sendigDatasetRefElementType
      ]


-- | Construct a value of type 'SendigDatasetRefElement' (by applying it's required fields, if any)
mkSendigDatasetRefElement
  :: SendigDatasetRefElement
mkSendigDatasetRefElement =
  SendigDatasetRefElement
  { sendigDatasetRefElementHref = Nothing
  , sendigDatasetRefElementTitle = Nothing
  , sendigDatasetRefElementType = Nothing
  }

-- ** SendigDatasetVariable
-- | SendigDatasetVariable
data SendigDatasetVariable = SendigDatasetVariable
  { sendigDatasetVariableOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sendigDatasetVariableName :: !(Maybe Text) -- ^ "name"
  , sendigDatasetVariableLabel :: !(Maybe Text) -- ^ "label"
  , sendigDatasetVariableDescription :: !(Maybe Text) -- ^ "description"
  , sendigDatasetVariableRole :: !(Maybe Text) -- ^ "role"
  , sendigDatasetVariableSimpleDatatype :: !(Maybe Text) -- ^ "simpleDatatype"
  , sendigDatasetVariableCore :: !(Maybe Text) -- ^ "core"
  , sendigDatasetVariableDescribedValueDomain :: !(Maybe Text) -- ^ "describedValueDomain"
  , sendigDatasetVariableValueList :: !(Maybe [Text]) -- ^ "valueList"
  , sendigDatasetVariableLinks :: !(Maybe SendigDatasetVariableLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigDatasetVariable
instance A.FromJSON SendigDatasetVariable where
  parseJSON = A.withObject "SendigDatasetVariable" $ \o ->
    SendigDatasetVariable
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "role")
      <*> (o .:? "simpleDatatype")
      <*> (o .:? "core")
      <*> (o .:? "describedValueDomain")
      <*> (o .:? "valueList")
      <*> (o .:? "_links")

-- | ToJSON SendigDatasetVariable
instance A.ToJSON SendigDatasetVariable where
  toJSON SendigDatasetVariable {..} =
   _omitNulls
      [ "ordinal" .= sendigDatasetVariableOrdinal
      , "name" .= sendigDatasetVariableName
      , "label" .= sendigDatasetVariableLabel
      , "description" .= sendigDatasetVariableDescription
      , "role" .= sendigDatasetVariableRole
      , "simpleDatatype" .= sendigDatasetVariableSimpleDatatype
      , "core" .= sendigDatasetVariableCore
      , "describedValueDomain" .= sendigDatasetVariableDescribedValueDomain
      , "valueList" .= sendigDatasetVariableValueList
      , "_links" .= sendigDatasetVariableLinks
      ]


-- | Construct a value of type 'SendigDatasetVariable' (by applying it's required fields, if any)
mkSendigDatasetVariable
  :: SendigDatasetVariable
mkSendigDatasetVariable =
  SendigDatasetVariable
  { sendigDatasetVariableOrdinal = Nothing
  , sendigDatasetVariableName = Nothing
  , sendigDatasetVariableLabel = Nothing
  , sendigDatasetVariableDescription = Nothing
  , sendigDatasetVariableRole = Nothing
  , sendigDatasetVariableSimpleDatatype = Nothing
  , sendigDatasetVariableCore = Nothing
  , sendigDatasetVariableDescribedValueDomain = Nothing
  , sendigDatasetVariableValueList = Nothing
  , sendigDatasetVariableLinks = Nothing
  }

-- ** SendigDatasetVariableLinks
-- | SendigDatasetVariableLinks
data SendigDatasetVariableLinks = SendigDatasetVariableLinks
  { sendigDatasetVariableLinksSelf :: !(Maybe SendigDatasetVariableRef) -- ^ "self"
  , sendigDatasetVariableLinksCodelist :: !(Maybe [RootCtCodelistRefElement]) -- ^ "codelist"
  , sendigDatasetVariableLinksModelClassVariable :: !(Maybe SdtmClassVariableRef) -- ^ "modelClassVariable"
  , sendigDatasetVariableLinksModelDatasetVariable :: !(Maybe SdtmDatasetVariableRef) -- ^ "modelDatasetVariable"
  , sendigDatasetVariableLinksParentProduct :: !(Maybe SendigProductRef) -- ^ "parentProduct"
  , sendigDatasetVariableLinksParentDataset :: !(Maybe SendigDatasetRef) -- ^ "parentDataset"
  , sendigDatasetVariableLinksRootItem :: !(Maybe RootSendigDatasetVariableRef) -- ^ "rootItem"
  , sendigDatasetVariableLinksPriorVersion :: !(Maybe SendigDatasetVariableRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigDatasetVariableLinks
instance A.FromJSON SendigDatasetVariableLinks where
  parseJSON = A.withObject "SendigDatasetVariableLinks" $ \o ->
    SendigDatasetVariableLinks
      <$> (o .:? "self")
      <*> (o .:? "codelist")
      <*> (o .:? "modelClassVariable")
      <*> (o .:? "modelDatasetVariable")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentDataset")
      <*> (o .:? "rootItem")
      <*> (o .:? "priorVersion")

-- | ToJSON SendigDatasetVariableLinks
instance A.ToJSON SendigDatasetVariableLinks where
  toJSON SendigDatasetVariableLinks {..} =
   _omitNulls
      [ "self" .= sendigDatasetVariableLinksSelf
      , "codelist" .= sendigDatasetVariableLinksCodelist
      , "modelClassVariable" .= sendigDatasetVariableLinksModelClassVariable
      , "modelDatasetVariable" .= sendigDatasetVariableLinksModelDatasetVariable
      , "parentProduct" .= sendigDatasetVariableLinksParentProduct
      , "parentDataset" .= sendigDatasetVariableLinksParentDataset
      , "rootItem" .= sendigDatasetVariableLinksRootItem
      , "priorVersion" .= sendigDatasetVariableLinksPriorVersion
      ]


-- | Construct a value of type 'SendigDatasetVariableLinks' (by applying it's required fields, if any)
mkSendigDatasetVariableLinks
  :: SendigDatasetVariableLinks
mkSendigDatasetVariableLinks =
  SendigDatasetVariableLinks
  { sendigDatasetVariableLinksSelf = Nothing
  , sendigDatasetVariableLinksCodelist = Nothing
  , sendigDatasetVariableLinksModelClassVariable = Nothing
  , sendigDatasetVariableLinksModelDatasetVariable = Nothing
  , sendigDatasetVariableLinksParentProduct = Nothing
  , sendigDatasetVariableLinksParentDataset = Nothing
  , sendigDatasetVariableLinksRootItem = Nothing
  , sendigDatasetVariableLinksPriorVersion = Nothing
  }

-- ** SendigDatasetVariableRef
-- | SendigDatasetVariableRef
data SendigDatasetVariableRef = SendigDatasetVariableRef
  { sendigDatasetVariableRefHref :: !(Maybe Text) -- ^ "href"
  , sendigDatasetVariableRefTitle :: !(Maybe Text) -- ^ "title"
  , sendigDatasetVariableRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigDatasetVariableRef
instance A.FromJSON SendigDatasetVariableRef where
  parseJSON = A.withObject "SendigDatasetVariableRef" $ \o ->
    SendigDatasetVariableRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SendigDatasetVariableRef
instance A.ToJSON SendigDatasetVariableRef where
  toJSON SendigDatasetVariableRef {..} =
   _omitNulls
      [ "href" .= sendigDatasetVariableRefHref
      , "title" .= sendigDatasetVariableRefTitle
      , "type" .= sendigDatasetVariableRefType
      ]


-- | Construct a value of type 'SendigDatasetVariableRef' (by applying it's required fields, if any)
mkSendigDatasetVariableRef
  :: SendigDatasetVariableRef
mkSendigDatasetVariableRef =
  SendigDatasetVariableRef
  { sendigDatasetVariableRefHref = Nothing
  , sendigDatasetVariableRefTitle = Nothing
  , sendigDatasetVariableRefType = Nothing
  }

-- ** SendigDatasetVariableRefElement
-- | SendigDatasetVariableRefElement
data SendigDatasetVariableRefElement = SendigDatasetVariableRefElement
  { sendigDatasetVariableRefElementHref :: !(Maybe Text) -- ^ "href"
  , sendigDatasetVariableRefElementTitle :: !(Maybe Text) -- ^ "title"
  , sendigDatasetVariableRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigDatasetVariableRefElement
instance A.FromJSON SendigDatasetVariableRefElement where
  parseJSON = A.withObject "SendigDatasetVariableRefElement" $ \o ->
    SendigDatasetVariableRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SendigDatasetVariableRefElement
instance A.ToJSON SendigDatasetVariableRefElement where
  toJSON SendigDatasetVariableRefElement {..} =
   _omitNulls
      [ "href" .= sendigDatasetVariableRefElementHref
      , "title" .= sendigDatasetVariableRefElementTitle
      , "type" .= sendigDatasetVariableRefElementType
      ]


-- | Construct a value of type 'SendigDatasetVariableRefElement' (by applying it's required fields, if any)
mkSendigDatasetVariableRefElement
  :: SendigDatasetVariableRefElement
mkSendigDatasetVariableRefElement =
  SendigDatasetVariableRefElement
  { sendigDatasetVariableRefElementHref = Nothing
  , sendigDatasetVariableRefElementTitle = Nothing
  , sendigDatasetVariableRefElementType = Nothing
  }

-- ** SendigDatasetVariableRefVersion
-- | SendigDatasetVariableRefVersion
data SendigDatasetVariableRefVersion = SendigDatasetVariableRefVersion
  { sendigDatasetVariableRefVersionHref :: !(Maybe Text) -- ^ "href"
  , sendigDatasetVariableRefVersionTitle :: !(Maybe Text) -- ^ "title"
  , sendigDatasetVariableRefVersionType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigDatasetVariableRefVersion
instance A.FromJSON SendigDatasetVariableRefVersion where
  parseJSON = A.withObject "SendigDatasetVariableRefVersion" $ \o ->
    SendigDatasetVariableRefVersion
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SendigDatasetVariableRefVersion
instance A.ToJSON SendigDatasetVariableRefVersion where
  toJSON SendigDatasetVariableRefVersion {..} =
   _omitNulls
      [ "href" .= sendigDatasetVariableRefVersionHref
      , "title" .= sendigDatasetVariableRefVersionTitle
      , "type" .= sendigDatasetVariableRefVersionType
      ]


-- | Construct a value of type 'SendigDatasetVariableRefVersion' (by applying it's required fields, if any)
mkSendigDatasetVariableRefVersion
  :: SendigDatasetVariableRefVersion
mkSendigDatasetVariableRefVersion =
  SendigDatasetVariableRefVersion
  { sendigDatasetVariableRefVersionHref = Nothing
  , sendigDatasetVariableRefVersionTitle = Nothing
  , sendigDatasetVariableRefVersionType = Nothing
  }

-- ** SendigDatasetVariables
-- | SendigDatasetVariables
data SendigDatasetVariables = SendigDatasetVariables
  { sendigDatasetVariablesOrdinal :: !(Maybe Text) -- ^ "ordinal"
  , sendigDatasetVariablesName :: !(Maybe Text) -- ^ "name"
  , sendigDatasetVariablesLabel :: !(Maybe Text) -- ^ "label"
  , sendigDatasetVariablesDescription :: !(Maybe Text) -- ^ "description"
  , sendigDatasetVariablesDatasetStructure :: !(Maybe Text) -- ^ "datasetStructure"
  , sendigDatasetVariablesLinks :: !(Maybe SendigDatasetVariablesLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigDatasetVariables
instance A.FromJSON SendigDatasetVariables where
  parseJSON = A.withObject "SendigDatasetVariables" $ \o ->
    SendigDatasetVariables
      <$> (o .:? "ordinal")
      <*> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "datasetStructure")
      <*> (o .:? "_links")

-- | ToJSON SendigDatasetVariables
instance A.ToJSON SendigDatasetVariables where
  toJSON SendigDatasetVariables {..} =
   _omitNulls
      [ "ordinal" .= sendigDatasetVariablesOrdinal
      , "name" .= sendigDatasetVariablesName
      , "label" .= sendigDatasetVariablesLabel
      , "description" .= sendigDatasetVariablesDescription
      , "datasetStructure" .= sendigDatasetVariablesDatasetStructure
      , "_links" .= sendigDatasetVariablesLinks
      ]


-- | Construct a value of type 'SendigDatasetVariables' (by applying it's required fields, if any)
mkSendigDatasetVariables
  :: SendigDatasetVariables
mkSendigDatasetVariables =
  SendigDatasetVariables
  { sendigDatasetVariablesOrdinal = Nothing
  , sendigDatasetVariablesName = Nothing
  , sendigDatasetVariablesLabel = Nothing
  , sendigDatasetVariablesDescription = Nothing
  , sendigDatasetVariablesDatasetStructure = Nothing
  , sendigDatasetVariablesLinks = Nothing
  }

-- ** SendigDatasetVariablesLinks
-- | SendigDatasetVariablesLinks
data SendigDatasetVariablesLinks = SendigDatasetVariablesLinks
  { sendigDatasetVariablesLinksSelf :: !(Maybe SendigDatasetVariablesRef) -- ^ "self"
  , sendigDatasetVariablesLinksModelDataset :: !(Maybe SdtmDatasetRef) -- ^ "modelDataset"
  , sendigDatasetVariablesLinksParentProduct :: !(Maybe SendigProductRef) -- ^ "parentProduct"
  , sendigDatasetVariablesLinksParentClass :: !(Maybe SendigClassRef) -- ^ "parentClass"
  , sendigDatasetVariablesLinksPriorVersion :: !(Maybe SendigDatasetVariablesRef) -- ^ "priorVersion"
  , sendigDatasetVariablesLinksDatasetVariables :: !(Maybe [SendigDatasetVariableRefElement]) -- ^ "datasetVariables"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigDatasetVariablesLinks
instance A.FromJSON SendigDatasetVariablesLinks where
  parseJSON = A.withObject "SendigDatasetVariablesLinks" $ \o ->
    SendigDatasetVariablesLinks
      <$> (o .:? "self")
      <*> (o .:? "modelDataset")
      <*> (o .:? "parentProduct")
      <*> (o .:? "parentClass")
      <*> (o .:? "priorVersion")
      <*> (o .:? "datasetVariables")

-- | ToJSON SendigDatasetVariablesLinks
instance A.ToJSON SendigDatasetVariablesLinks where
  toJSON SendigDatasetVariablesLinks {..} =
   _omitNulls
      [ "self" .= sendigDatasetVariablesLinksSelf
      , "modelDataset" .= sendigDatasetVariablesLinksModelDataset
      , "parentProduct" .= sendigDatasetVariablesLinksParentProduct
      , "parentClass" .= sendigDatasetVariablesLinksParentClass
      , "priorVersion" .= sendigDatasetVariablesLinksPriorVersion
      , "datasetVariables" .= sendigDatasetVariablesLinksDatasetVariables
      ]


-- | Construct a value of type 'SendigDatasetVariablesLinks' (by applying it's required fields, if any)
mkSendigDatasetVariablesLinks
  :: SendigDatasetVariablesLinks
mkSendigDatasetVariablesLinks =
  SendigDatasetVariablesLinks
  { sendigDatasetVariablesLinksSelf = Nothing
  , sendigDatasetVariablesLinksModelDataset = Nothing
  , sendigDatasetVariablesLinksParentProduct = Nothing
  , sendigDatasetVariablesLinksParentClass = Nothing
  , sendigDatasetVariablesLinksPriorVersion = Nothing
  , sendigDatasetVariablesLinksDatasetVariables = Nothing
  }

-- ** SendigDatasetVariablesRef
-- | SendigDatasetVariablesRef
data SendigDatasetVariablesRef = SendigDatasetVariablesRef
  { sendigDatasetVariablesRefHref :: !(Maybe Text) -- ^ "href"
  , sendigDatasetVariablesRefTitle :: !(Maybe Text) -- ^ "title"
  , sendigDatasetVariablesRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigDatasetVariablesRef
instance A.FromJSON SendigDatasetVariablesRef where
  parseJSON = A.withObject "SendigDatasetVariablesRef" $ \o ->
    SendigDatasetVariablesRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SendigDatasetVariablesRef
instance A.ToJSON SendigDatasetVariablesRef where
  toJSON SendigDatasetVariablesRef {..} =
   _omitNulls
      [ "href" .= sendigDatasetVariablesRefHref
      , "title" .= sendigDatasetVariablesRefTitle
      , "type" .= sendigDatasetVariablesRefType
      ]


-- | Construct a value of type 'SendigDatasetVariablesRef' (by applying it's required fields, if any)
mkSendigDatasetVariablesRef
  :: SendigDatasetVariablesRef
mkSendigDatasetVariablesRef =
  SendigDatasetVariablesRef
  { sendigDatasetVariablesRefHref = Nothing
  , sendigDatasetVariablesRefTitle = Nothing
  , sendigDatasetVariablesRefType = Nothing
  }

-- ** SendigDatasets
-- | SendigDatasets
data SendigDatasets = SendigDatasets
  { sendigDatasetsName :: !(Maybe Text) -- ^ "name"
  , sendigDatasetsLabel :: !(Maybe Text) -- ^ "label"
  , sendigDatasetsDescription :: !(Maybe Text) -- ^ "description"
  , sendigDatasetsSource :: !(Maybe Text) -- ^ "source"
  , sendigDatasetsEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , sendigDatasetsRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , sendigDatasetsVersion :: !(Maybe Text) -- ^ "version"
  , sendigDatasetsLinks :: !(Maybe SendigDatasetsLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigDatasets
instance A.FromJSON SendigDatasets where
  parseJSON = A.withObject "SendigDatasets" $ \o ->
    SendigDatasets
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")

-- | ToJSON SendigDatasets
instance A.ToJSON SendigDatasets where
  toJSON SendigDatasets {..} =
   _omitNulls
      [ "name" .= sendigDatasetsName
      , "label" .= sendigDatasetsLabel
      , "description" .= sendigDatasetsDescription
      , "source" .= sendigDatasetsSource
      , "effectiveDate" .= sendigDatasetsEffectiveDate
      , "registrationStatus" .= sendigDatasetsRegistrationStatus
      , "version" .= sendigDatasetsVersion
      , "_links" .= sendigDatasetsLinks
      ]


-- | Construct a value of type 'SendigDatasets' (by applying it's required fields, if any)
mkSendigDatasets
  :: SendigDatasets
mkSendigDatasets =
  SendigDatasets
  { sendigDatasetsName = Nothing
  , sendigDatasetsLabel = Nothing
  , sendigDatasetsDescription = Nothing
  , sendigDatasetsSource = Nothing
  , sendigDatasetsEffectiveDate = Nothing
  , sendigDatasetsRegistrationStatus = Nothing
  , sendigDatasetsVersion = Nothing
  , sendigDatasetsLinks = Nothing
  }

-- ** SendigDatasetsLinks
-- | SendigDatasetsLinks
data SendigDatasetsLinks = SendigDatasetsLinks
  { sendigDatasetsLinksSelf :: !(Maybe SendigDatasetsRef) -- ^ "self"
  , sendigDatasetsLinksParentProduct :: !(Maybe SendigProductRef) -- ^ "parentProduct"
  , sendigDatasetsLinksDatasets :: !(Maybe [SendigDatasetRefElement]) -- ^ "datasets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigDatasetsLinks
instance A.FromJSON SendigDatasetsLinks where
  parseJSON = A.withObject "SendigDatasetsLinks" $ \o ->
    SendigDatasetsLinks
      <$> (o .:? "self")
      <*> (o .:? "parentProduct")
      <*> (o .:? "datasets")

-- | ToJSON SendigDatasetsLinks
instance A.ToJSON SendigDatasetsLinks where
  toJSON SendigDatasetsLinks {..} =
   _omitNulls
      [ "self" .= sendigDatasetsLinksSelf
      , "parentProduct" .= sendigDatasetsLinksParentProduct
      , "datasets" .= sendigDatasetsLinksDatasets
      ]


-- | Construct a value of type 'SendigDatasetsLinks' (by applying it's required fields, if any)
mkSendigDatasetsLinks
  :: SendigDatasetsLinks
mkSendigDatasetsLinks =
  SendigDatasetsLinks
  { sendigDatasetsLinksSelf = Nothing
  , sendigDatasetsLinksParentProduct = Nothing
  , sendigDatasetsLinksDatasets = Nothing
  }

-- ** SendigDatasetsRef
-- | SendigDatasetsRef
data SendigDatasetsRef = SendigDatasetsRef
  { sendigDatasetsRefHref :: !(Maybe Text) -- ^ "href"
  , sendigDatasetsRefTitle :: !(Maybe Text) -- ^ "title"
  , sendigDatasetsRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigDatasetsRef
instance A.FromJSON SendigDatasetsRef where
  parseJSON = A.withObject "SendigDatasetsRef" $ \o ->
    SendigDatasetsRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SendigDatasetsRef
instance A.ToJSON SendigDatasetsRef where
  toJSON SendigDatasetsRef {..} =
   _omitNulls
      [ "href" .= sendigDatasetsRefHref
      , "title" .= sendigDatasetsRefTitle
      , "type" .= sendigDatasetsRefType
      ]


-- | Construct a value of type 'SendigDatasetsRef' (by applying it's required fields, if any)
mkSendigDatasetsRef
  :: SendigDatasetsRef
mkSendigDatasetsRef =
  SendigDatasetsRef
  { sendigDatasetsRefHref = Nothing
  , sendigDatasetsRefTitle = Nothing
  , sendigDatasetsRefType = Nothing
  }

-- ** SendigProduct
-- | SendigProduct
data SendigProduct = SendigProduct
  { sendigProductName :: !(Maybe Text) -- ^ "name"
  , sendigProductLabel :: !(Maybe Text) -- ^ "label"
  , sendigProductDescription :: !(Maybe Text) -- ^ "description"
  , sendigProductSource :: !(Maybe Text) -- ^ "source"
  , sendigProductEffectiveDate :: !(Maybe Text) -- ^ "effectiveDate"
  , sendigProductRegistrationStatus :: !(Maybe Text) -- ^ "registrationStatus"
  , sendigProductVersion :: !(Maybe Text) -- ^ "version"
  , sendigProductLinks :: !(Maybe SendigProductLinks) -- ^ "_links"
  , sendigProductClasses :: !(Maybe [SendigClass]) -- ^ "classes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigProduct
instance A.FromJSON SendigProduct where
  parseJSON = A.withObject "SendigProduct" $ \o ->
    SendigProduct
      <$> (o .:? "name")
      <*> (o .:? "label")
      <*> (o .:? "description")
      <*> (o .:? "source")
      <*> (o .:? "effectiveDate")
      <*> (o .:? "registrationStatus")
      <*> (o .:? "version")
      <*> (o .:? "_links")
      <*> (o .:? "classes")

-- | ToJSON SendigProduct
instance A.ToJSON SendigProduct where
  toJSON SendigProduct {..} =
   _omitNulls
      [ "name" .= sendigProductName
      , "label" .= sendigProductLabel
      , "description" .= sendigProductDescription
      , "source" .= sendigProductSource
      , "effectiveDate" .= sendigProductEffectiveDate
      , "registrationStatus" .= sendigProductRegistrationStatus
      , "version" .= sendigProductVersion
      , "_links" .= sendigProductLinks
      , "classes" .= sendigProductClasses
      ]


-- | Construct a value of type 'SendigProduct' (by applying it's required fields, if any)
mkSendigProduct
  :: SendigProduct
mkSendigProduct =
  SendigProduct
  { sendigProductName = Nothing
  , sendigProductLabel = Nothing
  , sendigProductDescription = Nothing
  , sendigProductSource = Nothing
  , sendigProductEffectiveDate = Nothing
  , sendigProductRegistrationStatus = Nothing
  , sendigProductVersion = Nothing
  , sendigProductLinks = Nothing
  , sendigProductClasses = Nothing
  }

-- ** SendigProductLinks
-- | SendigProductLinks
data SendigProductLinks = SendigProductLinks
  { sendigProductLinksSelf :: !(Maybe SendigProductRef) -- ^ "self"
  , sendigProductLinksModel :: !(Maybe SdtmProductRef) -- ^ "model"
  , sendigProductLinksPriorVersion :: !(Maybe SendigProductRef) -- ^ "priorVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigProductLinks
instance A.FromJSON SendigProductLinks where
  parseJSON = A.withObject "SendigProductLinks" $ \o ->
    SendigProductLinks
      <$> (o .:? "self")
      <*> (o .:? "model")
      <*> (o .:? "priorVersion")

-- | ToJSON SendigProductLinks
instance A.ToJSON SendigProductLinks where
  toJSON SendigProductLinks {..} =
   _omitNulls
      [ "self" .= sendigProductLinksSelf
      , "model" .= sendigProductLinksModel
      , "priorVersion" .= sendigProductLinksPriorVersion
      ]


-- | Construct a value of type 'SendigProductLinks' (by applying it's required fields, if any)
mkSendigProductLinks
  :: SendigProductLinks
mkSendigProductLinks =
  SendigProductLinks
  { sendigProductLinksSelf = Nothing
  , sendigProductLinksModel = Nothing
  , sendigProductLinksPriorVersion = Nothing
  }

-- ** SendigProductRef
-- | SendigProductRef
data SendigProductRef = SendigProductRef
  { sendigProductRefHref :: !(Maybe Text) -- ^ "href"
  , sendigProductRefTitle :: !(Maybe Text) -- ^ "title"
  , sendigProductRefType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigProductRef
instance A.FromJSON SendigProductRef where
  parseJSON = A.withObject "SendigProductRef" $ \o ->
    SendigProductRef
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SendigProductRef
instance A.ToJSON SendigProductRef where
  toJSON SendigProductRef {..} =
   _omitNulls
      [ "href" .= sendigProductRefHref
      , "title" .= sendigProductRefTitle
      , "type" .= sendigProductRefType
      ]


-- | Construct a value of type 'SendigProductRef' (by applying it's required fields, if any)
mkSendigProductRef
  :: SendigProductRef
mkSendigProductRef =
  SendigProductRef
  { sendigProductRefHref = Nothing
  , sendigProductRefTitle = Nothing
  , sendigProductRefType = Nothing
  }

-- ** SendigProductRefElement
-- | SendigProductRefElement
data SendigProductRefElement = SendigProductRefElement
  { sendigProductRefElementHref :: !(Maybe Text) -- ^ "href"
  , sendigProductRefElementTitle :: !(Maybe Text) -- ^ "title"
  , sendigProductRefElementType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SendigProductRefElement
instance A.FromJSON SendigProductRefElement where
  parseJSON = A.withObject "SendigProductRefElement" $ \o ->
    SendigProductRefElement
      <$> (o .:? "href")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON SendigProductRefElement
instance A.ToJSON SendigProductRefElement where
  toJSON SendigProductRefElement {..} =
   _omitNulls
      [ "href" .= sendigProductRefElementHref
      , "title" .= sendigProductRefElementTitle
      , "type" .= sendigProductRefElementType
      ]


-- | Construct a value of type 'SendigProductRefElement' (by applying it's required fields, if any)
mkSendigProductRefElement
  :: SendigProductRefElement
mkSendigProductRefElement =
  SendigProductRefElement
  { sendigProductRefElementHref = Nothing
  , sendigProductRefElementTitle = Nothing
  , sendigProductRefElementType = Nothing
  }

-- ** XmlAbout
-- | XmlAbout
data XmlAbout = XmlAbout
  { xmlAboutSelf :: !(Maybe About) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlAbout
instance A.FromJSON XmlAbout where
  parseJSON = A.withObject "XmlAbout" $ \o ->
    XmlAbout
      <$> (o .:? "self")

-- | ToJSON XmlAbout
instance A.ToJSON XmlAbout where
  toJSON XmlAbout {..} =
   _omitNulls
      [ "self" .= xmlAboutSelf
      ]


-- | Construct a value of type 'XmlAbout' (by applying it's required fields, if any)
mkXmlAbout
  :: XmlAbout
mkXmlAbout =
  XmlAbout
  { xmlAboutSelf = Nothing
  }

-- ** XmlAdamDatastructure
-- | XmlAdamDatastructure
data XmlAdamDatastructure = XmlAdamDatastructure
  { xmlAdamDatastructureSelf :: !(Maybe AdamDatastructure) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlAdamDatastructure
instance A.FromJSON XmlAdamDatastructure where
  parseJSON = A.withObject "XmlAdamDatastructure" $ \o ->
    XmlAdamDatastructure
      <$> (o .:? "self")

-- | ToJSON XmlAdamDatastructure
instance A.ToJSON XmlAdamDatastructure where
  toJSON XmlAdamDatastructure {..} =
   _omitNulls
      [ "self" .= xmlAdamDatastructureSelf
      ]


-- | Construct a value of type 'XmlAdamDatastructure' (by applying it's required fields, if any)
mkXmlAdamDatastructure
  :: XmlAdamDatastructure
mkXmlAdamDatastructure =
  XmlAdamDatastructure
  { xmlAdamDatastructureSelf = Nothing
  }

-- ** XmlAdamDatastructureVariables
-- | XmlAdamDatastructureVariables
data XmlAdamDatastructureVariables = XmlAdamDatastructureVariables
  { xmlAdamDatastructureVariablesSelf :: !(Maybe AdamDatastructureVariables) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlAdamDatastructureVariables
instance A.FromJSON XmlAdamDatastructureVariables where
  parseJSON = A.withObject "XmlAdamDatastructureVariables" $ \o ->
    XmlAdamDatastructureVariables
      <$> (o .:? "self")

-- | ToJSON XmlAdamDatastructureVariables
instance A.ToJSON XmlAdamDatastructureVariables where
  toJSON XmlAdamDatastructureVariables {..} =
   _omitNulls
      [ "self" .= xmlAdamDatastructureVariablesSelf
      ]


-- | Construct a value of type 'XmlAdamDatastructureVariables' (by applying it's required fields, if any)
mkXmlAdamDatastructureVariables
  :: XmlAdamDatastructureVariables
mkXmlAdamDatastructureVariables =
  XmlAdamDatastructureVariables
  { xmlAdamDatastructureVariablesSelf = Nothing
  }

-- ** XmlAdamDatastructureVarsets
-- | XmlAdamDatastructureVarsets
data XmlAdamDatastructureVarsets = XmlAdamDatastructureVarsets
  { xmlAdamDatastructureVarsetsSelf :: !(Maybe AdamDatastructureVarsets) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlAdamDatastructureVarsets
instance A.FromJSON XmlAdamDatastructureVarsets where
  parseJSON = A.withObject "XmlAdamDatastructureVarsets" $ \o ->
    XmlAdamDatastructureVarsets
      <$> (o .:? "self")

-- | ToJSON XmlAdamDatastructureVarsets
instance A.ToJSON XmlAdamDatastructureVarsets where
  toJSON XmlAdamDatastructureVarsets {..} =
   _omitNulls
      [ "self" .= xmlAdamDatastructureVarsetsSelf
      ]


-- | Construct a value of type 'XmlAdamDatastructureVarsets' (by applying it's required fields, if any)
mkXmlAdamDatastructureVarsets
  :: XmlAdamDatastructureVarsets
mkXmlAdamDatastructureVarsets =
  XmlAdamDatastructureVarsets
  { xmlAdamDatastructureVarsetsSelf = Nothing
  }

-- ** XmlAdamProduct
-- | XmlAdamProduct
data XmlAdamProduct = XmlAdamProduct
  { xmlAdamProductSelf :: !(Maybe AdamProduct) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlAdamProduct
instance A.FromJSON XmlAdamProduct where
  parseJSON = A.withObject "XmlAdamProduct" $ \o ->
    XmlAdamProduct
      <$> (o .:? "self")

-- | ToJSON XmlAdamProduct
instance A.ToJSON XmlAdamProduct where
  toJSON XmlAdamProduct {..} =
   _omitNulls
      [ "self" .= xmlAdamProductSelf
      ]


-- | Construct a value of type 'XmlAdamProduct' (by applying it's required fields, if any)
mkXmlAdamProduct
  :: XmlAdamProduct
mkXmlAdamProduct =
  XmlAdamProduct
  { xmlAdamProductSelf = Nothing
  }

-- ** XmlAdamProductDatastructures
-- | XmlAdamProductDatastructures
data XmlAdamProductDatastructures = XmlAdamProductDatastructures
  { xmlAdamProductDatastructuresSelf :: !(Maybe AdamProductDatastructures) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlAdamProductDatastructures
instance A.FromJSON XmlAdamProductDatastructures where
  parseJSON = A.withObject "XmlAdamProductDatastructures" $ \o ->
    XmlAdamProductDatastructures
      <$> (o .:? "self")

-- | ToJSON XmlAdamProductDatastructures
instance A.ToJSON XmlAdamProductDatastructures where
  toJSON XmlAdamProductDatastructures {..} =
   _omitNulls
      [ "self" .= xmlAdamProductDatastructuresSelf
      ]


-- | Construct a value of type 'XmlAdamProductDatastructures' (by applying it's required fields, if any)
mkXmlAdamProductDatastructures
  :: XmlAdamProductDatastructures
mkXmlAdamProductDatastructures =
  XmlAdamProductDatastructures
  { xmlAdamProductDatastructuresSelf = Nothing
  }

-- ** XmlAdamVariable
-- | XmlAdamVariable
data XmlAdamVariable = XmlAdamVariable
  { xmlAdamVariableSelf :: !(Maybe AdamVariable) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlAdamVariable
instance A.FromJSON XmlAdamVariable where
  parseJSON = A.withObject "XmlAdamVariable" $ \o ->
    XmlAdamVariable
      <$> (o .:? "self")

-- | ToJSON XmlAdamVariable
instance A.ToJSON XmlAdamVariable where
  toJSON XmlAdamVariable {..} =
   _omitNulls
      [ "self" .= xmlAdamVariableSelf
      ]


-- | Construct a value of type 'XmlAdamVariable' (by applying it's required fields, if any)
mkXmlAdamVariable
  :: XmlAdamVariable
mkXmlAdamVariable =
  XmlAdamVariable
  { xmlAdamVariableSelf = Nothing
  }

-- ** XmlAdamVarset
-- | XmlAdamVarset
data XmlAdamVarset = XmlAdamVarset
  { xmlAdamVarsetSelf :: !(Maybe AdamVarset) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlAdamVarset
instance A.FromJSON XmlAdamVarset where
  parseJSON = A.withObject "XmlAdamVarset" $ \o ->
    XmlAdamVarset
      <$> (o .:? "self")

-- | ToJSON XmlAdamVarset
instance A.ToJSON XmlAdamVarset where
  toJSON XmlAdamVarset {..} =
   _omitNulls
      [ "self" .= xmlAdamVarsetSelf
      ]


-- | Construct a value of type 'XmlAdamVarset' (by applying it's required fields, if any)
mkXmlAdamVarset
  :: XmlAdamVarset
mkXmlAdamVarset =
  XmlAdamVarset
  { xmlAdamVarsetSelf = Nothing
  }

-- ** XmlCdashClass
-- | XmlCdashClass
data XmlCdashClass = XmlCdashClass
  { xmlCdashClassSelf :: !(Maybe CdashClass) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashClass
instance A.FromJSON XmlCdashClass where
  parseJSON = A.withObject "XmlCdashClass" $ \o ->
    XmlCdashClass
      <$> (o .:? "self")

-- | ToJSON XmlCdashClass
instance A.ToJSON XmlCdashClass where
  toJSON XmlCdashClass {..} =
   _omitNulls
      [ "self" .= xmlCdashClassSelf
      ]


-- | Construct a value of type 'XmlCdashClass' (by applying it's required fields, if any)
mkXmlCdashClass
  :: XmlCdashClass
mkXmlCdashClass =
  XmlCdashClass
  { xmlCdashClassSelf = Nothing
  }

-- ** XmlCdashClassDomains
-- | XmlCdashClassDomains
data XmlCdashClassDomains = XmlCdashClassDomains
  { xmlCdashClassDomainsSelf :: !(Maybe CdashClassDomains) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashClassDomains
instance A.FromJSON XmlCdashClassDomains where
  parseJSON = A.withObject "XmlCdashClassDomains" $ \o ->
    XmlCdashClassDomains
      <$> (o .:? "self")

-- | ToJSON XmlCdashClassDomains
instance A.ToJSON XmlCdashClassDomains where
  toJSON XmlCdashClassDomains {..} =
   _omitNulls
      [ "self" .= xmlCdashClassDomainsSelf
      ]


-- | Construct a value of type 'XmlCdashClassDomains' (by applying it's required fields, if any)
mkXmlCdashClassDomains
  :: XmlCdashClassDomains
mkXmlCdashClassDomains =
  XmlCdashClassDomains
  { xmlCdashClassDomainsSelf = Nothing
  }

-- ** XmlCdashClassField
-- | XmlCdashClassField
data XmlCdashClassField = XmlCdashClassField
  { xmlCdashClassFieldSelf :: !(Maybe CdashClassField) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashClassField
instance A.FromJSON XmlCdashClassField where
  parseJSON = A.withObject "XmlCdashClassField" $ \o ->
    XmlCdashClassField
      <$> (o .:? "self")

-- | ToJSON XmlCdashClassField
instance A.ToJSON XmlCdashClassField where
  toJSON XmlCdashClassField {..} =
   _omitNulls
      [ "self" .= xmlCdashClassFieldSelf
      ]


-- | Construct a value of type 'XmlCdashClassField' (by applying it's required fields, if any)
mkXmlCdashClassField
  :: XmlCdashClassField
mkXmlCdashClassField =
  XmlCdashClassField
  { xmlCdashClassFieldSelf = Nothing
  }

-- ** XmlCdashDomain
-- | XmlCdashDomain
data XmlCdashDomain = XmlCdashDomain
  { xmlCdashDomainSelf :: !(Maybe CdashDomain) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashDomain
instance A.FromJSON XmlCdashDomain where
  parseJSON = A.withObject "XmlCdashDomain" $ \o ->
    XmlCdashDomain
      <$> (o .:? "self")

-- | ToJSON XmlCdashDomain
instance A.ToJSON XmlCdashDomain where
  toJSON XmlCdashDomain {..} =
   _omitNulls
      [ "self" .= xmlCdashDomainSelf
      ]


-- | Construct a value of type 'XmlCdashDomain' (by applying it's required fields, if any)
mkXmlCdashDomain
  :: XmlCdashDomain
mkXmlCdashDomain =
  XmlCdashDomain
  { xmlCdashDomainSelf = Nothing
  }

-- ** XmlCdashDomainField
-- | XmlCdashDomainField
data XmlCdashDomainField = XmlCdashDomainField
  { xmlCdashDomainFieldSelf :: !(Maybe CdashDomainField) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashDomainField
instance A.FromJSON XmlCdashDomainField where
  parseJSON = A.withObject "XmlCdashDomainField" $ \o ->
    XmlCdashDomainField
      <$> (o .:? "self")

-- | ToJSON XmlCdashDomainField
instance A.ToJSON XmlCdashDomainField where
  toJSON XmlCdashDomainField {..} =
   _omitNulls
      [ "self" .= xmlCdashDomainFieldSelf
      ]


-- | Construct a value of type 'XmlCdashDomainField' (by applying it's required fields, if any)
mkXmlCdashDomainField
  :: XmlCdashDomainField
mkXmlCdashDomainField =
  XmlCdashDomainField
  { xmlCdashDomainFieldSelf = Nothing
  }

-- ** XmlCdashDomainFields
-- | XmlCdashDomainFields
data XmlCdashDomainFields = XmlCdashDomainFields
  { xmlCdashDomainFieldsSelf :: !(Maybe CdashDomainFields) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashDomainFields
instance A.FromJSON XmlCdashDomainFields where
  parseJSON = A.withObject "XmlCdashDomainFields" $ \o ->
    XmlCdashDomainFields
      <$> (o .:? "self")

-- | ToJSON XmlCdashDomainFields
instance A.ToJSON XmlCdashDomainFields where
  toJSON XmlCdashDomainFields {..} =
   _omitNulls
      [ "self" .= xmlCdashDomainFieldsSelf
      ]


-- | Construct a value of type 'XmlCdashDomainFields' (by applying it's required fields, if any)
mkXmlCdashDomainFields
  :: XmlCdashDomainFields
mkXmlCdashDomainFields =
  XmlCdashDomainFields
  { xmlCdashDomainFieldsSelf = Nothing
  }

-- ** XmlCdashProduct
-- | XmlCdashProduct
data XmlCdashProduct = XmlCdashProduct
  { xmlCdashProductSelf :: !(Maybe CdashProduct) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashProduct
instance A.FromJSON XmlCdashProduct where
  parseJSON = A.withObject "XmlCdashProduct" $ \o ->
    XmlCdashProduct
      <$> (o .:? "self")

-- | ToJSON XmlCdashProduct
instance A.ToJSON XmlCdashProduct where
  toJSON XmlCdashProduct {..} =
   _omitNulls
      [ "self" .= xmlCdashProductSelf
      ]


-- | Construct a value of type 'XmlCdashProduct' (by applying it's required fields, if any)
mkXmlCdashProduct
  :: XmlCdashProduct
mkXmlCdashProduct =
  XmlCdashProduct
  { xmlCdashProductSelf = Nothing
  }

-- ** XmlCdashProductClasses
-- | XmlCdashProductClasses
data XmlCdashProductClasses = XmlCdashProductClasses
  { xmlCdashProductClassesSelf :: !(Maybe CdashProductClasses) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashProductClasses
instance A.FromJSON XmlCdashProductClasses where
  parseJSON = A.withObject "XmlCdashProductClasses" $ \o ->
    XmlCdashProductClasses
      <$> (o .:? "self")

-- | ToJSON XmlCdashProductClasses
instance A.ToJSON XmlCdashProductClasses where
  toJSON XmlCdashProductClasses {..} =
   _omitNulls
      [ "self" .= xmlCdashProductClassesSelf
      ]


-- | Construct a value of type 'XmlCdashProductClasses' (by applying it's required fields, if any)
mkXmlCdashProductClasses
  :: XmlCdashProductClasses
mkXmlCdashProductClasses =
  XmlCdashProductClasses
  { xmlCdashProductClassesSelf = Nothing
  }

-- ** XmlCdashProductDomains
-- | XmlCdashProductDomains
data XmlCdashProductDomains = XmlCdashProductDomains
  { xmlCdashProductDomainsSelf :: !(Maybe CdashProductDomains) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashProductDomains
instance A.FromJSON XmlCdashProductDomains where
  parseJSON = A.withObject "XmlCdashProductDomains" $ \o ->
    XmlCdashProductDomains
      <$> (o .:? "self")

-- | ToJSON XmlCdashProductDomains
instance A.ToJSON XmlCdashProductDomains where
  toJSON XmlCdashProductDomains {..} =
   _omitNulls
      [ "self" .= xmlCdashProductDomainsSelf
      ]


-- | Construct a value of type 'XmlCdashProductDomains' (by applying it's required fields, if any)
mkXmlCdashProductDomains
  :: XmlCdashProductDomains
mkXmlCdashProductDomains =
  XmlCdashProductDomains
  { xmlCdashProductDomainsSelf = Nothing
  }

-- ** XmlCdashigClass
-- | XmlCdashigClass
data XmlCdashigClass = XmlCdashigClass
  { xmlCdashigClassSelf :: !(Maybe CdashigClass) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashigClass
instance A.FromJSON XmlCdashigClass where
  parseJSON = A.withObject "XmlCdashigClass" $ \o ->
    XmlCdashigClass
      <$> (o .:? "self")

-- | ToJSON XmlCdashigClass
instance A.ToJSON XmlCdashigClass where
  toJSON XmlCdashigClass {..} =
   _omitNulls
      [ "self" .= xmlCdashigClassSelf
      ]


-- | Construct a value of type 'XmlCdashigClass' (by applying it's required fields, if any)
mkXmlCdashigClass
  :: XmlCdashigClass
mkXmlCdashigClass =
  XmlCdashigClass
  { xmlCdashigClassSelf = Nothing
  }

-- ** XmlCdashigClassDomains
-- | XmlCdashigClassDomains
data XmlCdashigClassDomains = XmlCdashigClassDomains
  { xmlCdashigClassDomainsSelf :: !(Maybe CdashigClassDomains) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashigClassDomains
instance A.FromJSON XmlCdashigClassDomains where
  parseJSON = A.withObject "XmlCdashigClassDomains" $ \o ->
    XmlCdashigClassDomains
      <$> (o .:? "self")

-- | ToJSON XmlCdashigClassDomains
instance A.ToJSON XmlCdashigClassDomains where
  toJSON XmlCdashigClassDomains {..} =
   _omitNulls
      [ "self" .= xmlCdashigClassDomainsSelf
      ]


-- | Construct a value of type 'XmlCdashigClassDomains' (by applying it's required fields, if any)
mkXmlCdashigClassDomains
  :: XmlCdashigClassDomains
mkXmlCdashigClassDomains =
  XmlCdashigClassDomains
  { xmlCdashigClassDomainsSelf = Nothing
  }

-- ** XmlCdashigClassScenarios
-- | XmlCdashigClassScenarios
data XmlCdashigClassScenarios = XmlCdashigClassScenarios
  { xmlCdashigClassScenariosSelf :: !(Maybe CdashigClassScenarios) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashigClassScenarios
instance A.FromJSON XmlCdashigClassScenarios where
  parseJSON = A.withObject "XmlCdashigClassScenarios" $ \o ->
    XmlCdashigClassScenarios
      <$> (o .:? "self")

-- | ToJSON XmlCdashigClassScenarios
instance A.ToJSON XmlCdashigClassScenarios where
  toJSON XmlCdashigClassScenarios {..} =
   _omitNulls
      [ "self" .= xmlCdashigClassScenariosSelf
      ]


-- | Construct a value of type 'XmlCdashigClassScenarios' (by applying it's required fields, if any)
mkXmlCdashigClassScenarios
  :: XmlCdashigClassScenarios
mkXmlCdashigClassScenarios =
  XmlCdashigClassScenarios
  { xmlCdashigClassScenariosSelf = Nothing
  }

-- ** XmlCdashigDomain
-- | XmlCdashigDomain
data XmlCdashigDomain = XmlCdashigDomain
  { xmlCdashigDomainSelf :: !(Maybe CdashigDomain) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashigDomain
instance A.FromJSON XmlCdashigDomain where
  parseJSON = A.withObject "XmlCdashigDomain" $ \o ->
    XmlCdashigDomain
      <$> (o .:? "self")

-- | ToJSON XmlCdashigDomain
instance A.ToJSON XmlCdashigDomain where
  toJSON XmlCdashigDomain {..} =
   _omitNulls
      [ "self" .= xmlCdashigDomainSelf
      ]


-- | Construct a value of type 'XmlCdashigDomain' (by applying it's required fields, if any)
mkXmlCdashigDomain
  :: XmlCdashigDomain
mkXmlCdashigDomain =
  XmlCdashigDomain
  { xmlCdashigDomainSelf = Nothing
  }

-- ** XmlCdashigDomainField
-- | XmlCdashigDomainField
data XmlCdashigDomainField = XmlCdashigDomainField
  { xmlCdashigDomainFieldSelf :: !(Maybe CdashigDomainField) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashigDomainField
instance A.FromJSON XmlCdashigDomainField where
  parseJSON = A.withObject "XmlCdashigDomainField" $ \o ->
    XmlCdashigDomainField
      <$> (o .:? "self")

-- | ToJSON XmlCdashigDomainField
instance A.ToJSON XmlCdashigDomainField where
  toJSON XmlCdashigDomainField {..} =
   _omitNulls
      [ "self" .= xmlCdashigDomainFieldSelf
      ]


-- | Construct a value of type 'XmlCdashigDomainField' (by applying it's required fields, if any)
mkXmlCdashigDomainField
  :: XmlCdashigDomainField
mkXmlCdashigDomainField =
  XmlCdashigDomainField
  { xmlCdashigDomainFieldSelf = Nothing
  }

-- ** XmlCdashigDomainFields
-- | XmlCdashigDomainFields
data XmlCdashigDomainFields = XmlCdashigDomainFields
  { xmlCdashigDomainFieldsSelf :: !(Maybe CdashigDomainFields) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashigDomainFields
instance A.FromJSON XmlCdashigDomainFields where
  parseJSON = A.withObject "XmlCdashigDomainFields" $ \o ->
    XmlCdashigDomainFields
      <$> (o .:? "self")

-- | ToJSON XmlCdashigDomainFields
instance A.ToJSON XmlCdashigDomainFields where
  toJSON XmlCdashigDomainFields {..} =
   _omitNulls
      [ "self" .= xmlCdashigDomainFieldsSelf
      ]


-- | Construct a value of type 'XmlCdashigDomainFields' (by applying it's required fields, if any)
mkXmlCdashigDomainFields
  :: XmlCdashigDomainFields
mkXmlCdashigDomainFields =
  XmlCdashigDomainFields
  { xmlCdashigDomainFieldsSelf = Nothing
  }

-- ** XmlCdashigProduct
-- | XmlCdashigProduct
data XmlCdashigProduct = XmlCdashigProduct
  { xmlCdashigProductSelf :: !(Maybe CdashigProduct) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashigProduct
instance A.FromJSON XmlCdashigProduct where
  parseJSON = A.withObject "XmlCdashigProduct" $ \o ->
    XmlCdashigProduct
      <$> (o .:? "self")

-- | ToJSON XmlCdashigProduct
instance A.ToJSON XmlCdashigProduct where
  toJSON XmlCdashigProduct {..} =
   _omitNulls
      [ "self" .= xmlCdashigProductSelf
      ]


-- | Construct a value of type 'XmlCdashigProduct' (by applying it's required fields, if any)
mkXmlCdashigProduct
  :: XmlCdashigProduct
mkXmlCdashigProduct =
  XmlCdashigProduct
  { xmlCdashigProductSelf = Nothing
  }

-- ** XmlCdashigProductClasses
-- | XmlCdashigProductClasses
data XmlCdashigProductClasses = XmlCdashigProductClasses
  { xmlCdashigProductClassesSelf :: !(Maybe CdashigProductClasses) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashigProductClasses
instance A.FromJSON XmlCdashigProductClasses where
  parseJSON = A.withObject "XmlCdashigProductClasses" $ \o ->
    XmlCdashigProductClasses
      <$> (o .:? "self")

-- | ToJSON XmlCdashigProductClasses
instance A.ToJSON XmlCdashigProductClasses where
  toJSON XmlCdashigProductClasses {..} =
   _omitNulls
      [ "self" .= xmlCdashigProductClassesSelf
      ]


-- | Construct a value of type 'XmlCdashigProductClasses' (by applying it's required fields, if any)
mkXmlCdashigProductClasses
  :: XmlCdashigProductClasses
mkXmlCdashigProductClasses =
  XmlCdashigProductClasses
  { xmlCdashigProductClassesSelf = Nothing
  }

-- ** XmlCdashigProductDomains
-- | XmlCdashigProductDomains
data XmlCdashigProductDomains = XmlCdashigProductDomains
  { xmlCdashigProductDomainsSelf :: !(Maybe CdashigProductDomains) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashigProductDomains
instance A.FromJSON XmlCdashigProductDomains where
  parseJSON = A.withObject "XmlCdashigProductDomains" $ \o ->
    XmlCdashigProductDomains
      <$> (o .:? "self")

-- | ToJSON XmlCdashigProductDomains
instance A.ToJSON XmlCdashigProductDomains where
  toJSON XmlCdashigProductDomains {..} =
   _omitNulls
      [ "self" .= xmlCdashigProductDomainsSelf
      ]


-- | Construct a value of type 'XmlCdashigProductDomains' (by applying it's required fields, if any)
mkXmlCdashigProductDomains
  :: XmlCdashigProductDomains
mkXmlCdashigProductDomains =
  XmlCdashigProductDomains
  { xmlCdashigProductDomainsSelf = Nothing
  }

-- ** XmlCdashigProductScenarios
-- | XmlCdashigProductScenarios
data XmlCdashigProductScenarios = XmlCdashigProductScenarios
  { xmlCdashigProductScenariosSelf :: !(Maybe CdashigProductScenarios) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashigProductScenarios
instance A.FromJSON XmlCdashigProductScenarios where
  parseJSON = A.withObject "XmlCdashigProductScenarios" $ \o ->
    XmlCdashigProductScenarios
      <$> (o .:? "self")

-- | ToJSON XmlCdashigProductScenarios
instance A.ToJSON XmlCdashigProductScenarios where
  toJSON XmlCdashigProductScenarios {..} =
   _omitNulls
      [ "self" .= xmlCdashigProductScenariosSelf
      ]


-- | Construct a value of type 'XmlCdashigProductScenarios' (by applying it's required fields, if any)
mkXmlCdashigProductScenarios
  :: XmlCdashigProductScenarios
mkXmlCdashigProductScenarios =
  XmlCdashigProductScenarios
  { xmlCdashigProductScenariosSelf = Nothing
  }

-- ** XmlCdashigScenario
-- | XmlCdashigScenario
data XmlCdashigScenario = XmlCdashigScenario
  { xmlCdashigScenarioSelf :: !(Maybe CdashigScenario) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashigScenario
instance A.FromJSON XmlCdashigScenario where
  parseJSON = A.withObject "XmlCdashigScenario" $ \o ->
    XmlCdashigScenario
      <$> (o .:? "self")

-- | ToJSON XmlCdashigScenario
instance A.ToJSON XmlCdashigScenario where
  toJSON XmlCdashigScenario {..} =
   _omitNulls
      [ "self" .= xmlCdashigScenarioSelf
      ]


-- | Construct a value of type 'XmlCdashigScenario' (by applying it's required fields, if any)
mkXmlCdashigScenario
  :: XmlCdashigScenario
mkXmlCdashigScenario =
  XmlCdashigScenario
  { xmlCdashigScenarioSelf = Nothing
  }

-- ** XmlCdashigScenarioField
-- | XmlCdashigScenarioField
data XmlCdashigScenarioField = XmlCdashigScenarioField
  { xmlCdashigScenarioFieldSelf :: !(Maybe CdashigScenarioField) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashigScenarioField
instance A.FromJSON XmlCdashigScenarioField where
  parseJSON = A.withObject "XmlCdashigScenarioField" $ \o ->
    XmlCdashigScenarioField
      <$> (o .:? "self")

-- | ToJSON XmlCdashigScenarioField
instance A.ToJSON XmlCdashigScenarioField where
  toJSON XmlCdashigScenarioField {..} =
   _omitNulls
      [ "self" .= xmlCdashigScenarioFieldSelf
      ]


-- | Construct a value of type 'XmlCdashigScenarioField' (by applying it's required fields, if any)
mkXmlCdashigScenarioField
  :: XmlCdashigScenarioField
mkXmlCdashigScenarioField =
  XmlCdashigScenarioField
  { xmlCdashigScenarioFieldSelf = Nothing
  }

-- ** XmlCdashigScenarioFields
-- | XmlCdashigScenarioFields
data XmlCdashigScenarioFields = XmlCdashigScenarioFields
  { xmlCdashigScenarioFieldsSelf :: !(Maybe CdashigScenarioFields) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCdashigScenarioFields
instance A.FromJSON XmlCdashigScenarioFields where
  parseJSON = A.withObject "XmlCdashigScenarioFields" $ \o ->
    XmlCdashigScenarioFields
      <$> (o .:? "self")

-- | ToJSON XmlCdashigScenarioFields
instance A.ToJSON XmlCdashigScenarioFields where
  toJSON XmlCdashigScenarioFields {..} =
   _omitNulls
      [ "self" .= xmlCdashigScenarioFieldsSelf
      ]


-- | Construct a value of type 'XmlCdashigScenarioFields' (by applying it's required fields, if any)
mkXmlCdashigScenarioFields
  :: XmlCdashigScenarioFields
mkXmlCdashigScenarioFields =
  XmlCdashigScenarioFields
  { xmlCdashigScenarioFieldsSelf = Nothing
  }

-- ** XmlCtCodelist
-- | XmlCtCodelist
data XmlCtCodelist = XmlCtCodelist
  { xmlCtCodelistSelf :: !(Maybe CtCodelist) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCtCodelist
instance A.FromJSON XmlCtCodelist where
  parseJSON = A.withObject "XmlCtCodelist" $ \o ->
    XmlCtCodelist
      <$> (o .:? "self")

-- | ToJSON XmlCtCodelist
instance A.ToJSON XmlCtCodelist where
  toJSON XmlCtCodelist {..} =
   _omitNulls
      [ "self" .= xmlCtCodelistSelf
      ]


-- | Construct a value of type 'XmlCtCodelist' (by applying it's required fields, if any)
mkXmlCtCodelist
  :: XmlCtCodelist
mkXmlCtCodelist =
  XmlCtCodelist
  { xmlCtCodelistSelf = Nothing
  }

-- ** XmlCtCodelistTerms
-- | XmlCtCodelistTerms
data XmlCtCodelistTerms = XmlCtCodelistTerms
  { xmlCtCodelistTermsSelf :: !(Maybe CtCodelistTerms) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCtCodelistTerms
instance A.FromJSON XmlCtCodelistTerms where
  parseJSON = A.withObject "XmlCtCodelistTerms" $ \o ->
    XmlCtCodelistTerms
      <$> (o .:? "self")

-- | ToJSON XmlCtCodelistTerms
instance A.ToJSON XmlCtCodelistTerms where
  toJSON XmlCtCodelistTerms {..} =
   _omitNulls
      [ "self" .= xmlCtCodelistTermsSelf
      ]


-- | Construct a value of type 'XmlCtCodelistTerms' (by applying it's required fields, if any)
mkXmlCtCodelistTerms
  :: XmlCtCodelistTerms
mkXmlCtCodelistTerms =
  XmlCtCodelistTerms
  { xmlCtCodelistTermsSelf = Nothing
  }

-- ** XmlCtPackage
-- | XmlCtPackage
data XmlCtPackage = XmlCtPackage
  { xmlCtPackageSelf :: !(Maybe CtPackage) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCtPackage
instance A.FromJSON XmlCtPackage where
  parseJSON = A.withObject "XmlCtPackage" $ \o ->
    XmlCtPackage
      <$> (o .:? "self")

-- | ToJSON XmlCtPackage
instance A.ToJSON XmlCtPackage where
  toJSON XmlCtPackage {..} =
   _omitNulls
      [ "self" .= xmlCtPackageSelf
      ]


-- | Construct a value of type 'XmlCtPackage' (by applying it's required fields, if any)
mkXmlCtPackage
  :: XmlCtPackage
mkXmlCtPackage =
  XmlCtPackage
  { xmlCtPackageSelf = Nothing
  }

-- ** XmlCtPackageCodelists
-- | XmlCtPackageCodelists
data XmlCtPackageCodelists = XmlCtPackageCodelists
  { xmlCtPackageCodelistsSelf :: !(Maybe CtPackageCodelists) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCtPackageCodelists
instance A.FromJSON XmlCtPackageCodelists where
  parseJSON = A.withObject "XmlCtPackageCodelists" $ \o ->
    XmlCtPackageCodelists
      <$> (o .:? "self")

-- | ToJSON XmlCtPackageCodelists
instance A.ToJSON XmlCtPackageCodelists where
  toJSON XmlCtPackageCodelists {..} =
   _omitNulls
      [ "self" .= xmlCtPackageCodelistsSelf
      ]


-- | Construct a value of type 'XmlCtPackageCodelists' (by applying it's required fields, if any)
mkXmlCtPackageCodelists
  :: XmlCtPackageCodelists
mkXmlCtPackageCodelists =
  XmlCtPackageCodelists
  { xmlCtPackageCodelistsSelf = Nothing
  }

-- ** XmlCtPackages
-- | XmlCtPackages
data XmlCtPackages = XmlCtPackages
  { xmlCtPackagesSelf :: !(Maybe CtPackages) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCtPackages
instance A.FromJSON XmlCtPackages where
  parseJSON = A.withObject "XmlCtPackages" $ \o ->
    XmlCtPackages
      <$> (o .:? "self")

-- | ToJSON XmlCtPackages
instance A.ToJSON XmlCtPackages where
  toJSON XmlCtPackages {..} =
   _omitNulls
      [ "self" .= xmlCtPackagesSelf
      ]


-- | Construct a value of type 'XmlCtPackages' (by applying it's required fields, if any)
mkXmlCtPackages
  :: XmlCtPackages
mkXmlCtPackages =
  XmlCtPackages
  { xmlCtPackagesSelf = Nothing
  }

-- ** XmlCtTerm
-- | XmlCtTerm
data XmlCtTerm = XmlCtTerm
  { xmlCtTermSelf :: !(Maybe CtTerm) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlCtTerm
instance A.FromJSON XmlCtTerm where
  parseJSON = A.withObject "XmlCtTerm" $ \o ->
    XmlCtTerm
      <$> (o .:? "self")

-- | ToJSON XmlCtTerm
instance A.ToJSON XmlCtTerm where
  toJSON XmlCtTerm {..} =
   _omitNulls
      [ "self" .= xmlCtTermSelf
      ]


-- | Construct a value of type 'XmlCtTerm' (by applying it's required fields, if any)
mkXmlCtTerm
  :: XmlCtTerm
mkXmlCtTerm =
  XmlCtTerm
  { xmlCtTermSelf = Nothing
  }

-- ** XmlLastupdated
-- | XmlLastupdated
data XmlLastupdated = XmlLastupdated
  { xmlLastupdatedSelf :: !(Maybe Lastupdated) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlLastupdated
instance A.FromJSON XmlLastupdated where
  parseJSON = A.withObject "XmlLastupdated" $ \o ->
    XmlLastupdated
      <$> (o .:? "self")

-- | ToJSON XmlLastupdated
instance A.ToJSON XmlLastupdated where
  toJSON XmlLastupdated {..} =
   _omitNulls
      [ "self" .= xmlLastupdatedSelf
      ]


-- | Construct a value of type 'XmlLastupdated' (by applying it's required fields, if any)
mkXmlLastupdated
  :: XmlLastupdated
mkXmlLastupdated =
  XmlLastupdated
  { xmlLastupdatedSelf = Nothing
  }

-- ** XmlProductgroupDataAnalysis
-- | XmlProductgroupDataAnalysis
data XmlProductgroupDataAnalysis = XmlProductgroupDataAnalysis
  { xmlProductgroupDataAnalysisSelf :: !(Maybe ProductgroupDataAnalysis) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlProductgroupDataAnalysis
instance A.FromJSON XmlProductgroupDataAnalysis where
  parseJSON = A.withObject "XmlProductgroupDataAnalysis" $ \o ->
    XmlProductgroupDataAnalysis
      <$> (o .:? "self")

-- | ToJSON XmlProductgroupDataAnalysis
instance A.ToJSON XmlProductgroupDataAnalysis where
  toJSON XmlProductgroupDataAnalysis {..} =
   _omitNulls
      [ "self" .= xmlProductgroupDataAnalysisSelf
      ]


-- | Construct a value of type 'XmlProductgroupDataAnalysis' (by applying it's required fields, if any)
mkXmlProductgroupDataAnalysis
  :: XmlProductgroupDataAnalysis
mkXmlProductgroupDataAnalysis =
  XmlProductgroupDataAnalysis
  { xmlProductgroupDataAnalysisSelf = Nothing
  }

-- ** XmlProductgroupDataCollection
-- | XmlProductgroupDataCollection
data XmlProductgroupDataCollection = XmlProductgroupDataCollection
  { xmlProductgroupDataCollectionSelf :: !(Maybe ProductgroupDataCollection) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlProductgroupDataCollection
instance A.FromJSON XmlProductgroupDataCollection where
  parseJSON = A.withObject "XmlProductgroupDataCollection" $ \o ->
    XmlProductgroupDataCollection
      <$> (o .:? "self")

-- | ToJSON XmlProductgroupDataCollection
instance A.ToJSON XmlProductgroupDataCollection where
  toJSON XmlProductgroupDataCollection {..} =
   _omitNulls
      [ "self" .= xmlProductgroupDataCollectionSelf
      ]


-- | Construct a value of type 'XmlProductgroupDataCollection' (by applying it's required fields, if any)
mkXmlProductgroupDataCollection
  :: XmlProductgroupDataCollection
mkXmlProductgroupDataCollection =
  XmlProductgroupDataCollection
  { xmlProductgroupDataCollectionSelf = Nothing
  }

-- ** XmlProductgroupDataTabulation
-- | XmlProductgroupDataTabulation
data XmlProductgroupDataTabulation = XmlProductgroupDataTabulation
  { xmlProductgroupDataTabulationSelf :: !(Maybe ProductgroupDataTabulation) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlProductgroupDataTabulation
instance A.FromJSON XmlProductgroupDataTabulation where
  parseJSON = A.withObject "XmlProductgroupDataTabulation" $ \o ->
    XmlProductgroupDataTabulation
      <$> (o .:? "self")

-- | ToJSON XmlProductgroupDataTabulation
instance A.ToJSON XmlProductgroupDataTabulation where
  toJSON XmlProductgroupDataTabulation {..} =
   _omitNulls
      [ "self" .= xmlProductgroupDataTabulationSelf
      ]


-- | Construct a value of type 'XmlProductgroupDataTabulation' (by applying it's required fields, if any)
mkXmlProductgroupDataTabulation
  :: XmlProductgroupDataTabulation
mkXmlProductgroupDataTabulation =
  XmlProductgroupDataTabulation
  { xmlProductgroupDataTabulationSelf = Nothing
  }

-- ** XmlProductgroupTerminology
-- | XmlProductgroupTerminology
data XmlProductgroupTerminology = XmlProductgroupTerminology
  { xmlProductgroupTerminologySelf :: !(Maybe ProductgroupTerminology) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlProductgroupTerminology
instance A.FromJSON XmlProductgroupTerminology where
  parseJSON = A.withObject "XmlProductgroupTerminology" $ \o ->
    XmlProductgroupTerminology
      <$> (o .:? "self")

-- | ToJSON XmlProductgroupTerminology
instance A.ToJSON XmlProductgroupTerminology where
  toJSON XmlProductgroupTerminology {..} =
   _omitNulls
      [ "self" .= xmlProductgroupTerminologySelf
      ]


-- | Construct a value of type 'XmlProductgroupTerminology' (by applying it's required fields, if any)
mkXmlProductgroupTerminology
  :: XmlProductgroupTerminology
mkXmlProductgroupTerminology =
  XmlProductgroupTerminology
  { xmlProductgroupTerminologySelf = Nothing
  }

-- ** XmlProducts
-- | XmlProducts
data XmlProducts = XmlProducts
  { xmlProductsSelf :: !(Maybe Products) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlProducts
instance A.FromJSON XmlProducts where
  parseJSON = A.withObject "XmlProducts" $ \o ->
    XmlProducts
      <$> (o .:? "self")

-- | ToJSON XmlProducts
instance A.ToJSON XmlProducts where
  toJSON XmlProducts {..} =
   _omitNulls
      [ "self" .= xmlProductsSelf
      ]


-- | Construct a value of type 'XmlProducts' (by applying it's required fields, if any)
mkXmlProducts
  :: XmlProducts
mkXmlProducts =
  XmlProducts
  { xmlProductsSelf = Nothing
  }

-- ** XmlQrsItem
-- | XmlQrsItem
data XmlQrsItem = XmlQrsItem
  { xmlQrsItemSelf :: !(Maybe QrsItem) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlQrsItem
instance A.FromJSON XmlQrsItem where
  parseJSON = A.withObject "XmlQrsItem" $ \o ->
    XmlQrsItem
      <$> (o .:? "self")

-- | ToJSON XmlQrsItem
instance A.ToJSON XmlQrsItem where
  toJSON XmlQrsItem {..} =
   _omitNulls
      [ "self" .= xmlQrsItemSelf
      ]


-- | Construct a value of type 'XmlQrsItem' (by applying it's required fields, if any)
mkXmlQrsItem
  :: XmlQrsItem
mkXmlQrsItem =
  XmlQrsItem
  { xmlQrsItemSelf = Nothing
  }

-- ** XmlQrsItems
-- | XmlQrsItems
data XmlQrsItems = XmlQrsItems
  { xmlQrsItemsSelf :: !(Maybe QrsItems) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlQrsItems
instance A.FromJSON XmlQrsItems where
  parseJSON = A.withObject "XmlQrsItems" $ \o ->
    XmlQrsItems
      <$> (o .:? "self")

-- | ToJSON XmlQrsItems
instance A.ToJSON XmlQrsItems where
  toJSON XmlQrsItems {..} =
   _omitNulls
      [ "self" .= xmlQrsItemsSelf
      ]


-- | Construct a value of type 'XmlQrsItems' (by applying it's required fields, if any)
mkXmlQrsItems
  :: XmlQrsItems
mkXmlQrsItems =
  XmlQrsItems
  { xmlQrsItemsSelf = Nothing
  }

-- ** XmlQrsProduct
-- | XmlQrsProduct
data XmlQrsProduct = XmlQrsProduct
  { xmlQrsProductSelf :: !(Maybe QrsProduct) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlQrsProduct
instance A.FromJSON XmlQrsProduct where
  parseJSON = A.withObject "XmlQrsProduct" $ \o ->
    XmlQrsProduct
      <$> (o .:? "self")

-- | ToJSON XmlQrsProduct
instance A.ToJSON XmlQrsProduct where
  toJSON XmlQrsProduct {..} =
   _omitNulls
      [ "self" .= xmlQrsProductSelf
      ]


-- | Construct a value of type 'XmlQrsProduct' (by applying it's required fields, if any)
mkXmlQrsProduct
  :: XmlQrsProduct
mkXmlQrsProduct =
  XmlQrsProduct
  { xmlQrsProductSelf = Nothing
  }

-- ** XmlQrsResponsegroup
-- | XmlQrsResponsegroup
data XmlQrsResponsegroup = XmlQrsResponsegroup
  { xmlQrsResponsegroupSelf :: !(Maybe QrsResponsegroup) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlQrsResponsegroup
instance A.FromJSON XmlQrsResponsegroup where
  parseJSON = A.withObject "XmlQrsResponsegroup" $ \o ->
    XmlQrsResponsegroup
      <$> (o .:? "self")

-- | ToJSON XmlQrsResponsegroup
instance A.ToJSON XmlQrsResponsegroup where
  toJSON XmlQrsResponsegroup {..} =
   _omitNulls
      [ "self" .= xmlQrsResponsegroupSelf
      ]


-- | Construct a value of type 'XmlQrsResponsegroup' (by applying it's required fields, if any)
mkXmlQrsResponsegroup
  :: XmlQrsResponsegroup
mkXmlQrsResponsegroup =
  XmlQrsResponsegroup
  { xmlQrsResponsegroupSelf = Nothing
  }

-- ** XmlQrsResponsegroups
-- | XmlQrsResponsegroups
data XmlQrsResponsegroups = XmlQrsResponsegroups
  { xmlQrsResponsegroupsSelf :: !(Maybe QrsResponsegroups) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlQrsResponsegroups
instance A.FromJSON XmlQrsResponsegroups where
  parseJSON = A.withObject "XmlQrsResponsegroups" $ \o ->
    XmlQrsResponsegroups
      <$> (o .:? "self")

-- | ToJSON XmlQrsResponsegroups
instance A.ToJSON XmlQrsResponsegroups where
  toJSON XmlQrsResponsegroups {..} =
   _omitNulls
      [ "self" .= xmlQrsResponsegroupsSelf
      ]


-- | Construct a value of type 'XmlQrsResponsegroups' (by applying it's required fields, if any)
mkXmlQrsResponsegroups
  :: XmlQrsResponsegroups
mkXmlQrsResponsegroups =
  XmlQrsResponsegroups
  { xmlQrsResponsegroupsSelf = Nothing
  }

-- ** XmlRootCdashClassField
-- | XmlRootCdashClassField
data XmlRootCdashClassField = XmlRootCdashClassField
  { xmlRootCdashClassFieldSelf :: !(Maybe RootCdashClassField) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlRootCdashClassField
instance A.FromJSON XmlRootCdashClassField where
  parseJSON = A.withObject "XmlRootCdashClassField" $ \o ->
    XmlRootCdashClassField
      <$> (o .:? "self")

-- | ToJSON XmlRootCdashClassField
instance A.ToJSON XmlRootCdashClassField where
  toJSON XmlRootCdashClassField {..} =
   _omitNulls
      [ "self" .= xmlRootCdashClassFieldSelf
      ]


-- | Construct a value of type 'XmlRootCdashClassField' (by applying it's required fields, if any)
mkXmlRootCdashClassField
  :: XmlRootCdashClassField
mkXmlRootCdashClassField =
  XmlRootCdashClassField
  { xmlRootCdashClassFieldSelf = Nothing
  }

-- ** XmlRootCdashDomainField
-- | XmlRootCdashDomainField
data XmlRootCdashDomainField = XmlRootCdashDomainField
  { xmlRootCdashDomainFieldSelf :: !(Maybe RootCdashDomainField) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlRootCdashDomainField
instance A.FromJSON XmlRootCdashDomainField where
  parseJSON = A.withObject "XmlRootCdashDomainField" $ \o ->
    XmlRootCdashDomainField
      <$> (o .:? "self")

-- | ToJSON XmlRootCdashDomainField
instance A.ToJSON XmlRootCdashDomainField where
  toJSON XmlRootCdashDomainField {..} =
   _omitNulls
      [ "self" .= xmlRootCdashDomainFieldSelf
      ]


-- | Construct a value of type 'XmlRootCdashDomainField' (by applying it's required fields, if any)
mkXmlRootCdashDomainField
  :: XmlRootCdashDomainField
mkXmlRootCdashDomainField =
  XmlRootCdashDomainField
  { xmlRootCdashDomainFieldSelf = Nothing
  }

-- ** XmlRootCdashigDomainField
-- | XmlRootCdashigDomainField
data XmlRootCdashigDomainField = XmlRootCdashigDomainField
  { xmlRootCdashigDomainFieldSelf :: !(Maybe RootCdashigDomainField) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlRootCdashigDomainField
instance A.FromJSON XmlRootCdashigDomainField where
  parseJSON = A.withObject "XmlRootCdashigDomainField" $ \o ->
    XmlRootCdashigDomainField
      <$> (o .:? "self")

-- | ToJSON XmlRootCdashigDomainField
instance A.ToJSON XmlRootCdashigDomainField where
  toJSON XmlRootCdashigDomainField {..} =
   _omitNulls
      [ "self" .= xmlRootCdashigDomainFieldSelf
      ]


-- | Construct a value of type 'XmlRootCdashigDomainField' (by applying it's required fields, if any)
mkXmlRootCdashigDomainField
  :: XmlRootCdashigDomainField
mkXmlRootCdashigDomainField =
  XmlRootCdashigDomainField
  { xmlRootCdashigDomainFieldSelf = Nothing
  }

-- ** XmlRootCdashigScenarioField
-- | XmlRootCdashigScenarioField
data XmlRootCdashigScenarioField = XmlRootCdashigScenarioField
  { xmlRootCdashigScenarioFieldSelf :: !(Maybe RootCdashigScenarioField) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlRootCdashigScenarioField
instance A.FromJSON XmlRootCdashigScenarioField where
  parseJSON = A.withObject "XmlRootCdashigScenarioField" $ \o ->
    XmlRootCdashigScenarioField
      <$> (o .:? "self")

-- | ToJSON XmlRootCdashigScenarioField
instance A.ToJSON XmlRootCdashigScenarioField where
  toJSON XmlRootCdashigScenarioField {..} =
   _omitNulls
      [ "self" .= xmlRootCdashigScenarioFieldSelf
      ]


-- | Construct a value of type 'XmlRootCdashigScenarioField' (by applying it's required fields, if any)
mkXmlRootCdashigScenarioField
  :: XmlRootCdashigScenarioField
mkXmlRootCdashigScenarioField =
  XmlRootCdashigScenarioField
  { xmlRootCdashigScenarioFieldSelf = Nothing
  }

-- ** XmlRootCtCodelist
-- | XmlRootCtCodelist
data XmlRootCtCodelist = XmlRootCtCodelist
  { xmlRootCtCodelistSelf :: !(Maybe RootCtCodelist) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlRootCtCodelist
instance A.FromJSON XmlRootCtCodelist where
  parseJSON = A.withObject "XmlRootCtCodelist" $ \o ->
    XmlRootCtCodelist
      <$> (o .:? "self")

-- | ToJSON XmlRootCtCodelist
instance A.ToJSON XmlRootCtCodelist where
  toJSON XmlRootCtCodelist {..} =
   _omitNulls
      [ "self" .= xmlRootCtCodelistSelf
      ]


-- | Construct a value of type 'XmlRootCtCodelist' (by applying it's required fields, if any)
mkXmlRootCtCodelist
  :: XmlRootCtCodelist
mkXmlRootCtCodelist =
  XmlRootCtCodelist
  { xmlRootCtCodelistSelf = Nothing
  }

-- ** XmlRootCtTerm
-- | XmlRootCtTerm
data XmlRootCtTerm = XmlRootCtTerm
  { xmlRootCtTermSelf :: !(Maybe RootCtTerm) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlRootCtTerm
instance A.FromJSON XmlRootCtTerm where
  parseJSON = A.withObject "XmlRootCtTerm" $ \o ->
    XmlRootCtTerm
      <$> (o .:? "self")

-- | ToJSON XmlRootCtTerm
instance A.ToJSON XmlRootCtTerm where
  toJSON XmlRootCtTerm {..} =
   _omitNulls
      [ "self" .= xmlRootCtTermSelf
      ]


-- | Construct a value of type 'XmlRootCtTerm' (by applying it's required fields, if any)
mkXmlRootCtTerm
  :: XmlRootCtTerm
mkXmlRootCtTerm =
  XmlRootCtTerm
  { xmlRootCtTermSelf = Nothing
  }

-- ** XmlRootSdtmClassVariable
-- | XmlRootSdtmClassVariable
data XmlRootSdtmClassVariable = XmlRootSdtmClassVariable
  { xmlRootSdtmClassVariableSelf :: !(Maybe RootSdtmClassVariable) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlRootSdtmClassVariable
instance A.FromJSON XmlRootSdtmClassVariable where
  parseJSON = A.withObject "XmlRootSdtmClassVariable" $ \o ->
    XmlRootSdtmClassVariable
      <$> (o .:? "self")

-- | ToJSON XmlRootSdtmClassVariable
instance A.ToJSON XmlRootSdtmClassVariable where
  toJSON XmlRootSdtmClassVariable {..} =
   _omitNulls
      [ "self" .= xmlRootSdtmClassVariableSelf
      ]


-- | Construct a value of type 'XmlRootSdtmClassVariable' (by applying it's required fields, if any)
mkXmlRootSdtmClassVariable
  :: XmlRootSdtmClassVariable
mkXmlRootSdtmClassVariable =
  XmlRootSdtmClassVariable
  { xmlRootSdtmClassVariableSelf = Nothing
  }

-- ** XmlRootSdtmDatasetVariable
-- | XmlRootSdtmDatasetVariable
data XmlRootSdtmDatasetVariable = XmlRootSdtmDatasetVariable
  { xmlRootSdtmDatasetVariableSelf :: !(Maybe RootSdtmDatasetVariable) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlRootSdtmDatasetVariable
instance A.FromJSON XmlRootSdtmDatasetVariable where
  parseJSON = A.withObject "XmlRootSdtmDatasetVariable" $ \o ->
    XmlRootSdtmDatasetVariable
      <$> (o .:? "self")

-- | ToJSON XmlRootSdtmDatasetVariable
instance A.ToJSON XmlRootSdtmDatasetVariable where
  toJSON XmlRootSdtmDatasetVariable {..} =
   _omitNulls
      [ "self" .= xmlRootSdtmDatasetVariableSelf
      ]


-- | Construct a value of type 'XmlRootSdtmDatasetVariable' (by applying it's required fields, if any)
mkXmlRootSdtmDatasetVariable
  :: XmlRootSdtmDatasetVariable
mkXmlRootSdtmDatasetVariable =
  XmlRootSdtmDatasetVariable
  { xmlRootSdtmDatasetVariableSelf = Nothing
  }

-- ** XmlRootSdtmigDatasetVariable
-- | XmlRootSdtmigDatasetVariable
data XmlRootSdtmigDatasetVariable = XmlRootSdtmigDatasetVariable
  { xmlRootSdtmigDatasetVariableSelf :: !(Maybe RootSdtmigDatasetVariable) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlRootSdtmigDatasetVariable
instance A.FromJSON XmlRootSdtmigDatasetVariable where
  parseJSON = A.withObject "XmlRootSdtmigDatasetVariable" $ \o ->
    XmlRootSdtmigDatasetVariable
      <$> (o .:? "self")

-- | ToJSON XmlRootSdtmigDatasetVariable
instance A.ToJSON XmlRootSdtmigDatasetVariable where
  toJSON XmlRootSdtmigDatasetVariable {..} =
   _omitNulls
      [ "self" .= xmlRootSdtmigDatasetVariableSelf
      ]


-- | Construct a value of type 'XmlRootSdtmigDatasetVariable' (by applying it's required fields, if any)
mkXmlRootSdtmigDatasetVariable
  :: XmlRootSdtmigDatasetVariable
mkXmlRootSdtmigDatasetVariable =
  XmlRootSdtmigDatasetVariable
  { xmlRootSdtmigDatasetVariableSelf = Nothing
  }

-- ** XmlRootSendigDatasetVariable
-- | XmlRootSendigDatasetVariable
data XmlRootSendigDatasetVariable = XmlRootSendigDatasetVariable
  { xmlRootSendigDatasetVariableSelf :: !(Maybe RootSendigDatasetVariable) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlRootSendigDatasetVariable
instance A.FromJSON XmlRootSendigDatasetVariable where
  parseJSON = A.withObject "XmlRootSendigDatasetVariable" $ \o ->
    XmlRootSendigDatasetVariable
      <$> (o .:? "self")

-- | ToJSON XmlRootSendigDatasetVariable
instance A.ToJSON XmlRootSendigDatasetVariable where
  toJSON XmlRootSendigDatasetVariable {..} =
   _omitNulls
      [ "self" .= xmlRootSendigDatasetVariableSelf
      ]


-- | Construct a value of type 'XmlRootSendigDatasetVariable' (by applying it's required fields, if any)
mkXmlRootSendigDatasetVariable
  :: XmlRootSendigDatasetVariable
mkXmlRootSendigDatasetVariable =
  XmlRootSendigDatasetVariable
  { xmlRootSendigDatasetVariableSelf = Nothing
  }

-- ** XmlSdtmClass
-- | XmlSdtmClass
data XmlSdtmClass = XmlSdtmClass
  { xmlSdtmClassSelf :: !(Maybe SdtmClass) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmClass
instance A.FromJSON XmlSdtmClass where
  parseJSON = A.withObject "XmlSdtmClass" $ \o ->
    XmlSdtmClass
      <$> (o .:? "self")

-- | ToJSON XmlSdtmClass
instance A.ToJSON XmlSdtmClass where
  toJSON XmlSdtmClass {..} =
   _omitNulls
      [ "self" .= xmlSdtmClassSelf
      ]


-- | Construct a value of type 'XmlSdtmClass' (by applying it's required fields, if any)
mkXmlSdtmClass
  :: XmlSdtmClass
mkXmlSdtmClass =
  XmlSdtmClass
  { xmlSdtmClassSelf = Nothing
  }

-- ** XmlSdtmClassDatasets
-- | XmlSdtmClassDatasets
data XmlSdtmClassDatasets = XmlSdtmClassDatasets
  { xmlSdtmClassDatasetsSelf :: !(Maybe SdtmClassDatasets) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmClassDatasets
instance A.FromJSON XmlSdtmClassDatasets where
  parseJSON = A.withObject "XmlSdtmClassDatasets" $ \o ->
    XmlSdtmClassDatasets
      <$> (o .:? "self")

-- | ToJSON XmlSdtmClassDatasets
instance A.ToJSON XmlSdtmClassDatasets where
  toJSON XmlSdtmClassDatasets {..} =
   _omitNulls
      [ "self" .= xmlSdtmClassDatasetsSelf
      ]


-- | Construct a value of type 'XmlSdtmClassDatasets' (by applying it's required fields, if any)
mkXmlSdtmClassDatasets
  :: XmlSdtmClassDatasets
mkXmlSdtmClassDatasets =
  XmlSdtmClassDatasets
  { xmlSdtmClassDatasetsSelf = Nothing
  }

-- ** XmlSdtmClassVariable
-- | XmlSdtmClassVariable
data XmlSdtmClassVariable = XmlSdtmClassVariable
  { xmlSdtmClassVariableSelf :: !(Maybe SdtmClassVariable) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmClassVariable
instance A.FromJSON XmlSdtmClassVariable where
  parseJSON = A.withObject "XmlSdtmClassVariable" $ \o ->
    XmlSdtmClassVariable
      <$> (o .:? "self")

-- | ToJSON XmlSdtmClassVariable
instance A.ToJSON XmlSdtmClassVariable where
  toJSON XmlSdtmClassVariable {..} =
   _omitNulls
      [ "self" .= xmlSdtmClassVariableSelf
      ]


-- | Construct a value of type 'XmlSdtmClassVariable' (by applying it's required fields, if any)
mkXmlSdtmClassVariable
  :: XmlSdtmClassVariable
mkXmlSdtmClassVariable =
  XmlSdtmClassVariable
  { xmlSdtmClassVariableSelf = Nothing
  }

-- ** XmlSdtmClassVariables
-- | XmlSdtmClassVariables
data XmlSdtmClassVariables = XmlSdtmClassVariables
  { xmlSdtmClassVariablesSelf :: !(Maybe SdtmClassVariables) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmClassVariables
instance A.FromJSON XmlSdtmClassVariables where
  parseJSON = A.withObject "XmlSdtmClassVariables" $ \o ->
    XmlSdtmClassVariables
      <$> (o .:? "self")

-- | ToJSON XmlSdtmClassVariables
instance A.ToJSON XmlSdtmClassVariables where
  toJSON XmlSdtmClassVariables {..} =
   _omitNulls
      [ "self" .= xmlSdtmClassVariablesSelf
      ]


-- | Construct a value of type 'XmlSdtmClassVariables' (by applying it's required fields, if any)
mkXmlSdtmClassVariables
  :: XmlSdtmClassVariables
mkXmlSdtmClassVariables =
  XmlSdtmClassVariables
  { xmlSdtmClassVariablesSelf = Nothing
  }

-- ** XmlSdtmClasses
-- | XmlSdtmClasses
data XmlSdtmClasses = XmlSdtmClasses
  { xmlSdtmClassesSelf :: !(Maybe SdtmClasses) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmClasses
instance A.FromJSON XmlSdtmClasses where
  parseJSON = A.withObject "XmlSdtmClasses" $ \o ->
    XmlSdtmClasses
      <$> (o .:? "self")

-- | ToJSON XmlSdtmClasses
instance A.ToJSON XmlSdtmClasses where
  toJSON XmlSdtmClasses {..} =
   _omitNulls
      [ "self" .= xmlSdtmClassesSelf
      ]


-- | Construct a value of type 'XmlSdtmClasses' (by applying it's required fields, if any)
mkXmlSdtmClasses
  :: XmlSdtmClasses
mkXmlSdtmClasses =
  XmlSdtmClasses
  { xmlSdtmClassesSelf = Nothing
  }

-- ** XmlSdtmDataset
-- | XmlSdtmDataset
data XmlSdtmDataset = XmlSdtmDataset
  { xmlSdtmDatasetSelf :: !(Maybe SdtmDataset) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmDataset
instance A.FromJSON XmlSdtmDataset where
  parseJSON = A.withObject "XmlSdtmDataset" $ \o ->
    XmlSdtmDataset
      <$> (o .:? "self")

-- | ToJSON XmlSdtmDataset
instance A.ToJSON XmlSdtmDataset where
  toJSON XmlSdtmDataset {..} =
   _omitNulls
      [ "self" .= xmlSdtmDatasetSelf
      ]


-- | Construct a value of type 'XmlSdtmDataset' (by applying it's required fields, if any)
mkXmlSdtmDataset
  :: XmlSdtmDataset
mkXmlSdtmDataset =
  XmlSdtmDataset
  { xmlSdtmDatasetSelf = Nothing
  }

-- ** XmlSdtmDatasetVariable
-- | XmlSdtmDatasetVariable
data XmlSdtmDatasetVariable = XmlSdtmDatasetVariable
  { xmlSdtmDatasetVariableSelf :: !(Maybe SdtmDatasetVariable) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmDatasetVariable
instance A.FromJSON XmlSdtmDatasetVariable where
  parseJSON = A.withObject "XmlSdtmDatasetVariable" $ \o ->
    XmlSdtmDatasetVariable
      <$> (o .:? "self")

-- | ToJSON XmlSdtmDatasetVariable
instance A.ToJSON XmlSdtmDatasetVariable where
  toJSON XmlSdtmDatasetVariable {..} =
   _omitNulls
      [ "self" .= xmlSdtmDatasetVariableSelf
      ]


-- | Construct a value of type 'XmlSdtmDatasetVariable' (by applying it's required fields, if any)
mkXmlSdtmDatasetVariable
  :: XmlSdtmDatasetVariable
mkXmlSdtmDatasetVariable =
  XmlSdtmDatasetVariable
  { xmlSdtmDatasetVariableSelf = Nothing
  }

-- ** XmlSdtmDatasetVariables
-- | XmlSdtmDatasetVariables
data XmlSdtmDatasetVariables = XmlSdtmDatasetVariables
  { xmlSdtmDatasetVariablesSelf :: !(Maybe SdtmDatasetVariables) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmDatasetVariables
instance A.FromJSON XmlSdtmDatasetVariables where
  parseJSON = A.withObject "XmlSdtmDatasetVariables" $ \o ->
    XmlSdtmDatasetVariables
      <$> (o .:? "self")

-- | ToJSON XmlSdtmDatasetVariables
instance A.ToJSON XmlSdtmDatasetVariables where
  toJSON XmlSdtmDatasetVariables {..} =
   _omitNulls
      [ "self" .= xmlSdtmDatasetVariablesSelf
      ]


-- | Construct a value of type 'XmlSdtmDatasetVariables' (by applying it's required fields, if any)
mkXmlSdtmDatasetVariables
  :: XmlSdtmDatasetVariables
mkXmlSdtmDatasetVariables =
  XmlSdtmDatasetVariables
  { xmlSdtmDatasetVariablesSelf = Nothing
  }

-- ** XmlSdtmDatasets
-- | XmlSdtmDatasets
data XmlSdtmDatasets = XmlSdtmDatasets
  { xmlSdtmDatasetsSelf :: !(Maybe SdtmDatasets) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmDatasets
instance A.FromJSON XmlSdtmDatasets where
  parseJSON = A.withObject "XmlSdtmDatasets" $ \o ->
    XmlSdtmDatasets
      <$> (o .:? "self")

-- | ToJSON XmlSdtmDatasets
instance A.ToJSON XmlSdtmDatasets where
  toJSON XmlSdtmDatasets {..} =
   _omitNulls
      [ "self" .= xmlSdtmDatasetsSelf
      ]


-- | Construct a value of type 'XmlSdtmDatasets' (by applying it's required fields, if any)
mkXmlSdtmDatasets
  :: XmlSdtmDatasets
mkXmlSdtmDatasets =
  XmlSdtmDatasets
  { xmlSdtmDatasetsSelf = Nothing
  }

-- ** XmlSdtmProduct
-- | XmlSdtmProduct
data XmlSdtmProduct = XmlSdtmProduct
  { xmlSdtmProductSelf :: !(Maybe SdtmProduct) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmProduct
instance A.FromJSON XmlSdtmProduct where
  parseJSON = A.withObject "XmlSdtmProduct" $ \o ->
    XmlSdtmProduct
      <$> (o .:? "self")

-- | ToJSON XmlSdtmProduct
instance A.ToJSON XmlSdtmProduct where
  toJSON XmlSdtmProduct {..} =
   _omitNulls
      [ "self" .= xmlSdtmProductSelf
      ]


-- | Construct a value of type 'XmlSdtmProduct' (by applying it's required fields, if any)
mkXmlSdtmProduct
  :: XmlSdtmProduct
mkXmlSdtmProduct =
  XmlSdtmProduct
  { xmlSdtmProductSelf = Nothing
  }

-- ** XmlSdtmigClass
-- | XmlSdtmigClass
data XmlSdtmigClass = XmlSdtmigClass
  { xmlSdtmigClassSelf :: !(Maybe SdtmigClass) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmigClass
instance A.FromJSON XmlSdtmigClass where
  parseJSON = A.withObject "XmlSdtmigClass" $ \o ->
    XmlSdtmigClass
      <$> (o .:? "self")

-- | ToJSON XmlSdtmigClass
instance A.ToJSON XmlSdtmigClass where
  toJSON XmlSdtmigClass {..} =
   _omitNulls
      [ "self" .= xmlSdtmigClassSelf
      ]


-- | Construct a value of type 'XmlSdtmigClass' (by applying it's required fields, if any)
mkXmlSdtmigClass
  :: XmlSdtmigClass
mkXmlSdtmigClass =
  XmlSdtmigClass
  { xmlSdtmigClassSelf = Nothing
  }

-- ** XmlSdtmigClassDatasets
-- | XmlSdtmigClassDatasets
data XmlSdtmigClassDatasets = XmlSdtmigClassDatasets
  { xmlSdtmigClassDatasetsSelf :: !(Maybe SdtmigClassDatasets) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmigClassDatasets
instance A.FromJSON XmlSdtmigClassDatasets where
  parseJSON = A.withObject "XmlSdtmigClassDatasets" $ \o ->
    XmlSdtmigClassDatasets
      <$> (o .:? "self")

-- | ToJSON XmlSdtmigClassDatasets
instance A.ToJSON XmlSdtmigClassDatasets where
  toJSON XmlSdtmigClassDatasets {..} =
   _omitNulls
      [ "self" .= xmlSdtmigClassDatasetsSelf
      ]


-- | Construct a value of type 'XmlSdtmigClassDatasets' (by applying it's required fields, if any)
mkXmlSdtmigClassDatasets
  :: XmlSdtmigClassDatasets
mkXmlSdtmigClassDatasets =
  XmlSdtmigClassDatasets
  { xmlSdtmigClassDatasetsSelf = Nothing
  }

-- ** XmlSdtmigClasses
-- | XmlSdtmigClasses
data XmlSdtmigClasses = XmlSdtmigClasses
  { xmlSdtmigClassesSelf :: !(Maybe SdtmigClasses) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmigClasses
instance A.FromJSON XmlSdtmigClasses where
  parseJSON = A.withObject "XmlSdtmigClasses" $ \o ->
    XmlSdtmigClasses
      <$> (o .:? "self")

-- | ToJSON XmlSdtmigClasses
instance A.ToJSON XmlSdtmigClasses where
  toJSON XmlSdtmigClasses {..} =
   _omitNulls
      [ "self" .= xmlSdtmigClassesSelf
      ]


-- | Construct a value of type 'XmlSdtmigClasses' (by applying it's required fields, if any)
mkXmlSdtmigClasses
  :: XmlSdtmigClasses
mkXmlSdtmigClasses =
  XmlSdtmigClasses
  { xmlSdtmigClassesSelf = Nothing
  }

-- ** XmlSdtmigDataset
-- | XmlSdtmigDataset
data XmlSdtmigDataset = XmlSdtmigDataset
  { xmlSdtmigDatasetSelf :: !(Maybe SdtmigDataset) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmigDataset
instance A.FromJSON XmlSdtmigDataset where
  parseJSON = A.withObject "XmlSdtmigDataset" $ \o ->
    XmlSdtmigDataset
      <$> (o .:? "self")

-- | ToJSON XmlSdtmigDataset
instance A.ToJSON XmlSdtmigDataset where
  toJSON XmlSdtmigDataset {..} =
   _omitNulls
      [ "self" .= xmlSdtmigDatasetSelf
      ]


-- | Construct a value of type 'XmlSdtmigDataset' (by applying it's required fields, if any)
mkXmlSdtmigDataset
  :: XmlSdtmigDataset
mkXmlSdtmigDataset =
  XmlSdtmigDataset
  { xmlSdtmigDatasetSelf = Nothing
  }

-- ** XmlSdtmigDatasetVariable
-- | XmlSdtmigDatasetVariable
data XmlSdtmigDatasetVariable = XmlSdtmigDatasetVariable
  { xmlSdtmigDatasetVariableSelf :: !(Maybe SdtmigDatasetVariable) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmigDatasetVariable
instance A.FromJSON XmlSdtmigDatasetVariable where
  parseJSON = A.withObject "XmlSdtmigDatasetVariable" $ \o ->
    XmlSdtmigDatasetVariable
      <$> (o .:? "self")

-- | ToJSON XmlSdtmigDatasetVariable
instance A.ToJSON XmlSdtmigDatasetVariable where
  toJSON XmlSdtmigDatasetVariable {..} =
   _omitNulls
      [ "self" .= xmlSdtmigDatasetVariableSelf
      ]


-- | Construct a value of type 'XmlSdtmigDatasetVariable' (by applying it's required fields, if any)
mkXmlSdtmigDatasetVariable
  :: XmlSdtmigDatasetVariable
mkXmlSdtmigDatasetVariable =
  XmlSdtmigDatasetVariable
  { xmlSdtmigDatasetVariableSelf = Nothing
  }

-- ** XmlSdtmigDatasetVariables
-- | XmlSdtmigDatasetVariables
data XmlSdtmigDatasetVariables = XmlSdtmigDatasetVariables
  { xmlSdtmigDatasetVariablesSelf :: !(Maybe SdtmigDatasetVariables) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmigDatasetVariables
instance A.FromJSON XmlSdtmigDatasetVariables where
  parseJSON = A.withObject "XmlSdtmigDatasetVariables" $ \o ->
    XmlSdtmigDatasetVariables
      <$> (o .:? "self")

-- | ToJSON XmlSdtmigDatasetVariables
instance A.ToJSON XmlSdtmigDatasetVariables where
  toJSON XmlSdtmigDatasetVariables {..} =
   _omitNulls
      [ "self" .= xmlSdtmigDatasetVariablesSelf
      ]


-- | Construct a value of type 'XmlSdtmigDatasetVariables' (by applying it's required fields, if any)
mkXmlSdtmigDatasetVariables
  :: XmlSdtmigDatasetVariables
mkXmlSdtmigDatasetVariables =
  XmlSdtmigDatasetVariables
  { xmlSdtmigDatasetVariablesSelf = Nothing
  }

-- ** XmlSdtmigDatasets
-- | XmlSdtmigDatasets
data XmlSdtmigDatasets = XmlSdtmigDatasets
  { xmlSdtmigDatasetsSelf :: !(Maybe SdtmigDatasets) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmigDatasets
instance A.FromJSON XmlSdtmigDatasets where
  parseJSON = A.withObject "XmlSdtmigDatasets" $ \o ->
    XmlSdtmigDatasets
      <$> (o .:? "self")

-- | ToJSON XmlSdtmigDatasets
instance A.ToJSON XmlSdtmigDatasets where
  toJSON XmlSdtmigDatasets {..} =
   _omitNulls
      [ "self" .= xmlSdtmigDatasetsSelf
      ]


-- | Construct a value of type 'XmlSdtmigDatasets' (by applying it's required fields, if any)
mkXmlSdtmigDatasets
  :: XmlSdtmigDatasets
mkXmlSdtmigDatasets =
  XmlSdtmigDatasets
  { xmlSdtmigDatasetsSelf = Nothing
  }

-- ** XmlSdtmigProduct
-- | XmlSdtmigProduct
data XmlSdtmigProduct = XmlSdtmigProduct
  { xmlSdtmigProductSelf :: !(Maybe SdtmigProduct) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSdtmigProduct
instance A.FromJSON XmlSdtmigProduct where
  parseJSON = A.withObject "XmlSdtmigProduct" $ \o ->
    XmlSdtmigProduct
      <$> (o .:? "self")

-- | ToJSON XmlSdtmigProduct
instance A.ToJSON XmlSdtmigProduct where
  toJSON XmlSdtmigProduct {..} =
   _omitNulls
      [ "self" .= xmlSdtmigProductSelf
      ]


-- | Construct a value of type 'XmlSdtmigProduct' (by applying it's required fields, if any)
mkXmlSdtmigProduct
  :: XmlSdtmigProduct
mkXmlSdtmigProduct =
  XmlSdtmigProduct
  { xmlSdtmigProductSelf = Nothing
  }

-- ** XmlSendigClass
-- | XmlSendigClass
data XmlSendigClass = XmlSendigClass
  { xmlSendigClassSelf :: !(Maybe SendigClass) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSendigClass
instance A.FromJSON XmlSendigClass where
  parseJSON = A.withObject "XmlSendigClass" $ \o ->
    XmlSendigClass
      <$> (o .:? "self")

-- | ToJSON XmlSendigClass
instance A.ToJSON XmlSendigClass where
  toJSON XmlSendigClass {..} =
   _omitNulls
      [ "self" .= xmlSendigClassSelf
      ]


-- | Construct a value of type 'XmlSendigClass' (by applying it's required fields, if any)
mkXmlSendigClass
  :: XmlSendigClass
mkXmlSendigClass =
  XmlSendigClass
  { xmlSendigClassSelf = Nothing
  }

-- ** XmlSendigClassDatasets
-- | XmlSendigClassDatasets
data XmlSendigClassDatasets = XmlSendigClassDatasets
  { xmlSendigClassDatasetsSelf :: !(Maybe SendigClassDatasets) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSendigClassDatasets
instance A.FromJSON XmlSendigClassDatasets where
  parseJSON = A.withObject "XmlSendigClassDatasets" $ \o ->
    XmlSendigClassDatasets
      <$> (o .:? "self")

-- | ToJSON XmlSendigClassDatasets
instance A.ToJSON XmlSendigClassDatasets where
  toJSON XmlSendigClassDatasets {..} =
   _omitNulls
      [ "self" .= xmlSendigClassDatasetsSelf
      ]


-- | Construct a value of type 'XmlSendigClassDatasets' (by applying it's required fields, if any)
mkXmlSendigClassDatasets
  :: XmlSendigClassDatasets
mkXmlSendigClassDatasets =
  XmlSendigClassDatasets
  { xmlSendigClassDatasetsSelf = Nothing
  }

-- ** XmlSendigClasses
-- | XmlSendigClasses
data XmlSendigClasses = XmlSendigClasses
  { xmlSendigClassesSelf :: !(Maybe SendigClasses) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSendigClasses
instance A.FromJSON XmlSendigClasses where
  parseJSON = A.withObject "XmlSendigClasses" $ \o ->
    XmlSendigClasses
      <$> (o .:? "self")

-- | ToJSON XmlSendigClasses
instance A.ToJSON XmlSendigClasses where
  toJSON XmlSendigClasses {..} =
   _omitNulls
      [ "self" .= xmlSendigClassesSelf
      ]


-- | Construct a value of type 'XmlSendigClasses' (by applying it's required fields, if any)
mkXmlSendigClasses
  :: XmlSendigClasses
mkXmlSendigClasses =
  XmlSendigClasses
  { xmlSendigClassesSelf = Nothing
  }

-- ** XmlSendigDataset
-- | XmlSendigDataset
data XmlSendigDataset = XmlSendigDataset
  { xmlSendigDatasetSelf :: !(Maybe SendigDataset) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSendigDataset
instance A.FromJSON XmlSendigDataset where
  parseJSON = A.withObject "XmlSendigDataset" $ \o ->
    XmlSendigDataset
      <$> (o .:? "self")

-- | ToJSON XmlSendigDataset
instance A.ToJSON XmlSendigDataset where
  toJSON XmlSendigDataset {..} =
   _omitNulls
      [ "self" .= xmlSendigDatasetSelf
      ]


-- | Construct a value of type 'XmlSendigDataset' (by applying it's required fields, if any)
mkXmlSendigDataset
  :: XmlSendigDataset
mkXmlSendigDataset =
  XmlSendigDataset
  { xmlSendigDatasetSelf = Nothing
  }

-- ** XmlSendigDatasetVariable
-- | XmlSendigDatasetVariable
data XmlSendigDatasetVariable = XmlSendigDatasetVariable
  { xmlSendigDatasetVariableSelf :: !(Maybe SendigDatasetVariable) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSendigDatasetVariable
instance A.FromJSON XmlSendigDatasetVariable where
  parseJSON = A.withObject "XmlSendigDatasetVariable" $ \o ->
    XmlSendigDatasetVariable
      <$> (o .:? "self")

-- | ToJSON XmlSendigDatasetVariable
instance A.ToJSON XmlSendigDatasetVariable where
  toJSON XmlSendigDatasetVariable {..} =
   _omitNulls
      [ "self" .= xmlSendigDatasetVariableSelf
      ]


-- | Construct a value of type 'XmlSendigDatasetVariable' (by applying it's required fields, if any)
mkXmlSendigDatasetVariable
  :: XmlSendigDatasetVariable
mkXmlSendigDatasetVariable =
  XmlSendigDatasetVariable
  { xmlSendigDatasetVariableSelf = Nothing
  }

-- ** XmlSendigDatasetVariables
-- | XmlSendigDatasetVariables
data XmlSendigDatasetVariables = XmlSendigDatasetVariables
  { xmlSendigDatasetVariablesSelf :: !(Maybe SendigDatasetVariables) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSendigDatasetVariables
instance A.FromJSON XmlSendigDatasetVariables where
  parseJSON = A.withObject "XmlSendigDatasetVariables" $ \o ->
    XmlSendigDatasetVariables
      <$> (o .:? "self")

-- | ToJSON XmlSendigDatasetVariables
instance A.ToJSON XmlSendigDatasetVariables where
  toJSON XmlSendigDatasetVariables {..} =
   _omitNulls
      [ "self" .= xmlSendigDatasetVariablesSelf
      ]


-- | Construct a value of type 'XmlSendigDatasetVariables' (by applying it's required fields, if any)
mkXmlSendigDatasetVariables
  :: XmlSendigDatasetVariables
mkXmlSendigDatasetVariables =
  XmlSendigDatasetVariables
  { xmlSendigDatasetVariablesSelf = Nothing
  }

-- ** XmlSendigDatasets
-- | XmlSendigDatasets
data XmlSendigDatasets = XmlSendigDatasets
  { xmlSendigDatasetsSelf :: !(Maybe SendigDatasets) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSendigDatasets
instance A.FromJSON XmlSendigDatasets where
  parseJSON = A.withObject "XmlSendigDatasets" $ \o ->
    XmlSendigDatasets
      <$> (o .:? "self")

-- | ToJSON XmlSendigDatasets
instance A.ToJSON XmlSendigDatasets where
  toJSON XmlSendigDatasets {..} =
   _omitNulls
      [ "self" .= xmlSendigDatasetsSelf
      ]


-- | Construct a value of type 'XmlSendigDatasets' (by applying it's required fields, if any)
mkXmlSendigDatasets
  :: XmlSendigDatasets
mkXmlSendigDatasets =
  XmlSendigDatasets
  { xmlSendigDatasetsSelf = Nothing
  }

-- ** XmlSendigProduct
-- | XmlSendigProduct
data XmlSendigProduct = XmlSendigProduct
  { xmlSendigProductSelf :: !(Maybe SendigProduct) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON XmlSendigProduct
instance A.FromJSON XmlSendigProduct where
  parseJSON = A.withObject "XmlSendigProduct" $ \o ->
    XmlSendigProduct
      <$> (o .:? "self")

-- | ToJSON XmlSendigProduct
instance A.ToJSON XmlSendigProduct where
  toJSON XmlSendigProduct {..} =
   _omitNulls
      [ "self" .= xmlSendigProductSelf
      ]


-- | Construct a value of type 'XmlSendigProduct' (by applying it's required fields, if any)
mkXmlSendigProduct
  :: XmlSendigProduct
mkXmlSendigProduct =
  XmlSendigProduct
  { xmlSendigProductSelf = Nothing
  }


-- * Enums


-- ** DefaultSearchScopes

-- | Enum of 'Text'
data DefaultSearchScopes
  = DefaultSearchScopes'Class -- ^ @"class"@
  | DefaultSearchScopes'Codelist -- ^ @"codelist"@
  | DefaultSearchScopes'ConceptId -- ^ @"conceptId"@
  | DefaultSearchScopes'Core -- ^ @"core"@
  | DefaultSearchScopes'DataStructure -- ^ @"dataStructure"@
  | DefaultSearchScopes'DatasetStructure -- ^ @"datasetStructure"@
  | DefaultSearchScopes'Definition -- ^ @"definition"@
  | DefaultSearchScopes'Description -- ^ @"description"@
  | DefaultSearchScopes'Domain -- ^ @"domain"@
  | DefaultSearchScopes'EffectiveDate -- ^ @"effectiveDate"@
  | DefaultSearchScopes'Extensible -- ^ @"extensible"@
  | DefaultSearchScopes'Href -- ^ @"href"@
  | DefaultSearchScopes'Label -- ^ @"label"@
  | DefaultSearchScopes'MeasureType -- ^ @"measureType"@
  | DefaultSearchScopes'Name -- ^ @"name"@
  | DefaultSearchScopes'PreferredTerm -- ^ @"preferredTerm"@
  | DefaultSearchScopes'Product -- ^ @"product"@
  | DefaultSearchScopes'ProductGroup -- ^ @"productGroup"@
  | DefaultSearchScopes'RegistrationStatus -- ^ @"registrationStatus"@
  | DefaultSearchScopes'RoleDescription -- ^ @"roleDescription"@
  | DefaultSearchScopes'SdtmTarget -- ^ @"sdtmTarget"@
  | DefaultSearchScopes'SimpleDatatype -- ^ @"simpleDatatype"@
  | DefaultSearchScopes'SubmissionValue -- ^ @"submissionValue"@
  | DefaultSearchScopes'Synonyms -- ^ @"synonyms"@
  | DefaultSearchScopes'Type -- ^ @"type"@
  | DefaultSearchScopes'UiHref -- ^ @"uiHref"@
  | DefaultSearchScopes'ValueDomain -- ^ @"valueDomain"@
  | DefaultSearchScopes'VariableSet -- ^ @"variableSet"@
  | DefaultSearchScopes'Version -- ^ @"version"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON DefaultSearchScopes where toJSON = A.toJSON . fromDefaultSearchScopes
instance A.FromJSON DefaultSearchScopes where parseJSON o = P.either P.fail (pure . P.id) . toDefaultSearchScopes =<< A.parseJSON o
instance WH.ToHttpApiData DefaultSearchScopes where toQueryParam = WH.toQueryParam . fromDefaultSearchScopes
instance WH.FromHttpApiData DefaultSearchScopes where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toDefaultSearchScopes
instance MimeRender MimeMultipartFormData DefaultSearchScopes where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'DefaultSearchScopes' enum
fromDefaultSearchScopes :: DefaultSearchScopes -> Text
fromDefaultSearchScopes = \case
  DefaultSearchScopes'Class -> "class"
  DefaultSearchScopes'Codelist -> "codelist"
  DefaultSearchScopes'ConceptId -> "conceptId"
  DefaultSearchScopes'Core -> "core"
  DefaultSearchScopes'DataStructure -> "dataStructure"
  DefaultSearchScopes'DatasetStructure -> "datasetStructure"
  DefaultSearchScopes'Definition -> "definition"
  DefaultSearchScopes'Description -> "description"
  DefaultSearchScopes'Domain -> "domain"
  DefaultSearchScopes'EffectiveDate -> "effectiveDate"
  DefaultSearchScopes'Extensible -> "extensible"
  DefaultSearchScopes'Href -> "href"
  DefaultSearchScopes'Label -> "label"
  DefaultSearchScopes'MeasureType -> "measureType"
  DefaultSearchScopes'Name -> "name"
  DefaultSearchScopes'PreferredTerm -> "preferredTerm"
  DefaultSearchScopes'Product -> "product"
  DefaultSearchScopes'ProductGroup -> "productGroup"
  DefaultSearchScopes'RegistrationStatus -> "registrationStatus"
  DefaultSearchScopes'RoleDescription -> "roleDescription"
  DefaultSearchScopes'SdtmTarget -> "sdtmTarget"
  DefaultSearchScopes'SimpleDatatype -> "simpleDatatype"
  DefaultSearchScopes'SubmissionValue -> "submissionValue"
  DefaultSearchScopes'Synonyms -> "synonyms"
  DefaultSearchScopes'Type -> "type"
  DefaultSearchScopes'UiHref -> "uiHref"
  DefaultSearchScopes'ValueDomain -> "valueDomain"
  DefaultSearchScopes'VariableSet -> "variableSet"
  DefaultSearchScopes'Version -> "version"

-- | parse 'DefaultSearchScopes' enum
toDefaultSearchScopes :: Text -> P.Either String DefaultSearchScopes
toDefaultSearchScopes = \case
  "class" -> P.Right DefaultSearchScopes'Class
  "codelist" -> P.Right DefaultSearchScopes'Codelist
  "conceptId" -> P.Right DefaultSearchScopes'ConceptId
  "core" -> P.Right DefaultSearchScopes'Core
  "dataStructure" -> P.Right DefaultSearchScopes'DataStructure
  "datasetStructure" -> P.Right DefaultSearchScopes'DatasetStructure
  "definition" -> P.Right DefaultSearchScopes'Definition
  "description" -> P.Right DefaultSearchScopes'Description
  "domain" -> P.Right DefaultSearchScopes'Domain
  "effectiveDate" -> P.Right DefaultSearchScopes'EffectiveDate
  "extensible" -> P.Right DefaultSearchScopes'Extensible
  "href" -> P.Right DefaultSearchScopes'Href
  "label" -> P.Right DefaultSearchScopes'Label
  "measureType" -> P.Right DefaultSearchScopes'MeasureType
  "name" -> P.Right DefaultSearchScopes'Name
  "preferredTerm" -> P.Right DefaultSearchScopes'PreferredTerm
  "product" -> P.Right DefaultSearchScopes'Product
  "productGroup" -> P.Right DefaultSearchScopes'ProductGroup
  "registrationStatus" -> P.Right DefaultSearchScopes'RegistrationStatus
  "roleDescription" -> P.Right DefaultSearchScopes'RoleDescription
  "sdtmTarget" -> P.Right DefaultSearchScopes'SdtmTarget
  "simpleDatatype" -> P.Right DefaultSearchScopes'SimpleDatatype
  "submissionValue" -> P.Right DefaultSearchScopes'SubmissionValue
  "synonyms" -> P.Right DefaultSearchScopes'Synonyms
  "type" -> P.Right DefaultSearchScopes'Type
  "uiHref" -> P.Right DefaultSearchScopes'UiHref
  "valueDomain" -> P.Right DefaultSearchScopes'ValueDomain
  "variableSet" -> P.Right DefaultSearchScopes'VariableSet
  "version" -> P.Right DefaultSearchScopes'Version
  s -> P.Left $ "toDefaultSearchScopes: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthBasicBasicAuth
data AuthBasicBasicAuth =
  AuthBasicBasicAuth B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicBasicAuth where
  applyAuthMethod _ a@(AuthBasicBasicAuth user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])


